<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LaPluma</title>
  
  <subtitle>Keep it simple and stupid.</subtitle>
  <link href="http://la-pluma.github.io/atom.xml" rel="self"/>
  
  <link href="http://la-pluma.github.io/"/>
  <updated>2024-09-21T18:20:42.472Z</updated>
  <id>http://la-pluma.github.io/</id>
  
  <author>
    <name>LaPluma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode个人题解[C++] P4 寻找两个正序数组的中位数</title>
    <link href="http://la-pluma.github.io/2024/09/21/LeetCode-P4/"/>
    <id>http://la-pluma.github.io/2024/09/21/LeetCode-P4/</id>
    <published>2024-09-21T12:29:30.000Z</published>
    <updated>2024-09-21T18:20:42.472Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong> <ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><strong>LeetCode|4.寻找两个正序数组的中位数</strong></a></p><span id="more"></span><hr /><h2 id="题面解释">题面解释</h2><p>找出两个有序数组合并后的中位数. 但要求时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><h2 id="解法一-二分">解法一 二分</h2><p>笔者看到复杂度<span class="math inline">\(\mathit{O}(log(m +n))\)</span>第一想法便是二分, 但怎么二分? 两个数组只是内部有序,两个数组并不有序, 常规对数组二分的思路肯定是不行的.</p><p>那该如何进行二分呢, 对答案进行二分. 令k为所寻找的k阶数, 初始为中位数,则此时我们取两个数组的前<spanclass="math inline">\(k/2\)</span>部分出来, 比较<spanclass="math inline">\(nums1[k/2]\)</span>和<spanclass="math inline">\(nums2[k/2]\)</span>, 则可以直接排除<spanclass="math inline">\(k/2\)</span>个数. 我们以下图例子来解释.</p><img src="/2024/09/21/LeetCode-P4/p1.png" class="" title="p1"><p><span class="math inline">\(m = n = 4\)</span>, 我们有 <spanclass="math inline">\(k = 4, k/2 = 2\)</span>,于是我们取两个数组的前两位, 比较3和5, 不难看出, 1和3不可能是中位数.为什么? 因为1和3的阶必定小于<span class="math inline">\(k = 4\)</span>,即便第一个数组的3比第二个数组的5前面所有数都大, 3的阶也只能是3,1就更不必说了. 而5前面的数可能大于3后面的数(例子中未能体现,读者可以自行构造一个满足这种情况的简单例子). 因此通过这种操作,我们可以排掉 <span class="math inline">\(k/2\)</span>个不可能是中位数的元素, 接着我们令<span class="math inline">\(k = k -k/2\)</span>, 将被排除的数去掉, 重新进行上述过程.</p><img src="/2024/09/21/LeetCode-P4/p2.png" class="" title="p2"><p>选取两个数组的前1位.比较2 和 4, 可以排除掉2. 此时过程进行到了边界处,接下来<span class="math inline">\(k = 1\)</span>无法继续了.而此时剩下的4和5正是我们需要的中位数.</p><blockquote><p><strong>Tips:</strong> 为什么第二个数组不是选择2, 5, 7?</p><p>因为我们在上面的步骤中无法确定2和5是中位数与否, 此时的有效信息不足.而把2 5 7都放进来与4进行比较会出现bug, 以上例, 4会被错误的排除掉</p></blockquote><p>k为奇数时情况稍有不同, 但大多是一些细节问题, 笔者在此不再赘述.推荐读者自己构建一个例子去推算上面的过程, 相信不难理解其中要义.</p><p>每次排除<span class="math inline">\(k/2\)</span>, 而 <spanclass="math inline">\(k = (m + n + 1) / 2\)</span>, 故时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><p>参考代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; m; i++)&#123;cout &lt;&lt; nums1[i] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; n; j++)&#123;cout &lt;&lt; nums2[j] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = (m + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 排除掉小于中位数的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组被清空</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// 注意循环条件 k &gt; 1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 边界情况，剩余数组大小不足k</span></span><br><span class="line">            <span class="keyword">if</span> (left1 + mid &gt; m) &#123; <span class="comment">// 等价于 left1 + mid - 1 &gt;= m</span></span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 + mid &gt; n) &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                k -= mid2 - left2 + <span class="number">1</span>; <span class="comment">// 一轮可以排除掉一半</span></span><br><span class="line">                left2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= mid1 - left1 + <span class="number">1</span>;</span><br><span class="line">                left1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 k == 1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                    left2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="built_in">return</span> (nums2[left2] + nums2[left2 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[left1] + nums1[left1 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num1;</span><br><span class="line">            <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                num1 = nums2[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = nums1[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                num2 = nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                num2 = nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (num1 + num2) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 本题思路并不难想出或者说并不难理解,但非常考验代码功底, 对细节和边界情况的考察更像是此题的侧重点.还望看到此处的读者能静下心来调试代码, 祝早日AC.</p></blockquote><h2 id="解法二-分割">解法二 分割</h2><blockquote><p>笔者阅读题解时注意到的巧妙的解法, 原链接在此<ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/"><strong>P4|windliang</strong></a></p></blockquote><p>更详细的数学证明, 思路和代码请阅读原文,笔者在此只给出自己对其的理解.</p><p>本质来说, 两种方法殊途同归, 但分割的方法较为巧妙一些. 中位数,或者说k阶数, 就是将数组分为两个部分, 其一是比k阶数小的部分,其二是比k阶数大的部分.</p><p>对于有序的一个数组, 其性质本身就已经满足,我们不妨将两部分简称为左半部分(小)和右半部分(大). 对于两个有序数组,情况是一样的, 如果存在一种划分, 满足左边最大MaxLeft小于右边最小MinRight,我们则认为这是关于k阶数的一种有效划分.</p><p>因此, 这道题就被转化为寻找数组中满足中位数的有效划分,关于特定k阶数划分, 还需要满足左半部分和右半部分的数量关系,若规定将k阶数划在左半部分, 则左半部分有k个元素, 右半部分有 n - k个元素.</p><p>后面的事情就简单了, 固定数组1的划分位置,根据数量关系找到数组2待判定划分位置,根据MaxLeft和MinRight的大小关系决定数组1划分位置的左移或右移,该过程可以通过二分完成.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt; &lt;a
href=&quot;https://leetcode.cn/problems/median-of-two-sorted-arrays/&quot;&gt;&lt;strong&gt;LeetCode|4.寻找两个正序数组的中位数&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode刷题记录" scheme="http://la-pluma.github.io/categories/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="http://la-pluma.github.io/tags/LeetCode/"/>
    
    <category term="二分" scheme="http://la-pluma.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-机器学习 Ch0-Ch1</title>
    <link href="http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/"/>
    <id>http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/</id>
    <published>2024-09-18T15:04:27.000Z</published>
    <updated>2024-09-24T11:34:07.166Z</updated>
    
    <content type="html"><![CDATA[<p><strong>机器学习所研究的主要内容,是关于在计算机上从数据中产生"模型"(model)的算法, 即"学习算法"(learningalgorithm).</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter-0-主要符号表">Chapter 0: 主要符号表</a></li><li><a href="#chapter-1-绪论">Chapter 1: 绪论</a><ul><li><a href="#11-基本术语">1.1 基本术语</a></li><li><a href="#13-假设空间">1.3 假设空间</a></li><li><a href="#14-归纳偏好">1.4 归纳偏好</a></li></ul></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>《机器学习》周志华 2016.</p><p>大名鼎鼎的西瓜书, 笔者在此略去介绍.</p><h2 id="chapter-0-主要符号表">Chapter 0: 主要符号表</h2><p><span class="math display">\[\begin{aligned}&amp;\mathit{x}&amp; &amp;标量\\&amp;\boldsymbol{x}&amp; &amp;向量 \\&amp;\mathrm{x}&amp; &amp;变量集 \\&amp;\mathbf{A}&amp; &amp;矩阵 \\&amp;\mathbf{I}&amp; &amp;单位阵 \\&amp;\mathcal{X}&amp; &amp;样本空间或状态空间\\&amp;\mathcal{D}&amp; &amp;概率分布\\&amp;\mathit{D}&amp; &amp;数据样本(数据集)\\&amp;\mathcal{H}&amp; &amp;假设空间\\&amp;\mathit{H}&amp; &amp;假设集\\&amp;\mathfrak{L}&amp; &amp;学习算法\\&amp;\left ( \cdot ,\cdot ,\cdot  \right )&amp; &amp;行向量\\&amp;\left ( \cdot ;\cdot ;\cdot \right )&amp; &amp;列向量\\&amp;\left ( \cdot  \right )^{T}&amp; &amp;向量或矩阵转置\\&amp;\left \{  \cdot \cdot \cdot \right \}&amp; &amp;集合\\&amp;\left | \left \{ \cdot \cdot \cdot \right \} \right |&amp;&amp;集合中元素个数\\&amp;\left \| \cdot  \right \|_{p}&amp; &amp;L_p范数, p缺省时为L_2范数\\&amp;\mathit{P}\left ( \cdot  \right ),\mathit{P}\left ( \cdot|\cdot  \right )&amp; &amp;概率质量函数,条件概率质量函数\\&amp;\mathit{p}\left ( \cdot  \right ),\mathit{p}\left ( \cdot  | \cdot\right )&amp; &amp;概率密度函数, 条件概率密度函数\\&amp;\mathbb{E}_{\cdot \sim \mathcal{D}}\left [ f\! \left ( \cdot \right) \right ]&amp; &amp;函数 f\! \left ( \cdot \right ) 对 \cdot 在分布\mathcal{D} 下的数学期望:意义明确是将省略 \mathcal{D} 和(或)\cdot \\&amp;sup\left ( \cdot \right )&amp; &amp;上确界\\&amp;\mathbb{I}\! \left ( \cdot  \right )&amp; &amp;指示函数，在\cdot  为真和假分别取值为1 , 0 \\&amp;sign\left ( \cdot  \right )&amp; &amp;符号函数，在 \cdot &lt; 0, =0 , &gt;  0 时分别取值为 -1,0,1\end{aligned}\]</span></p><h2 id="chapter-1-绪论">Chapter 1: 绪论</h2><h3 id="基本术语">1.1 基本术语</h3><blockquote><p>假定我们收集了一批关于西瓜的数据, 例如(色泽 = 浅白; 根蒂 = 蜷缩; 敲声= 浊响), (色泽 = 乌黑; 根蒂 = 稍蜷; 敲声 = 沉闷), (色泽 = 浅白; 根蒂 =硬挺; 敲声 = 清脆), ......, 每对括号内是一条记录,下文关于术语的表述会基于上述假定进行解释.</p></blockquote><ul><li><p><strong>数据集/样本(Data Set):</strong>这组记录的集合称为一个数据集.</p><blockquote><p><strong>Tips:</strong> 数据集亦称样本,因为数据集可看作对样本空间的一个采样.</p><p><strong>Addtional:</strong> "样本"的具体指代示例还是数据集,要看具体的上下文.</p></blockquote></li><li><p><strong>示例(Instance)/样本(Sample):</strong>每条记录称为示例/样本, 是关于一个事件或对象的描述(以上例,该对象为西瓜).</p></li><li><p><strong>属性(Attribute)/特征(Feature):</strong> "色泽", "根蒂","敲声"称为属性.</p></li><li><p><strong>属性值(Attribute Value):</strong>属性的取值称为属性值(以上例, "青绿"和"乌黑"是色泽的属性值).</p></li><li><p><strong>属性空间(Attribute Space)/样本空间(SampleSpace)/输入空间:</strong> 属性张成的空间.</p><blockquote><p><strong>Tips:</strong> 此处涉及的是线性代数知识,即将样本(Instance)依据属性转化为向量, 其中色泽, 根蒂和敲声为坐标轴,张成了一个用于描述西瓜特征的三维空间,该空间每个点即是线性代数意义上的一个向量, 也就是<strong>特征向量(FeatureVector)</strong>. 我们可以认为,示例(Instance)的另一种等价表述是特征向量.</p></blockquote></li><li><p><strong>数据集的表示:</strong> 令 <spanclass="math inline">\(\mathit{D} = \{x_1, x_2, ..., x_m\}\)</span>表示包含<span class="math inline">\(m\)</span>个示例的数据集, 每个示例由<span class="math inline">\(d\)</span> 个属性描述, 则每个示例(Instance)<span class="math inline">\(x_i= (x_{i1}; x_{i2}; ...; x_{id})\)</span>是 <span class="math inline">\(d\)</span> 维样本空间 <spanclass="math inline">\(\mathcal{X}\)</span> 中的一个向量, <spanclass="math inline">\(x_i \in \mathcal{X}\)</span>. <spanclass="math inline">\(d\)</span> 称为样本 <spanclass="math inline">\(x_i\)</span>的<strong>维数(Dimensionality)</strong>.</p></li><li><p><strong>学习(Learning)/训练(Training):</strong>从数据中学得模型的过程称为学习/训练,该过程通过执行某个学习算法完成.</p></li><li><p><strong>训练数据(Training Data):</strong>训练过程中所使用的数据.</p></li><li><p><strong>训练样本(Training Sample)/训练示例(TrainingInstance):</strong> 训练数据中的每个样本/示例.</p></li><li><p><strong>训练集(Training Set):</strong>训练样本组成的集合称为训练集.</p><blockquote><p><strong>Tips:</strong> 训练集相当于训练数据的子集,训练数据除去<strong>训练集</strong>外还存在<strong>验证集</strong>.(参考自:<ahref="https://zhuanlan.zhihu.com/p/115344944"><strong>知乎|训练集(trainingdataset), 测试集(test dataset)与验证集(validationdataset)</strong></a>)</p></blockquote></li><li><p><strong>假设(Hypothesis)&amp;真相/真实(Ground-Truth):</strong>学得模型对应了关于数据的某种潜在规律,因此亦称假设.这种潜在规律称为"真相"/"真实".学习的过程就是为了找出或逼近真相.</p><blockquote><p><strong>Tips:</strong> <ahref="https://en.wikipedia.org/wiki/Ground_truth"><strong>WIKIPEDIA|Ground-Truth</strong></a>又将其表述为<strong>基准真相</strong>.</p><p>"Ground truth is information that is known to be real or true,provided by direct observation and measurement (i.e. empirical evidence)as opposed to information provided by inference."</p></blockquote></li></ul><p><strong>Tips:</strong>本书有时又将<strong>模型</strong>称为<strong>学习器(Learner)</strong>,模型可看作是学习算法在给定数据和参数空间上的实例化.</p><ul><li><p><strong>标记(Label):</strong> 关于示例(Instance)结果的信息,称为标记(如"好瓜"). 一般的, 用 <span class="math inline">\((x_i,y_i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个样例, 其中<span class="math inline">\(y_i \in \mathcal{Y}\)</span> 是示例 <spanclass="math inline">\(x_i\)</span> 的标记, <spanclass="math inline">\(\mathcal{Y}\)</span> 是所有标记的集合,又称<strong>标记空间(Label Space)/输出空间</strong>.</p></li><li><p><strong>分类(Classification):</strong>若<strong>预测(Prediction)</strong>的是离散值(如"好瓜", "坏瓜"),则称此类学习任务是分类.</p></li><li><p><strong>回归(Regression):</strong> 若预测的是连续值(如成熟度0.95,0.7), 则称此类学习任务是回归.</p></li><li><p><strong>二分类(Binary Classification):</strong>只涉及两个类别的分类任务, 通常称其中一类为<strong>正类(PositiveClass)</strong>, 另一类为<strong>反类(Negative Class)</strong>.</p></li><li><p><strong>多分类(Multi-class Classification):</strong> 与之相对的,涉及多种类别的分类任务称为多分类任务.</p></li><li><p><strong>预测任务:</strong> 预测任务希望通过对训练集<spanclass="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m,y_m)\}\)</span> 进行学习, 建立一个从输入空间 <spanclass="math inline">\(\mathcal{X}\)</span> 到输出空间 <spanclass="math inline">\(\mathcal{Y}\)</span> 的映射 <spanclass="math inline">\(f : \mathcal{X} \rightarrow \mathcal{Y}\)</span>.对二分类, 通常取 <span class="math inline">\(\mathcal{Y} = \{-1,1\}\)</span> 或 <span class="math inline">\(\{0, 1\}\)</span>;对于多分类, <span class="math inline">\(|\mathcal{Y}| &gt; 2\)</span>;对于回归, <span class="math inline">\(\mathcal{Y} =\mathbb{R}\)</span>.</p></li><li><p><strong>测试(Testing):</strong>使用学习得到的模型进行预测的过程称为测试,预测的样本称为<strong>测试样本(Testing Sample)/测试示例(TestingInstance)</strong>.</p></li><li><p><strong>聚类(Clustering):</strong> 将训练集中的样本分为若干组,每组称为一个<strong>簇(Cluster)</strong>.</p><blockquote><p><strong>Tips:</strong> 形成的簇可能对应一些潜在的概念划分(如本地瓜,外地瓜), 但这样的概念我们事先不知道,否则通过标记(Label)就可以形成簇划分.</p></blockquote></li><li><p><strong>监督学习(Supervised Learning)/有导师学习:</strong>训练数据拥有标记信息, 分类和回归为代表.</p></li><li><p><strong>无监督学习(Unsupervised Learning)/无导师学习</strong>训练数据无标记信息, 聚类为代表.</p></li></ul><blockquote><p><strong>Tips:</strong> 此处仅作最基本的概念了解,关于上述两概念的具体释义留及之后的学习.</p></blockquote><ul><li><p><strong>泛化(Generalization):</strong>学得模型适用于新样本的能力,称为泛化能力.</p><blockquote><p><strong>Tips1:</strong> 样本空间通常很大, 训练过程无法涵盖所有的示例,我们希望模型可以对新样本有较好的目标表现, 这就是泛化的意义.</p><p><strong>Tips2:</strong> 泛化的数学支撑:</p><p>关于这种泛化,我们通常假设样本空间中的所有样本都服从一个未知的<strong>分布(Distribution)</strong><span class="math inline">\(\mathcal{D}\)</span>,获取的样本是从该分布上采样获得的, 满足<strong>独立同分布(Independent andIdentically Distributed, <em>i.d.d</em>)</strong>.</p><p>关于机器学习中为什么使用i.d.d, 可以从<ahref="https://www.zhihu.com/question/41222495"><strong>知乎|为什么机器学习中,要假设我们的数据是独立同分布的?</strong></a>获取相关信息.</p></blockquote></li></ul><h3 id="假设空间">1.3 假设空间</h3><p><strong>归纳(Induction)</strong>与<strong>演绎(Deduction)</strong>是科学推理的两大基本手段.</p><blockquote><p>前者是从特殊到一般的<strong>泛化(Generalization)</strong>过程;后者是从一般到特殊的<strong>特化(Specialization)</strong>过程.</p></blockquote><ul><li><p><strong>归纳学习(Inductive Learning):</strong>广义的归纳学习大体相当于从样例中学习,狭义的归纳学习要求从学习过程中习得<strong>概念(concept)</strong>,亦称<strong>概念学习/概念形成</strong>.</p></li><li><p><strong>版本空间(Version Space):</strong>存在一个与训练集一致的"假设集合", 称为版本空间, 例如:</p></li></ul><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/table1-1.png" class="" title="table1-1"><p>其假设空间为</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-1.png" class="" title="pic1-1"><p>其版本空间为</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-2.png" class="" title="pic1-2"><blockquote><p><strong>Tips:</strong> 在该数据集中, 好瓜具有的共同特征是蜷缩和浊响.因此色泽标识为通配符 <span class="math inline">\(*\)</span>, 同时,第一行的两种假设同样是与训练集一致的(可以匹配好瓜).</p></blockquote><h3 id="归纳偏好">1.4 归纳偏好</h3><ul><li><p><strong>归纳偏好(Inductive bias):</strong>算法在学习过程中对某种类型假设的偏好称为归纳偏好.</p><blockquote><p><strong>Tips:</strong><strong>任何</strong>一个有效的机器学习算法必有其归纳偏好,否则它无法产生确定的学习结果.</p><p>以图1-2的版本空间为例, 对新瓜(色泽=青绿;根蒂=蜷缩;敲声=沉闷),若模型告诉我们这种瓜时好时坏则没有意义,模型必须对给定的样本给予确定的结果.</p><p><strong>Additional:</strong>归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或"价值观".常遵循<strong>奥卡姆剃刀(Occam'sRazor)</strong>原则(<strong>若有多个假设与观察一致,则选简单的那个</strong>).</p></blockquote></li></ul><p>接下来我们来比较不同归纳偏好的优劣</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-3.png" class="" title="pic1-3"><p>从直观上看我们一般会认为, 拟合出平滑的曲线A要优于曲线B, 但很遗憾,当面临一些极端数据时, 曲线B可能会优于曲线A, 情形如下图所示.</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-4.png" class="" title="pic1-4"><p>接下来我们用数学语言尝试量化模型的优劣.</p><p>假设样本空间 <span class="math inline">\(\mathcal{X}\)</span>和假设空间 <span class="math inline">\(\mathcal{H}\)</span> 都是离散的,令 <span class="math inline">\(P(h|X, \mathfrak{L})\)</span>代表学习算法 <span class="math inline">\(\mathfrak{L}_a\)</span>基于训练数据 <span class="math inline">\(X\)</span> 产生假设 <spanclass="math inline">\(h\)</span> 的概率, 令 <spanclass="math inline">\(f\)</span> 为目标函数.则 <spanclass="math inline">\(\mathfrak{L}_a\)</span>在训练集外的所有样本上的误差为</p><p><span class="math display">\[\begin{equation} \label{eq1.1}E_{ote}(\mathfrak{L}_a|X, f) = \sum_h \sum_{x \in \mathcal{X} -X} P(x)\mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\tag{1.1}\end{equation}\]</span></p><blockquote><p><strong>Tips:</strong>以下是笔者个人对该公式的理解,可能存在疏漏或错误.</p><p>首先看乘起来的的三个式子, <spanclass="math inline">\(\mathbb{I}\)</span> 为指示函数, 代表的含义是假设<span class="math inline">\(h\)</span> 与目标函数 <spanclass="math inline">\(f\)</span> 没有误差时取0, 存在误差时取1. 若取1,则两个概率乘积表示在给定的<span class="math inline">\(x\)</span>和<spanclass="math inline">\(h\)</span>下, 存在误差的概率.</p><p>接下来的两个求和就不难理解了, 分别是对<spanclass="math inline">\(x\)</span>的所有取值求和以及对<spanclass="math inline">\(h\)</span>的所有取值求和, 权重为特定<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(h\)</span>的概率.</p></blockquote><p>为简化问题, 考虑二分类, 真实目标函数<spanclass="math inline">\(f\)</span>可以是任何函数<spanclass="math inline">\(\mathcal{X} \rightarrow \{0,1\}\)</span>,函数空间<span class="math inline">\(\{0,1\}^{|\mathcal{X}|}\)</span>.对所有可能的<spanclass="math inline">\(f\)</span>按均匀分布对误差求和,有</p><p><span class="math display">\[\begin{align} \nonumber\sum_f E_{ote}(\mathfrak{L}_a|x, f) &amp;= \sum_f \sum_h \sum_{x \in\mathcal{X} -X} P(x) \mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\\\nonumber&amp;= \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)\sum_f \mathbb{I}(h(x) \neq f(x))\\ \nonumber^*&amp;=  \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)\frac{1}{2}2^{|\mathcal{X}|}\\ \nonumber&amp;= \frac{1}{2}2^{|\mathcal{X}|} \sum_{x \in \mathcal{X} -X} P(x)\cdot 1 \tag{1.2}\end{align}\]</span></p><blockquote><p><strong>Tips:</strong> 标识<spanclass="math inline">\(*\)</span>的一步因为若<spanclass="math inline">\(f\)</span>均匀分布, 则有一半的<spanclass="math inline">\(f\)</span>对<spanclass="math inline">\(x\)</span>的预测与<spanclass="math inline">\(h(x)\)</span>不一致.</p></blockquote><p>式(1.2)指出, 误差与学习算法<spanclass="math inline">\(\mathfrak{L}\)</span>无关! 对于任意学习算法<spanclass="math inline">\(\mathfrak{L}_a\)</span>和<spanclass="math inline">\(mathfrak{L}_b\)</span>,有</p><p><span class="math display">\[\begin{equation}\sum_f E_{ote}(\mathfrak{L}_a|X, f) = \sum_f E_{ote}(\mathfrak{L}_b|X,f) \tag{1.3}\end{equation}\]</span></p><p>这简直糟糕透了, 似乎所有的学习算法期望性能居然都相同.这就是<strong>没有免费午餐定理(No Free Lunch Theorem, NFL)</strong>.</p><blockquote><p><strong>Tips:</strong> 原书的证明是多重假设下的简化论述,对严格数学证明感兴趣的读者可以自行查阅相关资料.</p></blockquote><p>但是, NFL定理有一个重要前提, 它假定了所有问题出现的机会相等,所有问题同等重要(例如上述证明中假设了<spanclass="math inline">\(f\)</span>均匀分布).但我们并不要求模型对所有情况都能给出一个好的解决方案,往往我们希望模型对特定问题表现是好的.</p><blockquote><p><strong>Tips:</strong> 原书中举了一个简单的例子,骑自行车从南京鼓楼到南京新街口显然是好方案(距离约两站地铁),但骑自行车从南京鼓楼到北京新街口, 显然不是好的方案,但我们不care.</p></blockquote><p>简单来说,NFL定理指出了<strong>没有一种机器学习算法是适用于所有情况的</strong>,只有针对具体问题, 才能谈论模型的优劣.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;机器学习所研究的主要内容,
是关于在计算机上从数据中产生&quot;模型&quot;(model)的算法, 即&quot;学习算法&quot;(learning
algorithm).&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="机器学习" scheme="http://la-pluma.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-大话设计模式 Ch0</title>
    <link href="http://la-pluma.github.io/2024/09/10/BookNote-DesignPatterns-by-JieCheng-1/"/>
    <id>http://la-pluma.github.io/2024/09/10/BookNote-DesignPatterns-by-JieCheng-1/</id>
    <published>2024-09-10T11:45:47.000Z</published>
    <updated>2024-09-24T15:06:15.318Z</updated>
    
    <content type="html"><![CDATA[<p><strong>精彩的代码是如何想出来的,要比看到精彩的代码更加令人期待.</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter-0-preview-面向对象基础">Chapter 0: Preview面向对象基础</a></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>《大话设计模式》程杰 2007.</p><p>本文<strong><em>不提供</em></strong>书籍的电子版文件,请有需要的读者移步至<strong>Z-library</strong>或其他渠道获得.</p><p>本书以情景对话形式, 辅以故事或例子介绍设计模式, 以C#语言书写代码,适合有面向过程编程基础但面向对象编程能力弱的初学者.</p><h2 id="chapter-0-preview-面向对象基础">Chapter 0: Preview面向对象基础</h2><blockquote><p>附录A 培训实习生——面向对象基础</p><p><strong>Tips:</strong> 本部分不设计具体的语法细节, 特性和原理,仅作示例, 如有需去可移步至专业书籍文献寻求细节, 如<ahref="https://learn.microsoft.com/en-us/dotnet/csharp/"><strong>微软官方</strong></a>或书籍<ahref="https://book.douban.com/subject/34894447/"><strong>C#图解教程</strong></a>.</p></blockquote><ul><li><p><strong>对象(Object):</strong> 对象是一个自包含的实体,用一组可识别的特性和行为来标识.</p><blockquote><p><strong>Tips:</strong> 定义比较拗口, 通俗来说, 对象是对事物的抽象,一切事物都可以称为对象.</p></blockquote></li><li><p><strong>面向对象编程(Object-Oriented Programming):</strong>面向对象的编程.</p><blockquote><p><strong>Tips:</strong> 简称OOP, 区别于面向过程编程,面向过程需要分析得出步骤, 按序实现程序功能. OOP首先对事物抽象为"对象",用对象的属性和行为解决问题.</p></blockquote></li><li><p><strong>类(Class):</strong>具有相同属性和功能对象的抽象集合.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">shout</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mew&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实例(Instance) &amp; 实例化:</strong> 实例是真实的对象,new得到实例的过程称为实例化.</p><blockquote><p><strong>Tips:</strong> 类就像是工厂的蓝图, 实例就是生产出来的产品,一个类只有实例化后才可以调用(可能不严谨, 存疑), 和蓝图与产品一样,一个类可以实例化出多个不同的实例(<strong>学生类</strong>可以实例化为<strong>学生李华</strong>,<strong>学生张三</strong>等).</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><ul><li><p><strong>修饰符:</strong></p><ul><li><p><strong>public:</strong> 修饰的类成员允许被任何类访问</p></li><li><p><strong>protected:</strong>修饰的类成员仅允许该类和其子类访问</p></li><li><p><strong>private:</strong> 修饰的类成员仅允许该类访问</p><blockquote><p><strong>Tips:</strong> 程序设计是一门权衡和妥协的艺术,对OOP为何如此设计的读者可自行查阅OOP发展的历史.</p></blockquote></li></ul></li><li><p><strong>属性:</strong> 属性是一个方法或一对方法,在调用它的代码看来, 它是一个字段,即属性适合于以字段的方法使用方法调用的场合.</p></li><li><p><strong>字段:</strong> 储存类设计所需的数据,形式上是与类相关的变量.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> num; <span class="comment">//声明一个私有内部字段, 修饰符private</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Num &#123; <span class="comment">//Num公有外部属性, 修饰符public</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="comment">//外部读取方法</span></span><br><span class="line">            <span class="keyword">return</span> Num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="comment">//外部修改方法, 删去此方法时表示Num是只读的.</span></span><br><span class="line">            Num = <span class="keyword">value</span>; <span class="comment">// set含有隐式参数, 由关键字value表示, 用于赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 属性和字段的描述比较抽象,推荐直接结合代码理解. 笔者认为是一种语法糖上的tricky,在其他语言OOP也有相似的写法. 这种写法的好处是隔离内部与外部,仅允许类提供的公共方法访问类内成员变量.</p></blockquote><ul><li><p><strong>构造方法/构造函数:</strong> 对类进行初始化的方法.与类同名, 无返回值, 不需要void, 在new中调用.</p><blockquote><p><strong>Tips:</strong> 以上语法细节适用于C#, 非C#可能会有差别,类中不显示写明构造函数时由编译器默认构造(更多语法细节和原理请移步至讨论C#的相关文献).</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123; <span class="comment">//这是构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>重载(overload):</strong>提供了创建多个同名方法(Function)的功能, 重载方法的参数类型不同.重载可以在不改变原方法基础上添加新功能.</p><blockquote><p><strong>Tips:</strong>这里<strong>参数类型的不同</strong>指的是参数个数不同或参数类型的不同(详见代码示例)</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="comment">//不仅构造函数, 普通函数也可以重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>()</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1, <span class="built_in">float</span> arg_2</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1, <span class="built_in">int</span> arg_2</span>)</span>&#123;&#125;;<span class="comment">//类型顺序不同也会被认为是重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>封装:</strong> 每个对象包含该对象操作所需的所有信息,不必依赖其他对象来完成自己的操作, 该特性称为封装.</p><blockquote><p><strong>Addtional:</strong> 良好的封装可以减少耦合,类内部实现可以自由修改, 具有清晰的对外接口</p></blockquote></li><li><p><strong>继承:</strong>对象的继承代表了一种"<strong>is-a</strong>"关系, 若描述为"B是A",则认为B可以继承A. 又可以理解为B是A的一种特殊化, B拥有A的特性之外,还拥有自己独特的特性. 即继承代表了一种包含关系, A包含B.</p><blockquote><strong>Addtional:</strong><ul><li>继承的双方称为<strong>子类/派生类&amp;父类/基类</strong>.</li><li>子类继承父类的成员有方法, 域, 属性, 事件, 索引指示器</li><li>构造方法<strong>无法</strong>继承, 只能调用,可以使用<strong>base</strong>关键字(C#语法特性)</li></ul></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>()</span> &#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;unamed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> shoutNum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ShoutNum &#123; <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> shoutNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            shoutNum = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Cat</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;mew &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Dog</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;woof &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong>继承的<strong>优点</strong>是使子类公共部分放在了父类, 代码得到了共享,减少了代码重复, 修改和扩展都变得相对容易.但<strong>缺点</strong>也是显而易见的, 继承会破坏封装,父类实现的细节暴露给子类, 父类和子类间是强耦合的.</p></blockquote><ul><li><p><strong>多态:</strong> 多态表示不同的对象可以执行相同的动作,但通过自己的代码执行.</p><blockquote><strong>Additional:</strong><ul><li>子类以父类身份出现</li><li>子类工作时以自己的方式实现</li><li>子类以父类身份出现时, 无法使用子类特有的属性和方法</li></ul><p><strong>Tips:</strong> 在父类中, 该动作需要声明为虚拟的,用关键字<strong>virtual</strong>标识.</p></blockquote></li><li><p><strong>重写/覆写(override):</strong>子类使用关键字<strong>override</strong>将父类实现替换为自己的实现.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//声明为虚方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*执行环境*/</span></span><br><span class="line"></span><br><span class="line">arrayAnimal = <span class="keyword">new</span> Animal[<span class="number">5</span>];</span><br><span class="line">arrayAnimal[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line">arrayAnimal[<span class="number">1</span>] = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">foreach</span>(Animal item <span class="keyword">in</span> arrayAnimal)&#123;</span><br><span class="line">    MessageBox.Show(item.Shout()); <span class="comment">//Cat为&quot;mew&quot;, Dog为&quot;woof&quot;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips1:</strong> C#的多态性分为静态多态性和动态多态性.静态多态性即为前文提到的overload重载, 在编译时确定;动态多态性为override覆写, 在运行时确定,通过抽象类(见下文)和虚方法实现.</p><p><strong>Tips2:</strong> 笔者在翻阅相关资料时,在C++语言中发现了更为复杂的机制, overwrite重写和override覆写存在区别,详见<ahref="https://www.cnblogs.com/kuliuheng/p/4107012.html"><strong>博客园|C++中的Overload、Override和Overwrite</strong></a></p><p><strong>Addtional:</strong> 原书对上述实现Animal Shout的代码进行重构,具体方法为将Shout()声明为父类公共方法(去掉virtual),声明新的虚方法getSound(), 在Shout()中调用, 在子类中覆写(override),从而避免了代码重复, 此处笔者不再浪费篇幅详细赘述.</p></blockquote><ul><li><p><strong>抽象类&amp;抽象方法:</strong>C#允许将类和方法用关键字<strong>abstract</strong>声明, 即抽象类,抽象方法.</p><blockquote><strong>Addtional:</strong><ul><li>抽象类不能被实例化</li><li>抽象方法必须被子类覆写(override)</li><li>含有抽象方法的类必须声明为抽象类, 不论是否具有一般方法</li><li>使用时考虑让抽象类拥有尽可能多的共同代码, 拥有尽可能少的数据</li></ul><p><strong>Tips:</strong> 抽象类通常代表一种抽象概念,提供了一个继承的出发点, 当设计一个新的抽象类时, 一定是用来继承的.因此在继承结构中, 叶节点应当是具体类, 非叶节点应当是抽象类.</p></blockquote></li><li><p><strong>接口(Interface):</strong>接口是把隐式公共方法和属性组合起来, 以封装特定功能的一个集合.类实现了接口就可以支持接口所指定的所有属性和成员.接口不允许提供任何成员的执行方法(因此接口不能实例化, 没有构造方法,字段和修饰符, 不能声明静态或虚拟等).</p><blockquote><strong>Addtionnal:</strong><ul><li>实现接口的类必须实现接口中所有方法和属性.</li><li>一个类可以支持多个接口, 不同类也可以支持相同接口.</li></ul><p><strong>Tips:</strong> <ahref="https://www.runoob.com/csharp/csharp-interface.html">菜鸟教程|C#Interface</a>将接口表述为:</p><p>接口定义了所有类继承接口时应遵循的语法合同.接口定义了语法合同"是什么"部分, 派生类定义了语法合同"怎么做"部分.接口定义了属性, 方法和事件, 这些都是接口的成员. 接口只包含了成员的声明.成员的定义是派生类的责任. 接口提供了派生类应遵循的标准结构.</p><p><strong>书写规范:</strong> 接口的命名需要在前面加一个大写"I".</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 笔者在此化简了书目中提供的例子, 能理解即可.</span></span><br><span class="line"><span class="comment">// 叮当猫继承自上文出现的Cat类, 内部需要实现变东西的接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MachineCat</span> : <span class="title">Cat</span>, <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>&#123; <span class="comment">//实现接口, 不需要使用override修饰</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.Shout() + <span class="string">&quot;我有万能口袋, 可以变出: &quot;</span> + thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Additional:</strong> 笔者在此补充一点C#的语法特性,接口也可以继承接口, 假设IB继承IA, 在IB中不需要声明IA中的声明,但实现IB的类需要实现IA和IB中的所有声明.</p><p><strong>Compare: Class v.s. Interface</strong></p><ul><li><strong>语法上:</strong> 抽象类可以给出一些成员的实现,接口不能包含成员的实现, 抽象类的抽象成员可被子类部分实现,但接口的成员需要类全部实现, 一个类只能继承<strong>一个</strong>抽象类,但可以实现<strong>多个</strong>接口.</li><li><strong>含义上:</strong> 类是对象的抽象, 抽象类是对类的抽象,接口是对<strong>行为</strong>的抽象.</li><li><strong>使用上:</strong> 如果行为跨越不同类的对象, 可使用接口;对于一些相似的类对象, 用继承抽象类. 需要注意的是,实现接口和继承抽象类并不冲突.</li><li><strong>设计角度上:</strong> 抽象类是从子类中发现了公共的东西,泛化出父类, 然后子类继承父类, 而接口根本不知道子类的存在,方法如何实现不明确, 预先定义.</li></ul></blockquote><ul><li><p><strong>泛型(Generic):</strong> 泛型是具有占位符(类型参数)的类,结构, 接口和方法, 这些占位符是类, 结构,接口和方法所储存域或使用的一个或多个类型的占位符.泛型集合类可以将类型参数用作它所存储的对象的类型的占位符:类型参数作为其字段的类型和其方法的参数类型出现.</p><blockquote><p><strong>Additional:</strong> 通常情况下, 都建议使用泛型集合,因为这样可以获得类型安全的直接优点而不需要从基集合类型派生并实现类型特定成员.此外, 如果集合元素为值类型,泛型集合类型的性能通常优于对应的非泛型集合类型,因为使用泛型时不必对元素进行装箱.</p><p><strong>Tips:</strong> <ahref="https://www.runoob.com/csharp/csharp-generic.html">菜鸟教程|C#Generic</a>将泛型表述为:</p><p>泛型(Generic)允许您延迟编写类或方法中的编程元素的数据类型的规范,直到实际在程序中使用它的时候. 换句话说,泛型允许您编写一个可以与任何数据类型一起工作的类或方法.</p><p>泛型的定义较为晦涩, 建议结合代码理解.笔者在此强烈建议阅读更多的资料来学习泛型.</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic; <span class="comment">//增加泛型集合命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Forml</span> : <span class="title">Form</span>&#123;</span><br><span class="line">    IList&lt;Animal&gt; arrayAnimal; <span class="comment">// 声明泛型集合变量, 表示只接受Animal类型</span></span><br><span class="line">    <span class="comment">//List&lt;Animal&gt; arrayAnimal; 两种写法是等价的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Event</span>()</span>&#123;</span><br><span class="line">        arrayAnimal = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Cat());</span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Dog());</span><br><span class="line">        arrayAnimal.Add(<span class="number">123</span>); <span class="comment">// Error! Invalid Type </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>委托:</strong> 委托是对函数的封装,可以当作给方法的特征指定一个名称.委托对象用关键字<strong>delegate</strong>声明.</p></li><li><p><strong>事件:</strong> 事件时委托的一种特殊形式,当发生有意义的事情时, 事件对象处理通知过程.事件对象用关键字<strong>event</strong>声明.</p></li></ul><blockquote><p><strong>Additional:</strong> 委托是一种引用方法的类型,一旦为委托分配了方法, 委托将与该方法具有完全相同的行为.事件则是在发生其他类或对象关注的事情时, 类或对象可通过事件通知它们.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情境: 猫Tom叫的时候两只老鼠Jerry和Jack要跑.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>()</span>; <span class="comment">// 声明委托</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout; <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span> (CatShout != <span class="literal">null</span>)&#123; <span class="comment">// 如果声明了事件CatShout</span></span><br><span class="line">            CatShout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫来了, &#123;0&#125;快跑&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    Mouse mouse1 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    Mouse mouse2 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse1.Run);</span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse2.Run); </span><br><span class="line">    <span class="comment">// &quot;+=&quot; 表示 &quot;add_CatShout&quot; 的意思; 与之相反 &quot;-=&quot; 表示 &quot;remove_CatShout()&quot;</span></span><br><span class="line"></span><br><span class="line">    cat.Shout();</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫来了, Jerry快跑!</span><br><span class="line">老猫来了, Jack快跑!</span><br></pre></td></tr></table></figure><ul><li><strong>EventArgs:</strong> EventArgs是包含事件数据的类的基类.</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CatShoutEventArgs</span> : <span class="title">EventArgs</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span>(CatShout != <span class="literal">null</span>)&#123;</span><br><span class="line">            CatShoutEventArgs e = <span class="keyword">new</span> CatShoutEventArgs();</span><br><span class="line">            e.Name = <span class="keyword">this</span>.name;</span><br><span class="line">            CatShout(<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫&#123;0&#125;来了, &#123;1&#125;快跑!&quot;</span>, args.Name, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main执行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫Tom来了, Jerry快跑!</span><br><span class="line">老猫Tom来了, Jack快跑!</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;精彩的代码是如何想出来的,
要比看到精彩的代码更加令人期待.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://la-pluma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>千里之行，始于足下</title>
    <link href="http://la-pluma.github.io/2024/09/08/hello-world/"/>
    <id>http://la-pluma.github.io/2024/09/08/hello-world/</id>
    <published>2024-09-08T12:56:57.000Z</published>
    <updated>2024-09-12T15:49:07.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong>A journey of a thousand miles begins with a singlestep.</strong></p><span id="more"></span><img src="/2024/09/08/hello-world/picture.png" class="" title="picture">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;A journey of a thousand miles begins with a single
step.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
