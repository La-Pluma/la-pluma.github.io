<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LaPluma</title>
  
  <subtitle>Keep it simple and stupid.</subtitle>
  <link href="http://la-pluma.github.io/atom.xml" rel="self"/>
  
  <link href="http://la-pluma.github.io/"/>
  <updated>2024-12-19T08:06:42.187Z</updated>
  <id>http://la-pluma.github.io/</id>
  
  <author>
    <name>LaPluma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NJU静态分析|A8-Taint Analysis</title>
    <link href="http://la-pluma.github.io/2024/12/17/SPA-A8/"/>
    <id>http://la-pluma.github.io/2024/12/17/SPA-A8/</id>
    <published>2024-12-17T00:29:48.000Z</published>
    <updated>2024-12-19T08:06:42.187Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-8 TaintAnalysis.</strong></p><span id="more"></span><h2 id="实验目标">实验目标</h2><p>基于<strong>tai-e</strong>框架实现污点分析.</p><h2 id="preparation">Preparation</h2><p>将A6的代码复制到此处.</p><p><strong>注意:</strong>A8的<code>Solver</code>中额外加入了污点分析所需的字段,因此不能直接替换A8的<code>Solver</code>.</p><h2 id="部分框架代码带读">部分框架代码带读</h2><p>在上过课程和阅读了实验指南后, 对于怎么做这个实验会有一个大概的思路,那么不妨先阅读一下框架代码, 看看Tai-e提供了什么样的工具和API.</p><h3 id="source-sink">Source &amp; Sink</h3><p>分别代表了污点分析中的Source和Sink语句,结构为<code>Source&lt;JMethod, Type&gt;</code>和<code>Sink&lt;JMethod, index&gt;</code>.</p><blockquote><p><strong>Tips:</strong><code>record</code>的用法在之前的实验已经接触过了, 简单来说,可以通过<code>source.method()</code>获取其中的<code>JMethod method</code>信息.</p></blockquote><h3 id="tainttransfer">TaintTransfer</h3><p>对应污点传播的类, 即实验指南中的:</p><img src="/2024/12/17/SPA-A8/pic1-1.png" class="" title="pic1-1"><p>具体规则实验指南和框架代码已足够清晰.</p><h3 id="taintmanager">TaintManager</h3><p>实验框架中用来管理污点对象的类(或许命名为<code>TaintObjManager</code>更合适).</p><p>类内采用简单的Map实现<code>&lt;(Invoke, Type), TaintObj&gt;</code>的查找.</p><p><strong>注意: 笔者为了方便表述,使用<code>TaintObj</code>表示污点对象,该类在框架代码中并不存在.</strong></p><p>其中包含三个方法:</p><ul><li><p><code>Obj makeTaint(Invoke source, Type type)</code>返回一个污点对象实例.</p><blockquote><p><strong>Tips:</strong> 注意到污点对象也是<code>obj</code>,即<code>taintObj</code>可以使用<code>obj</code>的方法进行操作.</p></blockquote></li><li><p><code>boolean isTaint(Obj obj)</code>判断一个<code>Obj</code>是否为<code>TaintObj</code>.</p></li><li><p><code>Invoke getSourceCall(Obj obj)</code>返回该对象实例化对应的<code>Invoke</code>.</p></li></ul><h3 id="taintflow">TaintFlow</h3><p>表示<code>Source -&gt; Sink</code>的污染流,也即污点分析的结果(TT老师在本次课程中一嘴带过的可以追踪的<code>Source -&gt; Sink</code>).</p><h3 id="taintconfig">TaintConfig</h3><p><del>碎碎念:不是为什么要把管理污点分析所需的数据结构和设置污点分析的配置两个功能都塞进来啊喂!!!阅读类名谁能知道会把数据结构放在这里啊喂!!!</del></p><p>存储污点分析所需的信息, 可以通过<code>getSources()</code>,<code>getSinks()</code>, <code>getTransfers()</code>获取,注意返回的类型是<code>Set</code>,请使用<code>Set</code>的API对其进行操作.</p><p>可以看出,TaintSources和TaintSinks以及TaintTransfers的规则在该类中已经配置 完成,可以在实验中<strong>直接使用</strong>.</p><blockquote><p><strong>Tips</strong> 其余部分都是有关配置污点分析的工具,本次实验不需要过多了解, 读者若有兴趣可以自行阅读框架代码.</p></blockquote><h3 id="taintanalysis">TaintAnalysis</h3><blockquote><p><strong>Tips:</strong>实验指南解释了为何是<code>TaintAnalysiss</code>,笔者在此使用更容易理解的表述.</p></blockquote><p>本次实验主要的逻辑实现部分,<code>Solver</code>可以根据其中的<code>taintAnalysis</code>字段调用<code>TaintAnalysis</code>中的API,从代码规范角度, 处理污点分析的代码应当在此处完成,<code>Solver</code>中仅调用API.</p><p>先看看该类具有哪些字段:</p><ul><li><code>TaintManager manager</code></li><li><code>TaintConfig config</code></li><li><code>Solver solver</code></li><li><code>CSManager csManager</code></li><li><code>Context emptyContext</code></li></ul><p>注意到除了污点分析相关组件,<code>TaintAnalysis</code>也可以和<code>Solver</code>和<code>CSManager</code>通信,并且给出了一个<code>emptyContext</code>, 以供直接使用.</p><p>以上字段均在实例化时被初始化.</p><p>接着看看类中的方法:</p><ul><li><p><code>void onFinish()</code>,向外部(这里是<code>Solver</code>)给出污点分析结果<code>taintFlows</code>.</p></li><li><p><code>Set&lt;TaintFlow&gt; collectTaintFlows()</code>,该部分等待完成, 用以计算所有的污染流.</p></li></ul><h3 id="solver">Solver</h3><p>到此已经知道所有污点分析相关类了,现在从顶层<code>Solver</code>中看看污点分析的使用.</p><ul><li><code>void solve()</code>是指针分析的步骤, 可以看到相比A6,最后一步设置了污点分析结果. 换句话说,本次实验中只需要考虑污点分析的实现,污点分析的前置工作和结果存储框架都已经做好了.</li></ul><h2 id="算法设计">算法设计</h2><h3 id="基本假设">基本假设</h3><p>在本次实验的污点分析中, 有几个基本假设:</p><ul><li><p><code>TaintObj</code>只会由<code>Source</code>产生,依据<code>TaintTransfer</code>的规则, 最终传播到<code>Sink</code>.其中<code>Source</code>的语句类型均为<code>Invoke</code>.</p></li><li><p>本次实验不考虑<strong>隐式污染</strong>(详见<ahref="https://cs.nju.edu.cn/tiantan/software-analysis/Security.pdf#page=44"><strong>课程ppt</strong></a>),这大大简化了本次实验分析难度.</p></li><li><p><code>TaintObj</code>是以<code>Obj</code>的方式进行封装的,这意味着<code>TaintObj</code>可以像<code>Obj</code>一样在指针流图<code>PointerFlowGraph</code>中传递.</p><blockquote><p><strong>Tips: 这意味着什么?</strong></p><p>这意味着除了<strong>TaintTransfer</strong>和<strong>SourceInvoke</strong>的传播途径外,<code>TaintObj</code>的其余传播途径都可以在之前的指针分析实现中完成.(如果感到难以理解可以试试推一下<code>Assign</code>,<code>Store</code>和<code>Load</code>语句的传播)</p></blockquote></li><li><p><code>TaintObj</code>的上下文被简单的处理成<code>emptyContext</code>,即来自同一个<code>Index: Invoke</code>的<code>TaintObj</code>在堆中被抽象为一个对象.</p></li><li><p><strong><em>(存疑)</em></strong> OnlineJudge上似乎所有的<code>Source</code>相关语句<strong>均是静态方法</strong>,因此理论上不需要进行<strong>dispatch</strong>也可以通过测试.</p></li></ul><h3 id="source-sink-tainttransferflow">Source &amp; Sink &amp;TaintTransferFlow</h3><p>三者均是在<code>Invoke</code>上进行操作,因此需要修的地方有<code>processCall</code>和<code>addReachable</code>.</p><ul><li><p>对于<code>Source</code>, 只需要按实验指南上的规则处理即可.但需要注意的是, 只有当<code>Invoke</code>存在返回值时,才执行<code>Source</code>的处理.</p></li><li><p>对于<code>Sink</code>, 可以选择边迭代边处理.但因为<strong>Pointer Analysis</strong>不依赖于<code>Sink</code>,也可以在算法跑完后遍历所有的<code>Sink</code>语句的参数的<code>PointsToSet</code>是否包含<code>TaintObj</code>.也就是说,这部分代码可以在<code>collectTaintFlows()</code>中统一完成.</p></li><li><p>对于<code>TaintTransferFlow</code>,同样只需要小心的按照指南规则处理即可. 但需要注意的是,由于污点数据流向目标时可能会有类型转换,因此需要创建一个新的<code>TaintObj</code>实例赋值给目标的<code>PointsToSet</code>.</p></li></ul><h3 id="污点数据的广播">污点数据的广播</h3><p>污点数据的传播逻辑处理是本次实验相对简单的部分,困难的是想清楚如何传播污点数据.</p><p>想知道答案, 就要先回顾一下指针分析的广播.</p><img src="/2024/12/17/SPA-A8/pic1-2.png" class="" title="pic1-2"><p>这个大循环中当<code>n</code>是变量<code>x</code>时,对相关语句进行广播.</p><p>如在A5, A6中,需要对<code>Array</code>和<code>Filed</code>以及<code>processCall</code>进行广播.</p><p>污点分析也是一种指针分析, 那么其理应也在这里广播.</p><p><code>from -&gt; to</code>的情况有三种,<code>from</code>的取值只有<code>Arg</code>和<code>Base</code>两种情况.</p><ul><li><p><code>Base</code>的广播可以在<code>processCall</code>中进行,因为二者中变量<code>x</code>都作为<code>Base</code>出现.</p></li><li><p><code>Arg</code>的广播没有现成的方法, 那么就考虑与其余情况并列,若<code>x</code>是某条<code>Invoke</code>的实参时, 则需要广播到此处,为该<code>Invoke</code>执行<code>TaintTransferFlow</code></p></li></ul><p>特别的, 因为这样的特性,你也可以考虑将<code>TaintTransferFlow</code>拆开来写.这样更符合其广播逻辑.</p><h2 id="拾遗">拾遗</h2><p>本次实验几乎不涉及新的方法和工具(当然你也可以选择使用一些隐藏API来完成本次实验,例如对于<strong>Instance Invoke</strong>,可以通过<code>((InvokeInstanceExp)(invoke.getInvokeExp())).getBase()</code>来获取<code>base</code>信息).</p><p><strong>All you need has already in Tai-e.</strong></p><h2 id="总结">总结</h2><p>完结撒花啦!</p><img src="/2024/12/17/SPA-A8/pic1-3.png" class="" title="pic1-3">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-8 Taint
Analysis.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A7-Alias-Aware Interprocedural Constant Propagation</title>
    <link href="http://la-pluma.github.io/2024/12/09/SPA-A7/"/>
    <id>http://la-pluma.github.io/2024/12/09/SPA-A7/</id>
    <published>2024-12-09T02:06:40.000Z</published>
    <updated>2024-12-17T17:51:20.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-7 Alias-AwareInterprocedural Constant Propagation.</strong></p><span id="more"></span><h2 id="实验目标">实验目标</h2><p>基于<strong>tai-e</strong>框架实现带别名分析的过程间常量传播.</p><h2 id="preparation">Preparation</h2><ul><li><p>将<code>A2/.../ConstantPropagation</code>复制到<code>A7/.../ConstantPropagation</code></p></li><li><p>将<code>A4/.../InterConstantPropagation</code>复制到<code>A7/.../InterConstantPropagation</code></p></li><li><p>将<code>A4/.../InterSolver</code>复制到<code>A7/InterSolver</code></p></li><li><p>将<code>A6/.../cs/Solver</code>复制到<code>A7/.../cs/Solver</code></p></li><li><p>将<code>A6/.../_2ObjSelector</code>复制到<code>A7/.../_2ObjSelector</code></p><blockquote><p><strong>Tips:</strong><code>plan.yml</code>已经配置好了<code>cs: 2-obj</code>,如果本地测试中想要使用其他策略,需要将对应<code>Selector</code>复制到本次实验目录,并配置<code>plan.yml</code>(方法已在A6实验指南中给出)</p></blockquote></li></ul><p><strong><em>注意:</em></strong>除去指针分析的部分作为结果查询字段指向外,其余文件都可以是本次实验的更改范围.</p><h2 id="review">Review</h2><p>由于要设计算法, 不妨先复习一下A2和A4中常量传播算法和应用范围.</p><ul><li><p>常量传播算法是<strong>Forward &amp; Must Analysis</strong>.迭代至收敛至"最大"不动点.</p><blockquote><p><strong>Additional:</strong></p><p>迭代算法框架如下:</p><img src="/2024/12/09/SPA-A7/pic1-1.png" class="" title="pic1-1"><p>活跃变量分析的迭代示例:</p><img src="/2024/12/09/SPA-A7/pic1-2.png" class="" title="pic1-2"></blockquote></li><li><p>常量传播算法中对数值的抽象为<code>UNDEF-&gt;CONST-&gt;NAC</code>.</p></li><li><p>由于数据流动的"单调性", <strong>Meet</strong>要满足</p><blockquote><img src="/2024/12/09/SPA-A7/pic1-3.png" class="" title="pic1-3"></blockquote></li><li><p>语句处理的<strong>Transfer Function</strong></p><blockquote><img src="/2024/12/09/SPA-A7/pic1-4.png" class="" title="pic1-4"></blockquote></li></ul><blockquote><p>在A2中,处理范围仅限于<code>DefinitionStmt</code>中的变量和表达式部分,对于诸如<strong>字段, 数组</strong>部分采取保守策略,赋值为<code>NAC</code>; 分析范围仅局限于<strong>过程内分析</strong>,此时为方法调用的返回值采取保守策略, 赋值为<code>NAC</code>.</p><p>在A4中, 同样只处理变量, 但分析范围扩展为过程间分析,需要完成对方法调用传参, 传返回值, 为了完成过程间的数据流传递,加入了<strong>Transfer Edge</strong>.</p><p>由于方法调用的<strong>动态时确认</strong>,需要知道在这个调用点<code>callsite</code>,真正的<code>callee</code>是什么,因此建立<strong>CallGraph</strong>为<strong>ICFG(inter-proceduralcontrol-flow graph)</strong>提供调用图信息.(你应该还记得在A4的<code>CHABuilder</code>完成前,<code>Assignment</code>不会输出任何ICFG信息)</p><img src="/2024/12/09/SPA-A7/pic1-5.png" class="" title="pic1-5"></blockquote><h2 id="requirement-analysis">Requirement &amp; Analysis</h2><p>现在来看看实验要求和手上的工具, 看看如何处理新需求.</p><h3 id="常量处理范围">常量处理范围</h3><p>在之前的实验中,忽略了<strong>字段Field</strong>和<strong>数组Array</strong>的分析,原因在本次实验已经指出, 是<strong>别名Alias</strong>所引起的,由于多个变量(指针)可以指向同一个对象, 只有当明确指针所指向对象时,才能为其赋值<strong>常量Constant</strong>.</p><p>需要指出的是, 本次实验仍然<strong>只需要处理int类型的变量</strong>.A2中已经提供了足够好用的<code>canHoldInt()</code>.</p><p>另外,指南上讲述了实验框架中会忽略<strong>静态字段的初始化</strong>的情况,因其在控制流图中不可达, 不需要对其进行额外的处理.</p><h3 id="域分析范围">域分析范围</h3><p>A4开始采用了一种精度较低的方法CHA构建<strong>CallGraph</strong>; A5,A6使用了精度更高的指针分析技术构建<strong>CallGraph</strong>.</p><p>本次实验仍然是处理<strong>过程间常量传播</strong>,由于<strong>CallGraph</strong>更加精确, 分析精度相较于A4也会更进一步.同时,在Tai-e框架下完成实验不需要关注<strong>ICFG</strong>如何获得<strong>CG</strong>信息(如有兴趣可自行阅读框架代码).</p><h3 id="pointeranalysisresult">PointerAnalysisResult</h3><p>框架代码提供了<code>class PointerAnalysisResult</code>用来获取指针分析的结果,该部分的初始化在<code>InterConstantPropagation</code>中的<code>initial()</code>中完成.</p><p>其中包含的API说明都较为清晰, 笔者在此不过多赘述.</p><h3 id="别名分析">别名分析</h3><p>该部分实验指南已经给出了一个比较简单的实现方法,<strong>Pointer指向的PointsToSet存在交集,则认为二者互为别名.</strong></p><p>换个说法, <strong>存在两个或两个以上Pointer指向同一个Obj,则认为二者互为别名.</strong></p><p>实验指南中讲述了为什么只需要<code>Pointer</code>而不是<code>CSPointer</code>的原因</p><p>笔者在此给出两个简单的算法思路:</p><ul><li><p>遍历所有的<code>Pointer1</code>与<code>Pointer2</code>,获取<code>PointsToSet</code>,如果有交集就加入<code>Multiple Map</code>中,简单地以<code>&lt;Var, Var&gt;</code>的形式维护alias信息.</p></li><li><p>遍历所有的<code>Pointer</code>和对应的<code>PointsToSet</code>,维护一个<code>&lt;Obj, Var&gt;</code>结构,对于<code>&lt;Obj, Var1&gt;</code>和<code>&lt;Obj, Var2&gt;</code>,<code>Var1</code>和<code>Var2</code>互为别名.</p></li></ul><blockquote><p><strong>Tips: 框架代码的做法</strong></p><p>如果你有阅读过框架代码或者"意外"跳转到<code>class Maps</code>,便会发现,Tai-e框架中已经配置了好了获取基本数据结构的API(被TT深不可测的代码力所折服).可以通过简单的<code>Maps.newMultiMap()</code>获取实例化数据结构. 当然,也可以选择自己实例化Map的结构.</p><p>不过需要注意的是, 该部分代码<strong>不是显式给出的</strong>,而是封装在<code>tai-e-assignment.jar</code>中,可以选择阅读科研版doc或者阅读反编译后的源码(该部分结构简单,即便无注释也可以理解)</p></blockquote><h3 id="field处理">Field处理</h3><p>在这里会遇到第一个头疼的点: <strong>ConstPropagation是流敏感的,但PointerAnalysis是流不敏感的.</strong></p><p>尽管别名信息不依赖于常量传播, 但对象存储的值来源常量传播. 因此,需要先理清楚如何处理<code>Load</code>和<code>Store</code>.(<strong>注意:</strong>笔者以下论述基于InstanceField,SaticField的处理只会比InstanceField简单)</p><blockquote><p><strong>Try: 先收集所有的Store再更新给Load?</strong></p><p>这是符合流不敏感的思路,但是在ConstPropagation的流敏感框架中非常难以实现. 在迭代过程中,Store的<strong>右值</strong>可能会改变,Store的变化也会引起非Field和Array变量的变化. 所以,Field和Array的更新也需要采用流敏感框架中的迭代方法.</p></blockquote><p>现在来分析如何用迭代的方法处理Field.</p><ul><li><p>对于Load, 因为迭代的缘故, 可以先假设后续的处理会正确的广播到此处,更新Load的值. 因此只需要简单的传播到def即可.</p></li><li><p>对于Store, 假设已经有了一个对应的Load结构,Store产生了更新该如何广播?worklist加入<code>Load Stmt</code>迭代即可.</p></li><li><p>同时, 需要注意InstanceFiled的特性,考虑别名信息进行更新即可.</p></li></ul><h3 id="array处理">Array处理</h3><p>Array可以理解成一种特殊的InstanceField, 不过需要注意何时互为别名,只有在互为别名的情况下才考虑广播.</p><h3 id="小结">小结</h3><p>至此已经有了一个对完成本次实验的一个基本思路了,接下来开始考虑一些完成实验的细节.</p><h2 id="算法设计">算法设计</h2><blockquote><p><strong>Tips:</strong> 笔者在此章节不详谈实现上的细节, 该部分在<ahref="#拾遗-tai-e-faq-you-need-to-know">拾遗</a>章节分点给出. 并且,由于框架代码的特性, 算法的实现可能与思路有所出入.</p></blockquote><blockquote><p><strong>Question: 这次新写的代码和A4冲突吗?</strong></p><p>这个问题实际上是在问:Field和Array的传播是否会影响到过程间常量传播的<strong>EdgeTransfer</strong>.</p><p>答案自然是否定的, Field和Array可以理解成一种特殊的Var,尽管其结果不需要呈现在<code>DataFlowResult</code>中. 可以自然地得出结论:加入Field和Array并不会改变A4的算法框架.</p><p>也即,本次实验所设计的算法是对<strong>TransferNonCallNode(A2-IntraConstPropagation)</strong>的补全.</p></blockquote><p>所以, 本次算法的基本框架可以表示为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">transferNonCallNode</span><span class="params">(Stmt stmt, CPFact in, CPFact out)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> LoadField)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> StoreFiled)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> LoadArray)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> StoreArray)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cp.transferNode(); <span class="comment">//form A2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,你也可以选择将这些语句的处理直接整合进<code>ConstantPropagation</code>(前提是A2的实现最好确保是正确的).</p><blockquote><p><strong>Tips:</strong>还记得在A5和A6中是如何优雅地处理繁杂的<code>instanceof</code>判断吗? 对,就是<strong>访问者模式</strong>, 在本次实验中,仍然可以选择这样的方法实现算法.所有的<code>Stmt</code>类中都已经内置了<code>accept()</code>API可供访问,只需要新的访问类继承自<code>StmtVisitor</code>即可.</p></blockquote><h3id="field-value的存储和广播"><code>&lt;Field, Value&gt;</code>的存储和广播</h3><blockquote><p><strong>Tips:</strong> 在Tai-e框架中, 将Array等效抽象成Field,并不对<strong>Index</strong>做具体的区分(对<code>a[i]</code>和<code>a[j]</code>的store操作视为对同一对象<code>a[...]</code>的store操作).尽管如此,index信息也有助于分区<code>a[i]</code>和<code>a[j]</code>是否为别名,从而决定是否需要广播. 因此, Array的维护会比Field更复杂, 但基本原理一致,笔者在此章节<strong>不再</strong>赘述Array应如何处理.</p></blockquote><p>在之前的分析中已经获知了<a href="#别名分析">Alias信息</a>,该部分算法的实现依赖于别名信息.</p><p>笔者在此给出两个算法思路抛砖引玉:</p><h4 id="只考虑alias层">只考虑Alias层</h4><p>这是个朴实但简单的想法:所有的<code>y = x.f</code>来自也只来自<code>x.f = z</code>,这句"废话"意味着什么?</p><p><strong>意味着其实根本就不需要考虑<code>x.f</code>或者说<code>oi.f</code>的取值,如果想知道<code>y</code>可能的value值,只需要<code>meet</code>所有的<code>z</code>就可以了.</strong></p><p>根据这个思路, 有:</p><ul><li><p>对于<code>LoadField</code>,找到所有与<code>x.f</code>相关的<code>x'.f = z</code>,其中<code>x'</code>是<code>x</code>的别名, <strong>meet</strong><code>z</code>的<code>value</code>值.如果<code>y = meet(foreach(z))</code>有更新,将其后续<code>Node</code>加入<code>workList</code>.</p></li><li><p>对于<code>StoreField</code>,找到所有与<code>x.f</code>相关的<code>y = x'.f</code>,其中<code>x'</code>是<code>x</code>的别名,将这些<code>StoreField</code>加入<code>workList</code>.</p></li></ul><p>这个算法的优点是实现简单, 但缺点是效率低,展现着独属于暴力的美学魅力.</p><p>其关键在于如何维护<code>&lt;Field, Stmt&gt;</code>的结构,框架代码中有不少细节需要关注.</p><h4 id="考虑mapobj-value">考虑<code>Map&lt;Obj, Value&gt;</code></h4><p><code>x.f</code>中的<code>x</code>是<code>Pointer</code>,真正存储Value值的是<code>Obj</code>,因此可以考虑维护<code>&lt;Var, Obj&gt;</code>和<code>&lt;Obj.field, Value&gt;</code>两个Map,<code>Load</code>和<code>Store</code>均对Map进行操作.</p><p>该思路避免了之前算法中的大量冗余计算(笔者自测跑完本地测试需要近30s),提高了效率, 但Map的维护较为复杂.</p><p>具体处理<code>LoadField</code>和<code>StoreField</code>时,只需要将信息更新到<code>Map&lt;Obj.field, Value&gt;</code>即可,广播逻辑与之前相同.</p><p>不过需要注意的是, 由于指针分析结果是流不敏感的,对于<code>Store</code>操作只使用<code>meet</code>而不是<code>kill</code>.</p><blockquote><p><strong>Question: Store语句应该在何时广播?</strong></p><p>答案是当<code>outFact</code>改变的时候广播,或者具体来说,是<code>x.f = y</code>的<code>y</code>的value值改变时进行广播.</p></blockquote><h2 id="拾遗-tai-e-faq-you-need-to-know">拾遗: Tai-e FAQ You Need toKnow</h2><h3 id="cs-ci-pointer-analysis">CS &amp; CI Pointer Analysis</h3><p>CallGraph建立的ICFG是没有上下文的,这和常量传播不关注上下文的行为一致.但对<code>Pointer</code>指向信息可以使用带上下文的分析结果以获取更高的精度,这与ICFG并不冲突.</p><h3 id="ir">IR</h3><p>IR的使用为本次实验做了大量简化, 你可能会疑惑,对于<code>x.f = y.g</code>这样的操作,上述算法框架可以覆盖到该语句吗?</p><p>实际上, <code>x.f = y.g</code>在IR中会被转化为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">21</span><span class="meta">@L16</span>] temp$<span class="number">8</span> = x.&lt;X: <span class="type">int</span> f&gt;;</span><br><span class="line">[<span class="number">22</span><span class="meta">@L16</span>] y.&lt;Y: <span class="type">int</span> g&gt; = temp$<span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>与之类似的, <code>Invoke</code>,<code>BinaryExp</code>也具有相同的特性.</p><p>如果不确定某条语句在框架中如何表示,可以自己设计测试样例通过Assignment分析其结果.</p><p>回到这次实验,可以简单认为<strong>所有<code>AssignStmt</code>的左值和右值中最多只有一个是Field/Array,另外一个是Var</strong>.</p><h3id="intersolver与interconstpropagation">InterSolver与InterConstPropagation</h3><p>InterConstPropagation的字段可以简单的通过参数的方式进行传递,但InterSolver与InterConstPropagation间该如何通信?</p><p>注意到<code>InterConstantPropagation extends AbstractInterDataflowAnalysis</code>,其父类中含有字段<code>InterSolver solver</code>,可以通过<code>solver.xxx</code>实现通信.</p><p>对于其中的<code>private</code>和<code>protected</code>字段,可以为其编写一个<code>public XType getX()</code>API提供访问接口.(如<code>result</code>,<code>worklist</code>等).</p><h3 id="数据结构map">数据结构Map</h3><p>本次实验中存在大量"一对多"的联系,可以考虑选取<code>MultiMap</code>进行维护.其中提供了不少相当便捷的API.</p><h3 id="relevantstmt">relevantStmt</h3><p>如果能把字段中的Var取出,可以使用其中的API<code>var.getStoreField()</code>等API方便的获取有关语句,不过对Static就没有太好的方法了,笔者采用的是遍历<code>icfg.getNodes()</code>.</p><h3 id="fieldstmt-fieldaccesss-filedref-jfield">FieldStmt, FieldAccesss,FiledRef &amp; JField</h3><p>Tai-e框架中的Field的处理要比Array复杂不少, 笔者在此做简要解释.</p><ul><li><p>JField的结构是<code>&lt;Type: FieldName&gt;</code>,可以使用<code>FieldStmt.getRef().resolve()</code>得到.当使用Stmt解析出JField进行比较时会获取更高的精度.(笔者因为这个卡了hidden test)</p></li><li><p>如果想获取Field的Obj(即base部分),可以使用<code>FieldStmt.getFieldAccess().getBase()</code>.不过需要先转换为<code>InstanceFieldAccess</code>类型才能使用<code>getBase()</code>的API.</p><blockquote><p><strong>Tips:</strong> 笔者在此吐槽一句,为何关于Field的API都封装在了<code>tai-e-Assignemnt.jar</code>中而不是显式的给出,增大了如何处理Field的学习成本.</p></blockquote></li></ul><h3 id="arraystmt">ArrayStmt</h3><p>Array的结构相对简单一点,通过<code>getAccess()</code>就可以简单的<code>access.getBase/Index()</code>获取需要的信息.</p><h2 id="总结">总结</h2><p>恭喜挺过了本学期SPA的实验大魔王, 自己设计算法还是颇有难度的,接下来迎接较为轻松的A8吧. (^_^)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-7 Alias-Aware
Interprocedural Constant Propagation.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A6-Context Sensitive Pointer Analysis</title>
    <link href="http://la-pluma.github.io/2024/12/01/SPA-A6/"/>
    <id>http://la-pluma.github.io/2024/12/01/SPA-A6/</id>
    <published>2024-12-01T13:52:02.000Z</published>
    <updated>2024-12-03T13:08:48.339Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-6 Context SensitivePointer Analysis.</strong></p><span id="more"></span><p>笔者写该实验写了一个下午之后注意力涣散了😇(†升天†)</p><blockquote><p><strong>Tips:</strong> 本次实验的指南中存在省略,因此Debug过程可能会包含一些困难.</p></blockquote><h2 id="实验目标">实验目标</h2><p>基于<strong>tai-e</strong>框架实现上下文敏感的指针分析.</p><h2 id="preparation">Preparation</h2><ul><li><p><strong>确保</strong>理解了CI和CS的指针分析理论部分知识,笔者不负责讲解课程中已经讲述过的理论知识.</p></li><li><p><strong>确保</strong>理解了实验指南中的注意事项和框架中新增以及修改的源码,否则在阅读本实验记录可能会遇到"共识"缺失的问题.</p></li></ul><h2 id="理论部分">理论部分</h2><p>总体来说, 上下文敏感指针分析算法和理论与上下文非敏感指针分析区别不大,大体框架是一致的. 笔者不再像A5中整理, 不同的部分会在下文需要时给出.</p><h2 id="框架代码">框架代码</h2><p>比起A5的框架代码变动并不大, 笔者在此简要解释一些要点.</p><img src="/2024/12/01/SPA-A6/pic1-1.png" class="" title="pic1-1"><ul><li><p>手册中该部分提及了上下文敏感指针分析中最重要的部分之一,<code>CSElement</code>和<code>Pointer</code>是本次实验主要操作的对象.</p></li><li><p>在正式写实验之前请思考这两者间的不同,如有混淆可能会影响实验的完成.(明晰两者的区别才知道该去哪里找API,该调用什么方法, 毕竟ppt上的算法是类型"模糊"的)</p></li><li><p>与A5相同, <code>Pointer</code>与<code>Obj</code>相对独立,但请注意这里的<code>CSElement</code>与<code>Element</code>同样相对独立,<code>Element</code>与<code>Context</code>组合形成了<code>CSElement</code>,因此许多API需要先取出<code>Context</code>或<code>Element</code>才能使用.具体如何取出请参阅框架代码.</p></li><li><p><code>PointsToSets</code>的实例化需要调用<code>PointsToSetsFactory</code>,这点与A5不尽相同.</p></li><li><p>上下文敏感指针信息不再通过<code>PointerFlowGraph</code>获取而是<code>CSManager</code>.</p></li><li><p><code>Solver</code>中提供了<code>private final ContextSelector contextSelector</code>来获取算法中的<code>select()</code>方法,该部分的实现对应实验指南的<strong>Task2</strong>.对于<strong>Task1</strong>, 只需要知道可以调用其中的方法获取<spanclass="math inline">\(c^t\)</span>上下文即可.</p></li></ul><h2 id="task1-实现上下文敏感指针分析">Task1 实现上下文敏感指针分析</h2><p>与A5相同, 推荐先完成顶层方法<code>analysis()</code>.</p><blockquote><p><strong>Tips:</strong>在写代码时<strong>一定一定</strong>要注意上下文, 变量命名时要有区分度,否则<strong>DEBUG</strong>时会充满痛苦.</p></blockquote><p><strong>重要:</strong> 虽然<code>Stmt</code>中不包含上下文信息,但框架代码中提供了丰富的API来根据<code>Stmt</code>的信息获取上下文信息.同时可以确定的已知的相同上下文可以直接拿过来使用.框架代码和算法原理确保了上述两点都是正确的.</p><h3 id="analysis">analysis()</h3><ul><li>逻辑上与上下文非敏感一致,区别在于需要做例如<code>Var</code>与<code>CSVar</code>的转化,传入<code>addPFGEdge()</code>的参数需要附上上下文,可通过<code>csManager.getXXX()</code>获取.</li><li>别忘了处理<strong>Array Store/Load</strong>,以及判断<code>Field</code>是否为静态字段.</li></ul><h3 id="addpfgedge">addPFGEdge()</h3><ul><li>该函数内不涉及对上下文的关注,与A5中的<code>addPFGEdge()</code>字符级一致,可以直接<code>Crtl + C/V</code>.</li></ul><h3 id="propagate">propagate()</h3><ul><li>同样不关注上下文信息, 逻辑一致,但不同的是<code>PointsToSet</code>的实例化,需要通过<code>PointsToSetFactory</code>完成.</li></ul><h3 id="processcall">processCall()</h3><ul><li>注意该过程涉及三个不同的上下文: <code>CSVar recv</code>的上下文<spanclass="math inline">\(c\)</span>,<code>CSObj recvObj</code>的上下文<spanclass="math inline">\(c&#39;\)</span>,和通过<code>select</code>选择出的上下文<spanclass="math inline">\(c^t\)</span>.在使用上下文时请确保使用的是正确的上下文.</li><li>上下文<spanclass="math inline">\(c^t\)</span>的获取可通过<code>contextSelector.selectContext()</code>方法获取.</li><li>Callee的<code>thisVar</code>以及参数和返回值的获取在A4,A5中已经指出, 如有遗忘请进行复习.</li><li><code>callGraph.addEdge()</code>中需要新建<code>Edge</code>,其中参数<code>CallKind</code>可以通过<code>CallGraphs.getCallKind()</code>获取(通过A4了解).需要注意的是,<code>CallGraphs</code>类虽然在本次实验中并未显式放在<code>src\</code>目录下,但仍然可以使用.</li><li>其余要点在A4和A5中已经提到过, 在此不再赘述.</li></ul><h3 id="addreachable">addReachable()</h3><ul><li><p>使用访问者模式时代码依旧简洁,但是需要注意的是此次使用<code>StmtProcessor</code>类时需要为每个方法实例化一个<code>StmtProcessor</code>.</p><blockquote><p><strong>Tips:</strong> 原因比较直接, 为了区分上下文信息.本次实验中处理语句需要用到<code>CSMethod</code>的上下文信息.</p></blockquote></li></ul><h4 id="class-stmtprocessor">Class StmtProcessor</h4><p>实现访问者模式的类, 在完成该部分时存在一些注意事项.</p><ul><li><p><code>Copy</code>,<code>Static StoreField</code>和<code>Static LoadField</code>与A5几乎没有区别,注意传入的参数转换为带上下文的即可.</p></li><li><p>算法伪代码中对<code>New</code>的处理和实际代码略有出入,主要体现在上下文<span class="math inline">\(c\)</span>上.<code>Obj</code>的上下文要通过<code>contextSelector.selectHeapContext()</code>获取.</p><blockquote><p>笔者在此简要的解释一下.</p><img src="/2024/12/01/SPA-A6/pic1-2.png" class="" title="pic1-2"><p>算法中将<span class="math inline">\(x\)</span>和<spanclass="math inline">\(o_i\)</span>的上下文均描述成<spanclass="math inline">\(c\)</span>, 这其实表明<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(o_i\)</span>的上下文来源相同, 而不代表这两个<spanclass="math inline">\(c\)</span>是一致的,主要原因是限制两者的<code>k</code>不一定相同.为了区分, 令其为<spanclass="math inline">\(c_x\)</span>和<spanclass="math inline">\(c_o\)</span>, 笔者通过一个例子说明原因.</p><p>假设使用<strong>CallSite敏感</strong>策略, <code>k = 2</code>,令堆上下文为<code>k - 1 = 1</code>.那么传入的<code>c:method</code>的上下文为<code>[3, 9]</code>,在该Method中有<code>15: y = new T()</code>, 对于<code>y</code>,其上下文为<code>[3, 9]</code>, 但对于<code>o15</code>,其上下文为<code>[9]</code>.即二者上下文均来自<code>c:method</code>的上下文<spanclass="math inline">\(c\)</span>, 但由于层数不同,上下文也可能是不同的.</p></blockquote></li><li><p>对于<strong>静态</strong><code>Stmt Invoke</code>的处理,最好调用<code>Context selectContext(CSCallSite, JMethod)</code>而不是<code>Context selectContext(CSCallSite, CSObj, JMethod)</code>,这是更符合框架代码API的描述的用法. 当然,也可以选择在Task2中的后者加入静态调用的处理,这样就可以在<code>Solver</code>中统一使用同一个方法.</p></li></ul><h2 id="task2-实现常见的上下文敏感策略">Task2实现常见的上下文敏感策略</h2><img src="/2024/12/01/SPA-A6/pic1-3.png" class="" title="pic1-3"><ul><li><p>注意手册上的要求和明确根据<strong>哪个参数</strong>获取上下文即可.该部分并不难实现.</p></li><li><p>另外需要注意的是框架中将四个参数合并为三个,<code>CSCallSite</code>中包含了<code>Context</code>和<code>Invoke</code>两个参数.</p></li><li><p>注意手册中对静态方法的处理要求,<strong>CallSite</strong>和<strong>Object</strong>,<strong>Type</strong>的要求并不一致.</p></li><li><p>对于<code>selectContext()</code>处理方法调用的上下文,需要根据参数新生成一层;但对于<code>selectHeapContext()</code>处理堆的上下文,则直接根据参数截取即可.</p></li></ul><h3 id="callselector-_2callselector">_1CallSelector &amp;_2CallSelector</h3><p>对于<strong>CallSite敏感</strong>策略,上下文自然在参数<code>CSCallSite callSite</code>中获取.</p><p>如果<code>k = 2</code>,枚举<code>Context</code>的层数选择最后一个和新上下文组合即可.</p><h3 id="objselector-_2objselector">_1ObjSelector &amp;_2ObjSelector</h3><p>对于<strong>Object敏感</strong>策略,上下文需要在<code>CSObj recv</code>中获取.</p><h3 id="typeselector-_2typeselector">_1TypeSelector &amp;_2TypeSelector</h3><p>对于<strong>Type敏感</strong>策略,上下文也需要在<code>CSObj recv</code>中获取.(想一想<code>Type</code>上下文选取是如何来的)</p><p>根据<strong>Type敏感</strong>的定义,可以在框架代码中找到一个对应的API: <code>Obj.getContainerType()</code>.通过该方法获取<code>Type</code>即可.</p><h2 id="总结">总结</h2><p>如果理解了CI指针分析, 本次CS指针分析实验的原理和逻辑就不难理解,但细节处理上比A5要麻烦很多, 还请小心仔细.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-6 Context Sensitive
Pointer Analysis.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A5-Context Insensitive Pointer Analysis</title>
    <link href="http://la-pluma.github.io/2024/11/27/SPA-A5/"/>
    <id>http://la-pluma.github.io/2024/11/27/SPA-A5/</id>
    <published>2024-11-27T06:38:06.000Z</published>
    <updated>2024-12-02T07:44:50.413Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-5 ContextInsensitive Pointer Analysis.</strong></p><span id="more"></span><blockquote><p>这些规则与你在课上所学到的规则非常相似<strong>（甚至更简单）</strong>. ——A5实验指南</p></blockquote><p>对......对吗？</p><h2 id="实验目标">实验目标</h2><p>基于<strong>tai-e</strong>框架实现非上下文敏感的指针分析.</p><h2 id="preparation">Preparation</h2><p><strong>Hint:</strong> A5和A6不再像之前的实验般友好,没有理解上课时所讲算法,实验指南或框架代码的人会被这两次实验狠狠地拷打.(笔者已感到有些汗流浃背了)</p><h2 id="算法理论">算法理论</h2><h3 id="算法伪代码">算法伪代码</h3><img src="/2024/11/27/SPA-A5/pic1-1.png" class="" title="pic1-1"><img src="/2024/11/27/SPA-A5/pic1-2.png" class="" title="pic1-2"><h3 id="规则形式化表述">规则形式化表述</h3><h4 id="分析语句类型">分析语句类型</h4><img src="/2024/11/27/SPA-A5/pic1-3.png" class="" title="pic1-3"><h4 id="符号体系">符号体系</h4><img src="/2024/11/27/SPA-A5/pic1-4.png" class="" title="pic1-4"><h4 id="对象传递规则">对象传递规则</h4><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr><th style="text-align: center;">Kind</th><th style="text-align: center;">Stmt</th><th style="text-align: center;">Rule</th><th style="text-align: center;">PFG Edge</th></tr></thead><tbody><tr><td style="text-align: center;">New</td><td style="text-align: center;"><code>i : x = new T()</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{}{o_i\in pt(x)}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\text{N/A}\)</span></td></tr><tr><td style="text-align: center;">Assign</td><td style="text-align: center;"><code>x = y</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{o_i\in pt(y)}{o_i \in pt(x)}\)</span></td><td style="text-align: center;"><span class="math inline">\(x \leftarrowy\)</span></td></tr><tr><td style="text-align: center;">Field Store</td><td style="text-align: center;"><code>x.f = y</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{o_i\in pt(x),\ o_j \in pt(y)}{o_j \in pt(o_i.f)}\)</span></td><td style="text-align: center;"><span class="math inline">\(y \leftarrowo_i.f\)</span></td></tr><tr><td style="text-align: center;">Field Load</td><td style="text-align: center;"><code>y = x.f</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{o_i\in pt(x),\ o_j \in pt(o_i.f)}{o_j \in pt(y)}\)</span></td><td style="text-align: center;"><span class="math inline">\(y \leftarrowo_i.f\)</span></td></tr><tr><td style="text-align: center;">Static Store</td><td style="text-align: center;"><code>T.f = y</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{o_i\in pt(y)}{o_i \in pt(T.f)}\)</span></td><td style="text-align: center;"><span class="math inline">\(T.f\leftarrow y\)</span></td></tr><tr><td style="text-align: center;">Static Load</td><td style="text-align: center;"><code>y = T.f</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{o_i\in pt(T.f)}{o_i \in pt(y)}\)</span></td><td style="text-align: center;"><span class="math inline">\(y \leftarrowT.f\)</span></td></tr><tr><td style="text-align: center;">Array Store</td><td style="text-align: center;"><code>x[i] = y</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{o_u\in pt(x),\ i_v \in pt(y)}{o_v \in pt(o_u[*])}\)</span></td><td style="text-align: center;"><span class="math inline">\(o_u[*]\leftarrow y\)</span></td></tr><tr><td style="text-align: center;">Array Load</td><td style="text-align: center;"><code>y = x[i]</code></td><td style="text-align: center;"><span class="math inline">\(\dfrac{o_u\in pt(x),\ o_v \in pt(o_u[*])}{o_v \in pt(y)}\)</span></td><td style="text-align: center;"><span class="math inline">\(y \leftarrowo_u[*]\)</span></td></tr><tr><td style="text-align: center;">Call</td><tdstyle="text-align: center;"><code>l : r = x.k(a1, ..., an)</code></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{\begin{array}{c} o_i \in pt(x),\ m =Dispatch(o_i,\ k),\\ o_u \in pt(aj),\ i \leq j \leq n,\\ o_v \inpt(m_{ret})\end{array}}{\begin{array}{c} o_i \in pt(m_{this}),\\ o_u \inpt(m_{pj}),\ 1 \leq j \leq n,\\ o_v \in pt(r)\end{array}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\begin{array}{c}a1 \rightarrow m_{p1} \\ ... \\ an\rightarrow m_{pn} \\ r \leftarrow m_{ret}\end{array}\)</span></td></tr><tr><td style="text-align: center;">Static Call</td><td style="text-align: center;"><code>r = T.k(a1, ..., an)</code></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{\begin{array}{c} o_u \in pt(aj),\ i \leq j\leq n,\\ o_v \in pt(m_{ret}) \end{array}}{\begin{array}{c} o_u \inpt(m_{pj}),\ 1 \leq j \leq n,\\ o_v \in pt(r) \end{array}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\begin{array}{c} a1 \rightarrow m_{p1} \\ ... \\an \rightarrow m_{pn} \\ r \leftarrow m_{ret} \end{array}\)</span></td></tr></tbody></table><h2 id="部分框架代码带读">部分框架代码带读</h2><p>该部分是为分析实际伪代码的书写,因为课程上的算法和框架中的实现不完全一致, 主要体现在 <strong>Stmt inMethod</strong> 这一部分. 笔者就部分关键框架代码进行讲解.</p><h3 id="概览">概览</h3><p><code>graph.callgraph</code>,<code>ir</code>包中的大部分文件在先前的实验中已经了解,如有遗忘或模糊可以参考先前的实验指南或自行阅读相关框架代码.</p><p><strong>着重注意</strong><code>Stmt</code>的层次结构和<code>Stmt</code>中包含的信息类型的继承关系(如<code>Var</code>,<code>LValue</code>等),以及<code>JMethod</code>和<code>IR</code>相关信息,较为重要的是在A4中如何获取形参和实参.</p><p>新的文件主要集中在<code>pta</code>包中, 笔者在此着重介绍该部分.</p><h3 id="pointer-pointstoset">Pointer &amp; PointsToSet</h3><p>指针分析中最重要的两个类型, 前者是在指针流图中的节点,后者存储指向信息.</p><p>在框架代码中,每个<code>Pointer</code>包含一个<code>PointsToSet</code>实例,包含该指针指向的对象信息.</p><p>通过阅读<code>pointsToSet</code>源码,不难看出是由基本的<code>Set</code>实例化得到,支持<code>Set</code>的常规基本操作.</p><h4 id="varptr-instancefield-staticfield-arrayindex">VarPtr &amp;InstanceField &amp; StaticField &amp; ArrayIndex</h4><p>代表了四种指针类型, 均继承自<code>Pointer</code>.</p><p>与<code>Pointer</code>相比没有太大的不同,仅根据类型不同添加了如何获取指针信息的API.</p><h3 id="pointerflowgraph">PointerFlowGraph</h3><p>本次实验中最重要的类之一, 存储了指针分析过程中的指针流信息.</p><p>其实现运用了多个<code>Map</code>, 其提供的API包括两类:</p><ul><li><p>图结构的<code>addEdge()</code>和<code>getSuccOf()</code>,这两个API可以修改和遍历<strong>PFG</strong>.</p></li><li><p>图信息的四种<code>get</code>方法,由于<code>JMethod</code>,<code>IR</code>以及<code>Obj</code>与<code>Pointer</code>并不是直接关联,该类方法提供了一个获取对应类型指针的API. &gt; <strong>Tips:</strong>举个例子, 对于<code>Stmt</code>类型的Assign语句<code>x = y</code>,可以解析得到<code>Var</code>类型的<code>x</code>和<code>y</code>,通过<code>getVarPtr()</code>方法就可以得到<code>Var</code>类型的<code>x</code>,<code>y</code>在<strong>PFG</strong>中对应的指针.</p></li></ul><h3 id="cipta-ciptaresult-resultprocessor">CIPTA &amp; CIPTAResult &amp;ResultProcessor</h3><p>这些类与实现的核心逻辑联系不大,这三个类负责处理指针分析算法的前后工作, 提供了初始化,执行指针分析和解析指针分析结果的API. 更具体的信息可以阅读框架代码.</p><h3 id="heapmodel-obj">HeapModel &amp; Obj</h3><p>该部分对应了指针分析原理中的<strong>堆抽象</strong>部分.</p><p>内部涉及的API比较简单, 且大多数不需要关注, 需要注意的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapModel</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the abstract object for given new statement.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Obj <span class="title function_">getObj</span><span class="params">(New allocSite)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法提供了获取<code>Stmt New</code>语句创建的对象的API.</p><blockquote><p><strong>Tips:</strong> 指针分析中最特殊的语句便是<code>New</code>,只有<code>New</code>语句可以创建对象,指针流图中所有的对象均是由<code>New</code>方法创建出来的.因此只有<code>New</code>语句需要通过与<strong>抽象堆</strong>交互获取对象,其余语句获取对象均由<strong>PFG</strong>中传递得到.</p></blockquote><h3 id="stmt-package">Stmt Package</h3><p>本次实验所涉及的<code>Stmt</code>类型继承关系为<code>Stmt-&gt;AbstractStmt-&gt;DefinitionStmt-&gt;AssignStmt-&gt;(FieldStmt)</code></p><p>其中大部分API在之前的实验中已经熟悉了.以下介绍一些本实验中可能涉及的细节.</p><h4 id="fieldstmt">FieldStmt</h4><p>该类提供了<code>getFieldAccess()</code>和<code>getFieldRef()</code>,其中后者比较重要,可以通过<code>fieldStmt.getFieldRef().resolve()</code>获得<code>JField field</code>.(实验指南中已指出)</p><h4 id="accept-可选">accept() *可选</h4><p>详见<a href="#stmtvisitor-可选"><strong>StmtVisitor</strong></a></p><h3 id="worklist">WorkList</h3><p>对应算法伪代码中的WorkList.(笔者较为疑惑为何其内部节点称为<code>Entry</code>)</p><h3 id="callgraph-abstractcallgraph-defaultcallgraph">CallGraph &amp;AbstractCallGraph &amp; DefaultCallGraph</h3><p>CallGraph在实验A4中已经接触过了, 笔者在此不再赘述.</p><h3 id="stmtvisitor-可选">StmtVisitor *可选</h3><p>访问者模式不是完成本实验必要的部分, 如果不打算使用访问者模式,可以跳过这一部分.</p><p><code>Solver</code>中的<code>class StmtProcessor</code>继承自该类,用以实现<strong>访问者设计模式</strong>.内部重载了多个<code>visit()</code>方法, 用以访问不同的类型.</p><p>需要注意的是, 访问者模式需要被访问的类支持这一设计,具体表现为其包含<code>accept()</code>方法.</p><p>访问者用以优雅地替代大量<code>instanceof</code>的判断,由<strong>访问类</strong>(本次实验中为<code>class StmtProcessor</code>)的函数重载巧妙地避开大量的类型判定.</p><p>笔者在此以<code>New</code>,<code>Copy</code>和<code>StmtProcessor</code>为例具体说明.</p><p>在本次实验中, <code>addReachable()</code>需要遍历新方法中的所有语句,对不同语句做不同处理.</p><img src="/2024/11/27/SPA-A5/pic1-5.png" class="" title="pic1-5"><p>显然这些处理从封装的角度看不应当嵌入到<code>New</code>和<code>Assign</code>类的内部,而是应当放在外部进行处理, 那么如果不使用访问者模式,写出来的代码大概是长这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> New newStmt)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> Assign assignStmt)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码一点也不优雅, 充斥着大量的冗余判断.访问者模式可以很好的解决这个问题.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">New</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(StmtVisitor&lt;T&gt; visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处略去Assign</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StmtVisitor</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">visit</span><span class="params">(New stmt)</span>;</span><br><span class="line">    T <span class="title function_">visit</span><span class="params">(Assign stmt)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StmtProcessor</span> <span class="keyword">implements</span> <span class="title class_">StmtVisitor</span>&lt;Void&gt;&#123;</span><br><span class="line">    Void <span class="title function_">visit</span><span class="params">(New stmt)</span>&#123;</span><br><span class="line">        <span class="comment">//handle new stmt</span></span><br><span class="line">    &#125;</span><br><span class="line">    Void <span class="title function_">visit</span><span class="params">(Assign stmt)</span>&#123;</span><br><span class="line">        <span class="comment">//handle assign stmt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时将遍历<code>Stmt</code>的代码改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">    stmt.accept(stmtProcessor); <span class="comment">// 已经实例化过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑应该是不难理解的,在<code>instanceof</code>实现的遍历中, 就好像是一个提供多种服务的公司,挨个询问客户购买的是什么服务然后提供服务(在这里简单假设每家只购买了一种服务).而访问者模式中,客户向公司发送"请求",公司从多个服务中选择正确的为客户进行服务(函数重载).</p><p>在访问者模式中,<code>New</code>和<code>Assign</code>通过<code>accept()</code>方法向<code>StmtProcessor</code>提供了自己的类型,并在该方法中调用来自<code>StmtProcessor</code>的处理方法<code>visit()</code>.从面向对象设计角度来看, 是一种优于前者的设计模式.</p><h2 id="框架代码中的算法">框架代码中的算法</h2><h3 id="s-s_m">S &amp; S_m</h3><blockquote><p>这里部分参考了<ahref="https://github.com/RicoloveFeng"><strong>RicoloveFeng|SPA-Freestyle-Guidance</strong></a>中的内容.</p></blockquote><p>这里是与课上讲述的算法区别最大的地方.阅读<code>Sovler</code>中的代码, 发现该部分是不存在对应关系的.</p><p>重读定义<code>Var</code>的文件,会发现一些之前没有用到的函数在本次实验中利用了起来,如<code>addLoadField()</code>, <code>getLoadFields()</code>.</p><p>这些方法就是"隐式"维护S和S_m的API(说<strong>隐式</strong>是因为对于完成实验来说,该部分不需要详细了解).</p><p>这部分实现了S和S_m的"自动"维护, 即通过生成<strong>IR</strong>,和<code>CallGraph</code>中的<code>addMethod()</code>进行维护.具体的细节可以阅读源码.</p><p>对于完成本次实验来说, 只需要知道不需要处理有关S和S_m的工作了,在需要获取相关信息时,直接通过<code>Var</code>中的<code>getXXX()</code>获取即可.</p><h3 id="基于框架代码的算法伪代码">基于框架代码的算法伪代码</h3><p><strong>Tips:</strong> 该部分的代码不会严格遵循框架代码中的API,仅作示例.</p><p><strong>推荐完成顺序:</strong>优先实现顶层方法<code>analysis()</code></p><h4 id="analysis">analysis()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">analysis</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 所有的初始化工作框架代码中已经完成, 包括添加Entry Method</span></span><br><span class="line">    <span class="comment">// 这里只需要处理while WorkList NOT Empty即可</span></span><br><span class="line">    <span class="keyword">while</span>(WorkList.isNotEmpty())&#123;</span><br><span class="line">        &lt;n, pts&gt; = WorkList.poll() <span class="comment">// &lt;Pointer, PointsToSet&gt;</span></span><br><span class="line">        delta_pts = propagate(n, pts)</span><br><span class="line">        <span class="keyword">if</span>(n <span class="keyword">instanceof</span> VarPtr x)&#123;</span><br><span class="line">            foreach oi in delta_pts <span class="keyword">do</span>&#123;</span><br><span class="line">                foreach x.getStoreFields() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// x.f = y</span></span><br><span class="line">                    addEdge(y, oi.f)</span><br><span class="line">                foreach x.getLoadFields() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// y = x.f</span></span><br><span class="line">                    addEdge(oi.f, y)</span><br><span class="line">                foreach x.getStoreArrays() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// x[i] = y</span></span><br><span class="line">                    addEdge(y, oi[*])</span><br><span class="line">                foreach x.getLoadArrays() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// y = x[i]</span></span><br><span class="line">                    addEdge(oi[*], y)</span><br><span class="line"></span><br><span class="line">                processCall(x, oi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分的逻辑比较简单, 照着算法写就行,获取跟<code>Var x</code>相关的<code>Stmt</code>的方法在<ahref="#s--s_m"><strong>S &amp; S_m</strong></a>部分已经讲过,此处不再赘述.</p><p>不要忘记依手册在此处完成对Array的处理.</p><h4 id="addpfgedge">addPFGEdge()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addPFGEdge</span><span class="params">(Pointer source, Pointer target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointerFlowGraph.addEdge(source, target))&#123;</span><br><span class="line">        <span class="comment">// form API: true mean not include</span></span><br><span class="line">        <span class="keyword">if</span> (source.getPointsToSet().isNotEmpty())&#123;</span><br><span class="line">            WorkList.add(&lt;target, source_pts&gt;) <span class="comment">// &lt;Pointer, PointsToSet&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是照着算法写即可.</p><h4 id="propagate">propagate()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PointsToSet <span class="title function_">propagate</span><span class="params">(Pointer pointer, PointsToSet pointsToSet)</span>&#123;</span><br><span class="line">    delta_pts = pointsToSet - pointer.getPointsToSet();</span><br><span class="line"></span><br><span class="line">    pointer_pts += delta_pts;</span><br><span class="line"></span><br><span class="line">    foreach pointerpointerFlowGraph.getSuccsOf(pointer) <span class="keyword">do</span></span><br><span class="line">        <span class="comment">//succ of pointer node</span></span><br><span class="line">        WorkList.add(&lt;succ, delta_pts&gt;) <span class="comment">// &lt;Pointer, PointsToSet&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="processcall">processCall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">processCall</span><span class="params">(Var <span class="keyword">var</span>, Obj recv)</span> &#123;</span><br><span class="line">    foreach <span class="keyword">var</span>.<span class="keyword">var</span>.getInvokes() <span class="keyword">do</span></span><br><span class="line">        <span class="comment">// [invoke] l: r = x.k(a1,..., an)</span></span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">method</span> <span class="operator">=</span> resolveCallee(recv, invoke)</span><br><span class="line">        <span class="keyword">if</span>(method thisVar is not empty)&#123;</span><br><span class="line">            <span class="comment">//means is not Static</span></span><br><span class="line">            <span class="comment">//also can use !invoke.isStatic()</span></span><br><span class="line">            workList.add(&lt;method_this, recv&gt;);</span><br><span class="line">            <span class="keyword">if</span>(callGraph.addEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>(callKind, invoke, method)))&#123;</span><br><span class="line">                <span class="comment">//transfer paramters &amp; return Var</span></span><br><span class="line">                foreach paramters : addEdge();</span><br><span class="line">                returnVar : addEdge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些细节需要注意:</p><ul><li>如何处理<code>JMethod</code>在A4中已经接触过了,可以通过<code>method.getIR().getThis()</code>获取该方法的this Var,然后再通过<strong>PFG</strong>就能获取this Pointer了. 如果还有印象的话,A4中通过<code>CallGraphs.getCallKind()</code>来获取<code>CallKind</code>,在本次实验沿用该方法即可.</li><li>在这里不处理Static Call, 通过判断是否存在this指针,<code>isStatic()</code>方法都可以判断(尽管从实际上分析,此处不应该也不可能出现Static Call)</li><li>之后的处理参数和返回值同A4,同样需要注意返回值是否被丢弃或有复数个返回值.</li></ul><h4 id="addreachable">addReachable()</h4><p>如果不使用访问者模式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addReachable</span><span class="params">(JMethod method)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callGraph.addReachableMethod(method))&#123;</span><br><span class="line">        <span class="comment">//form API : true means not include</span></span><br><span class="line">        <span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> New)&#123;</span><br><span class="line">                WorkList.add(stmt_def, obj)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> Assign)&#123;</span><br><span class="line">                addEdge(right, left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> StoreField &amp;&amp; isStatic)&#123;</span><br><span class="line">                addEdge(right, left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> LoadField &amp;&amp; isStatic)&#123;</span><br><span class="line">                addEdge(right, left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> Invoke &amp;&amp; isStatic)&#123;</span><br><span class="line">                <span class="comment">//same as processCall</span></span><br><span class="line">                <span class="comment">//except do not need to add &lt;this, obj&gt; to workList</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用访问者模式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addReachable</span><span class="params">(JMethod method)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callGraph.addReachableMethod(method))&#123;</span><br><span class="line">        <span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">            stmt.accept(stmtProcessor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑同不使用访问模式的<code>instanceof</code>成立后执行的方法.将这些方法写进<code>StmtProcessor</code>中的<code>visit()</code>即可.</p><blockquote><p><strong>Tips:</strong> 为什么要在这里处理静态方法和字段?</p><p>在回答这个问题之前,不妨思考一下为什么非静态指针要在<code>analysis()</code>中如此处理.因为不论是字段还是方法, 都需要"resolve"到一个确定的结果时,才能进行分析和对象传递. 而静态方法和静态字段的对象是唯一确定的,在遍历到一个新方法时只需要处理一次.</p></blockquote><ul><li>框架代码中的<code>CallGraph</code>包含了<code>RM</code>,阅读相关API以获取详细信息.</li><li>如何根据<code>Stmt</code>信息获取指针<code>Pointer</code>的方法在上文框架代码分析中已经指出.如果该方法在后期完成, 此时应当已经知道如何获取所需参数和类型.</li><li>需要注意的是在此仍然需要通过<code>resolveCallee()</code>方法获得静态方法,参数设置为<code>recv = null</code>即可.</li></ul><h2 id="总结">总结</h2><p>指针分析还是相当硬核的, 尽管实验框架已经化简了其中部分内容,这仍然是一个较困难的实验.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-5 Context
Insensitive Pointer Analysis.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda+Cuda+Pytorch+Pycharm环境配置</title>
    <link href="http://la-pluma.github.io/2024/11/25/conda-env/"/>
    <id>http://la-pluma.github.io/2024/11/25/conda-env/</id>
    <published>2024-11-24T17:53:37.000Z</published>
    <updated>2024-11-25T18:17:41.400Z</updated>
    
    <content type="html"><![CDATA[<p><strong>笔者个人conda环境搭建记录.</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#前言">前言</a></li><li><a href="#安装pycharm--anaconda">安装Pycharm &amp; Anaconda</a><ul><li><a href="#pycharm">Pycharm</a></li><li><a href="#anaconda3">Anaconda3</a><ul><li><a href="#选项配置">选项配置</a></li><li><a href="#环境变量">环境变量</a></li><li><a href="#安装位置">安装位置</a></li><li><a href="#debug">Debug</a></li><li><a href="#anaconda-安装检测">Anaconda 安装检测</a></li></ul></li></ul></li><li><a href="#安装cuda">安装Cuda</a></li><li><a href="#安装pytorch">安装Pytorch</a><ul><li><a href="#anaconda创建conda环境">Anaconda创建conda环境</a></li><li><a href="#确定pytorch版本">确定Pytorch版本</a></li><li><a href="#pytorch安装检测">Pytorch安装检测</a></li></ul></li><li><a href="#pycharm激活conda环境">Pycharm激活conda环境</a><ul><li><a href="#导入环境检测">导入环境检测</a></li></ul></li><li><a href="#参考资料">参考资料</a></li></ul><h2 id="前言">前言</h2><p>本日志记录一次笔者配置conda环境的过程. 参考资料来源网络, 见<ahref="#参考资料"><strong>参考资料</strong></a></p><p>本次搭建环境基于<ahref="https://www.anaconda.com/"><strong>Anaconda</strong></a>+<ahref="https://developer.nvidia.com/"><strong>Cuda</strong></a>搭建<ahref="https://pytorch.org/"><strong>Pytorch</strong></a>环境并导入<ahref="https://www.jetbrains.com.cn/pycharm/"><strong>Pycharm</strong></a>中使用.</p><p>笔者的环境为:</p><p><strong>Win11家庭版23H2</strong> + <strong>CPU:AMD Ryzen 75800H</strong> + <strong>GPU: 3060laptop</strong></p><p><strong>Anaconda-2024.10.1</strong> + <strong>Cuda-12.6</strong> +<strong>Pytorch-win_x86_64-cuda12.4</strong> + <strong>PycharmCommunity-2022.2.2</strong></p><h2 id="安装pycharm-anaconda">安装Pycharm &amp; Anaconda</h2><h3 id="pycharm">Pycharm</h3><p>笔者的Pycharm已经安装好了, Community版本是可以免费使用的,安装教程可以<strong>STFW</strong>.</p><p>需要注意的是, Pycharm本身不包含python, python需要自行下载.</p><h3 id="anaconda3">Anaconda3</h3><h4 id="选项配置">选项配置</h4><img src="/2024/11/25/conda-env/pic1-1.png" class="" title="pic1-1"><p><code>Just Me</code>与<code>All Users</code>选择<code>All Users</code>.</p><img src="/2024/11/25/conda-env/pic1-2.png" class="" title="pic1-2"><p>全部勾选.</p><p>安装结束后不需要launch, 还要配置环境变量.</p><h4 id="环境变量">环境变量</h4><p>在高级系统设置中添加系统环境变量, 路径以安装路径为准.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\anaconda3</span><br><span class="line">D:\anaconda3\Scripts</span><br><span class="line">D:\anaconda3\Library\bin</span><br><span class="line">D:\anaconda3\Library\mingw-w64\bin</span><br></pre></td></tr></table></figure><h4 id="安装位置">安装位置</h4><p>如果已有分盘, 推荐安装到别的分区.</p><p>Anaconda的环境和包管理也可以迁移, 笔者本次省略了这个步骤.</p><h4 id="debug">Debug</h4><p>笔者在安装完成后遇到了打开<code>Anaconda Navigator</code>时卡死在<code>Loading Applications</code>页面上,通过为程序添加默认管理员权限解决.</p><h4 id="anaconda-安装检测">Anaconda 安装检测</h4><p>打开<code>Anaconda Prompt</code>, 页面如下:</p><img src="/2024/11/25/conda-env/pic1-3.png" class="" title="pic1-3"><p>执行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda --version</span></span><br></pre></td></tr></table></figure><p>终端输出conda版本号即成功安装了conda</p><img src="/2024/11/25/conda-env/pic1-4.png" class="" title="pic1-4"><p>可以通过如下指令查看conda的配置信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda info</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 笔者本次略去了Conda的配置, 如包和环境位置,镜像源的配置. 有需要可以自行配置.</p></blockquote><h2 id="安装cuda">安装Cuda</h2><p>调出cmd后在终端中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvidia-smi</span></span><br></pre></td></tr></table></figure><p>得到</p><img src="/2024/11/25/conda-env/pic1-5.png" class="" title="pic1-5"><p>其中<code>CUDA Version</code>代表最高支持的<code>CUDA</code>版本,到官网对应版本下载即可.</p><p>安装完成后在cmd中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvcc -V</span></span><br></pre></td></tr></table></figure><p>正常输出Cuda版本即安装完成.</p><img src="/2024/11/25/conda-env/pic1-6.png" class="" title="pic1-6"><h2 id="安装pytorch">安装Pytorch</h2><p>Pytorch依赖于conda环境, 因此在安装Pytorch前需要配置conda虚拟环境.</p><h3 id="anaconda创建conda环境">Anaconda创建conda环境</h3><p>打开<code>Anaconda Prompt</code>,此时的环境为默认的<code>base</code>(见<ahref="#anaconda-安装检测"><strong>上文</strong></a>)</p><p>执行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda create –n pytorch python=3.10</span></span><br></pre></td></tr></table></figure><p>其中<code>pytorch</code>为环境名称,<code>python=3.10</code>为指定python解释器版本.</p><p>需要注意的是,目前(2024.11)的Pytorch需要<strong>至少</strong>python版本为3.9</p><p>如果需要特定版本,在安装Pytorch时需要查看<code>Preview Version</code>.</p><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda activate pytorch</span></span><br></pre></td></tr></table></figure><p>终端环境变更为<code>pytorch</code></p><p>想要回到<code>base</code>环境, 只需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda deactivate</span></span><br></pre></td></tr></table></figure><p>Pytorch的安装位置便是在名为<code>pytorch</code>的环境中.</p><h3 id="确定pytorch版本">确定Pytorch版本</h3><p>进入Pytorch官网的Install页面</p><img src="/2024/11/25/conda-env/pic1-7.png" class="" title="pic1-7"><p>根据自己的Cuda版本选择安装.</p><p>如果选择conda安装,只需要在<code>Anaconda Prompt</code>中激活创建的<code>pytorch</code>环境,执行官网上给出的安装命令.</p><p>耐心等待安装完成即可.</p><h3 id="pytorch安装检测">Pytorch安装检测</h3><p>安装结束后, 在激活<code>pytorch</code>环境的终端中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python</span></span><br></pre></td></tr></table></figure><img src="/2024/11/25/conda-env/pic1-8.png" class="" title="pic1-8"><p>输入以下python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><img src="/2024/11/25/conda-env/pic1-9.png" class="" title="pic1-9"><p>得到类似输出而没有报错即成功在conda环境中安装pytorch.</p><h2 id="pycharm激活conda环境">Pycharm激活conda环境</h2><p>以创建的<code>pytorch</code>环境为例.</p><p>使用Pycharm打开项目, 进入<code>File-&gt;Setting</code>页面</p><img src="/2024/11/25/conda-env/pic1-10.png" class="" title="pic1-10"><p>选择<code>项目-&gt;Python解释器</code></p><p>点击<code>添加解释器-&gt;添加本地解释器-&gt;conda环境</code></p><img src="/2024/11/25/conda-env/pic1-11.png" class="" title="pic1-11"><p>Conda可执行文件输入<code>D:\anaconda3\Scripts\conda.exe</code>(依据Anaconda安装位置)</p><p>选择解释器(依据自己的conda环境创建位置)</p><img src="/2024/11/25/conda-env/pic1-12.png" class="" title="pic1-12"><p>点击确认等待配置完成.</p><h3 id="导入环境检测">导入环境检测</h3><p>与<ahref="#pytorch安装检测"><strong>Pytorch安装检测</strong></a>类似,只需要在python文件中键入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><p>执行代码得到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.5.1</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>然后就可以开始愉快(迫真)的炼丹之旅啦!</p><h2 id="参考资料">参考资料</h2><blockquote><p><strong>Tips:</strong> 博客并不能解决所有问题,对于博客中的内容要和面对ChatGPT生成的内容一样小心求证.必要时更推荐官方文档(此处略去).</p></blockquote><p><a href="https://blog.csdn.net/qq_44000789/article/details/142214660"class="uri">https://blog.csdn.net/qq_44000789/article/details/142214660</a></p><p><ahref="https://blog.csdn.net/weixin_41401924/article/details/120332417"class="uri">https://blog.csdn.net/weixin_41401924/article/details/120332417</a></p><p><a href="https://zhuanlan.zhihu.com/p/389992455"class="uri">https://zhuanlan.zhihu.com/p/389992455</a></p><p><ahref="https://blog.csdn.net/weixin_62075168/article/details/131226082"class="uri">https://blog.csdn.net/weixin_62075168/article/details/131226082</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;笔者个人conda环境搭建记录.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="AI" scheme="http://la-pluma.github.io/categories/AI/"/>
    
    
    <category term="环境配置" scheme="http://la-pluma.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="AI" scheme="http://la-pluma.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A4-CHA &amp; Inter Constant Propagation</title>
    <link href="http://la-pluma.github.io/2024/11/18/SPA-A4/"/>
    <id>http://la-pluma.github.io/2024/11/18/SPA-A4/</id>
    <published>2024-11-18T08:10:38.000Z</published>
    <updated>2024-11-18T12:00:06.297Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-4 Class HierarchyAnalysis &amp; Interprocedural Constant Propagation.</strong></p><span id="more"></span><h2 id="实验信息食用指南">实验信息&amp;食用指南</h2><p>见本博客A1-A3.</p><blockquote><p><strong>手册的手册不能替代手册, 看不懂的话请回去看手册. ——</strong><ahref="https://github.com/RicoloveFeng"><strong>RicoloveFeng|SPA-Freestyle-Guidance</strong></a></p></blockquote><h2 id="实验目标">实验目标</h2><p>基于<strong>Tai-e</strong> 框架实现 <strong>CHA</strong> &amp;<strong>Inter Constprop</strong>.</p><p><del>真的还有必要在记录里补充这个吗</del></p><h2 id="实验简析">实验简析</h2><p>其实没什么好说的, 课程 &amp; ppt &amp; 指南已经讲的比较明确了,笔者在此补充一些手册写的不明确或是略去的部分.</p><p><strong>不过本次实验涉及不少新东西,烦请耐心阅读相关代码API.</strong></p><h2 id="preparation">Preparation</h2><p>从Assignment2中将<code>ConstPropogation.java</code>copy到本次实验目录对应位置.</p><p><strong>需要注意的是,A2中不完全正确的实现可能会影响本次实验的本地测试.</strong></p><h2 id="chabuilder">CHABuilder</h2><p>这部分tt老师贴心的在ppt中给好了算法框架,对应本次的框架代码复刻即可.</p><p>需要注意的是, 只有在完成了该部分后,<strong>Tai-e</strong>框架才能正确构建<code>ICFG</code>,否则使用<code>Assignment</code>分析的结果只会为空.</p><p>推荐完成顺序 <code>dispatch</code> -&gt; <code>resolve</code> -&gt;<code>buildCallGraph</code></p><h3 id="dispatch">dispatch()</h3><p>可以选择递归或者循环完成该部分.</p><ul><li><p><code>dispatch()</code>可能会失败, 此时可以返回<code>null</code>,但要确保<code>resolve()</code>中可以正确处理这一情况.</p><blockquote><p><strong>Additional:</strong> 为什么可能会失败?</p><p><code>resolve()</code>中,假设我们要处理一个<code>Interface</code>或者<code>Abstract</code>类型声明的类方法,首先我们需要<code>dispatch</code>这个声明类本身,易见此时应当得到<code>null</code>(接口中的方法和抽象方法无法被实例化)</p></blockquote></li><li><p><code>dispatch()</code>得到的<code>JMethod</code>如果是<code>Abstract</code>,同样需要返回<code>null</code>.</p><blockquote><p><strong>Tips:</strong> 由于OOP的机制,当<code>JMethod</code>是<code>Abstract</code>时,不需要继续<code>dispatch</code>了.如果对此感到困惑可以去查阅相关的OOP资料.</p></blockquote></li></ul><h3 id="resolve">resolve()</h3><ul><li><p>遍历的方式自选, 笔者采用较好实现的BFS.</p></li><li><p>尽管课上将<code>Interface</code>归入了<strong>VirtualInvoke</strong>, 但按照代码框架,这部分单独作为一个需要处理的<code>CallKind</code>.不过处理起来也并非难事,因为处理方式和<code>VIRTUAL</code>没有实质性区别.</p></li><li><p>需要注意的是,框架中处理<strong>Interface</strong>和<strong>Class</strong>分别有专门的API方法,具体使用什么API, 可以阅读<code>ClassHierarachy</code>,<code>CHABuilder</code>中也提供了访问<code>ClassHierarachy</code>的成员<code>private ClassHierarchy hierarchy</code>.</p></li><li><p><code>STATIC</code>方法的获取在框架中没有专门的API,但可以使用<code>dispatch()</code>获取,因此<code>STATIC</code>和<code>SPRECIAL</code>也可以一起处理.</p></li></ul><h3 id="buildcallgraph">buildCallGraph()</h3><p>实现和ppt中的算法没有区别.</p><ul><li><p>判断是否可达在框架中集成到了<code>Class CallGraph</code>的<code>addReachableMethod()</code>方法中了,可以阅读API注释获取更详细的信息.</p></li><li><p>得到<code>callSite</code>,<code>callKind</code>的方法也可以通过<code>Class CallGraph</code>获取.<del>(我看看是谁不想去读API注释)</del></p></li></ul><h2 id="intersovler">InterSovler</h2><p>由于框架代码在<code>InterSovler</code>这一部分进行了较大幅度的重构,因此笔者推荐先完成该部分使得对<code>InterConstantPropopagation</code>有一个自顶向下的认识.</p><p>同手册所说, 该部分比起A2的<code>worklistSovler</code>没有太大的区别,跟着手册做即可.</p><p><strong>注意:</strong>该部分实例化的<code>private final InterDataflowAnalysis&lt;Node, Fact&gt; analysis</code>继承自<code>Class AbstractInterDataflowAnalysis</code>,该部分的源码阅读是必不可少的.<del>(这里不读在完成InterConstantPropopagation的时候也要读)</del></p><h3 id="initialize">initialize()</h3><ul><li>除去icfg的入口方法使用<code>BoundaryInit</code>外,其余节点均使用<code>NormalInit</code>.可以通过<code>icfg.entryMethods()</code>方法获取入口方法.</li></ul><blockquote><p><strong>Tips:</strong>需要注意的是<code>icfg.entryMethods()</code>返回的是<code>Stream</code>类型,遍历该类型可以使用<code>forEach</code>.更多关于<code>forEach</code>的信息可以查阅java的文档.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">icfg.entryMethods().forEach(method -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>Confusion:</strong> 笔者在此比较困惑为何可能会出现多个入口,虽然在网络上查询得知java中可能不止一个<code>main()</code>方法,但不知如何在tai-e框架中复现,以及本次实验中的"多个入口"是否对应该特性.</p></blockquote><h3 id="dosolve">dosolve()</h3><p>与A2相比,只需要修改处理<code>pred Node</code>部分为<code>pred Edge</code>,可以通过<code>getInEdgesOf()</code>方法获得<code>pred Edge</code>信息,与<code>analysis.transferNode()</code>对应,可通过<code>analysis.transferEdge()</code>来处理<code>pred Edge</code>.</p><h2 id="interconstantpropopagation">InterConstantPropopagation</h2><p>部分API在框架中已经给出了实现, 在该部分只需要实现6个API即可.</p><p><strong>善用A2中完成部分进行本次实验,过程间常量传播并不影响计算常量的逻辑.</strong></p><h3 id="transfercallnode-transfernoncallnode">transferCallNode() &amp;transferNonCallNode()</h3><p>含义同方法名,如果这个<code>Node</code>(即<code>Stmt</code>)是<code>Invoke</code>,就称该<code>Node</code>为<code>CallNode</code>,否则为<code>NonCallNode</code>.</p><ul><li>需要注意的是,过程间处理的大部分操作都在<code>Edge</code>上而非<code>Node</code>上,因此我们在<code>transferCallNode()</code>中并不会进行 add/kill def的操作. 这一点与指南上的图片逻辑相同.</li></ul><img src="/2024/11/18/SPA-A4/pic4-1.png" class="" title="pic4-1"><blockquote><p>如图片所示,<code>Node 2</code>在经过<code>transferCallNode()</code>后并没有把<code>b</code>添加进<code>outFact</code>.</p><p>尽管我们可以在这里处理, <del>但这样有可能会让你过不去oj</del>,但这样会造成逻辑上的混乱, 所有的<strong>interprocedural</strong>操作都在<code>Edge</code>上进行在逻辑上是一致的.接下来对四种<code>transferEdge</code>的处理中会解释这一点.</p></blockquote><ul><li>所以对于非call Node,可以直接使用过程内分析的<code>transferNode()</code>方法, 对于call Node,<code>transferCallNode()</code>只需要把<code>inFact</code> 赋值给<code>outFact</code>即可.</li></ul><h3 id="transferedge">transfer**Edge</h3><p>在完成该部分前, 要先知道该部分会在什么地方使用,通过阅读<code>Class AbstractInterDataflowAnalysis</code>的源码API,可以发现四种<code>transfer**Edge</code>统一为了一个方法<code>transferEdge()</code>.(如果阅读的足够仔细,会发现两个<code>NodeTransfer</code>的方法也被统一为了<code>transferNode()</code>)</p><p><strong>注意:</strong> 如手册所言, 由于java的引用机制,不应当对第二个参数<code>CPFact out</code>做任何修改.返回值也不应是第二个参数本身,需要深拷贝一个<code>out</code>或者<code>new CPFact()</code>.</p><h4 id="transfernormaledge">transferNormalEdge()</h4><p>对于普通节点, 不需要对<code>OutFact</code>中的内容做修改,直接传给<code>Edge</code>的<code>target</code>即可.</p><blockquote><p>对应上文图片中的<strong>黑色实线</strong>.</p></blockquote><h4 id="transfercalltoreturnedge">transferCallToReturnEdge()</h4><p>在这里要处理<strong>def kill</strong>工作, 根据框架代码,这里的<code>Stmt</code>一定是<code>Invoke</code>,请阅读源码API获取使用信息.</p><ul><li><code>Invoke</code>继承自<code>DefinitionStmt</code>,如何获取<code>def</code>在之前的实验中已有涉及.</li></ul><blockquote><p>对应上文图片中的<strong>黑色虚线</strong>.</p></blockquote><h4 id="transfercalledge">transferCallEdge()</h4><p>负责传参中的<code>Var</code>转换.</p><ul><li><p>对于<code>Invoke invoke</code>,可以通过<code>invoke.getInvokeExp().getArgs()</code>获取传入<strong>实参</strong>的信息.</p></li><li><p>对于<code>JMethod callee</code>,可以通过<code>callee.getIR().getParams()</code>获取调用方法的<strong>形参</strong>信息.</p></li><li><p>在tai-e框架中, 保证上述形参与实参列表顺序是一一对应的.可以根据这一特性维护传参的转换过程.</p></li></ul><blockquote><p>对应上文图片中的<strong>蓝色虚线</strong>.</p></blockquote><h4 id="transferreturnedge">transferReturnEdge()</h4><p>负责将调用方法的返回值传回<code>callSite</code>.</p><ul><li><code>Class ReturnEdge</code>的<code>getReturnVars()</code>的API说明讲明了为什么可能有多个返回值,需要注意的是, 如果有多个返回值,需要使用<code>cp.meetValue()</code>.</li></ul><blockquote><p>对应上文图片中的<strong>红色虚线</strong>.</p></blockquote><h2 id="总结">总结</h2><p>过程间常量传播的思想还是比较巧妙的, 值得细心品味.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-4 Class Hierarchy
Analysis &amp;amp; Interprocedural Constant Propagation.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-On Java8 Ch3-Ch5</title>
    <link href="http://la-pluma.github.io/2024/11/03/BookNote-OnJava8-by-BruceEckel-2/"/>
    <id>http://la-pluma.github.io/2024/11/03/BookNote-OnJava8-by-BruceEckel-2/</id>
    <published>2024-11-03T11:29:38.000Z</published>
    <updated>2024-11-13T13:01:43.739Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java语言假设程序员只进行面向对象编程,因此Java中(几乎)万物皆对象.</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#chapter3-万物皆对象">Chapter3 万物皆对象</a><ul><li><a href="#对象操纵">对象操纵</a></li><li><a href="#对象创建">对象创建</a><ul><li><a href="#数据存储">数据存储</a></li><li><a href="#基本类型存储">基本类型存储</a></li><li><a href="#高精度数值">高精度数值</a></li><li><a href="#数组存储">数组存储</a></li></ul></li><li><a href="#代码注释">代码注释</a></li><li><a href="#对象清理">对象清理</a><ul><li><a href="#作用域">作用域</a></li><li><a href="#对象作用域">对象作用域</a></li></ul></li><li><a href="#类的创建">类的创建</a><ul><li><a href="#类型">类型</a></li><li><a href="#字段field">字段(Field)</a></li><li><a href="#基本类型默认值">基本类型默认值</a></li><li><a href="#方法使用">方法使用</a></li><li><a href="#返回类型">返回类型</a></li><li><a href="#参数列表">参数列表</a></li></ul></li><li><a href="#程序编写">程序编写</a><ul><li><a href="#命名可见性">命名可见性</a></li><li><a href="#import">import</a></li><li><a href="#static">static</a></li></ul></li><li><a href="#编码风格">编码风格</a></li></ul></li><li><a href="#chapter4-运算符">Chapter4 运算符</a><ul><li><a href="#beginning">Beginning</a></li><li><a href="#优先级关联性">优先级&amp;关联性</a></li><li><a href="#赋值">赋值</a></li><li><a href="#算术运算符">算术运算符</a></li><li><a href="#自增自减">自增&amp;自减</a></li><li><a href="#关系运算符">关系运算符</a></li><li><a href="#逻辑运算符">逻辑运算符</a><ul><li><a href="#短路">短路</a></li></ul></li><li><a href="#字面值常量literal">字面值常量(Literal)</a></li><li><a href="#位运算符">位运算符</a></li><li><a href="#三目运算符">三目运算符</a></li></ul></li><li><a href="#chapter5-控制流">Chapter5 控制流</a><ul><li><a href="#if-else">if-else</a></li><li><a href="#for-while-do-while">for while do-while</a></li><li><a href="#return">return</a></li><li><a href="#breakcontinue">break&amp;continue</a><ul><li><a href="#标签">标签</a></li></ul></li><li><a href="#switch">switch</a></li></ul></li></ul><hr /><h2 id="chapter3-万物皆对象">Chapter3 万物皆对象</h2><blockquote><p><strong>如果我们说另一种不同的语言, 我们会发觉一个不同的世界! ——Ludwig Wittgenstein(1889-1951)</strong></p></blockquote><h3 id="对象操纵">对象操纵</h3><p>所有的编程语言都会操纵内存中的元素.</p><blockquote><ul><li>C/C++中对象的操纵是通过指针来完成的.</li><li>Java利用万物皆对象的思想和单一一致的语法方式来简化问题,采用<strong>引用(Reference)</strong> 操纵对象.</li></ul></blockquote><h3 id="对象创建">对象创建</h3><p>Java中使用<strong>引用</strong>关联<strong>对象</strong>.</p><p>通常使用关键字<code>new</code>创建对象实例.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="数据存储">数据存储</h4><ul><li><strong>寄存器(Registers)</strong>: 最快的存储器, 位于CPU内部.但数量有限,且Java无法直接控制(C/C++允许开发者像编译器建议寄存器的分配).</li><li><strong>栈内存(Stack)</strong>: 位于<strong>随机访问存储器(RandomAccess Memory, RAM)</strong> 中, CPU可通过栈指针直接访问.栈指针下移分配内存, 上移释放内存. 但栈上的数据要求提前知晓对象生存周期,因此栈内存上只存放部分Java数据, 对象本身存储在堆内存.</li><li><strong>堆内存(Heap)</strong>: RAM区域的一种通用内存池,存放着所有的Java对象. 相较于栈区, 堆区的使用更灵活,但代价是分配和清理对象会比栈区更耗时.</li><li><strong>常量存储(COnstant Storage)</strong>: 通常直接放在代码中,可考虑置于<strong>只读存储器(Read Only Memory, ROM)</strong>.</li><li><strong>非RAM存储(Non-RAM Storage)</strong>: 数据存在于程序之外,包括<strong>序列化对象</strong>和<strong>持久化对象</strong>.</li></ul><h4 id="基本类型存储">基本类型存储</h4><p>Java中使用和C/C++一样策略的基本类型数据, 存放在栈中,其内存占用大小固定.</p><table><thead><tr><th style="text-align: center;">基本类型</th><th style="text-align: center;">大小</th><th style="text-align: center;">最小值</th><th style="text-align: center;">最大值</th><th style="text-align: center;">包装类型</th></tr></thead><tbody><tr><td style="text-align: center;">boolean</td><td style="text-align: center;">---</td><td style="text-align: center;">---</td><td style="text-align: center;">---</td><td style="text-align: center;">Boolean</td></tr><tr><td style="text-align: center;">char</td><td style="text-align: center;">16bits</td><td style="text-align: center;"><span class="math inline">\(Unicode\0\)</span></td><td style="text-align: center;"><span class="math inline">\(Unicode\2^{16}-1\)</span></td><td style="text-align: center;">Character</td></tr><tr><td style="text-align: center;">byte</td><td style="text-align: center;">8bits</td><td style="text-align: center;"><spanclass="math inline">\(-128\)</span></td><td style="text-align: center;"><spanclass="math inline">\(+127\)</span></td><td style="text-align: center;">Byte</td></tr><tr><td style="text-align: center;">short</td><td style="text-align: center;">16bits</td><td style="text-align: center;"><spanclass="math inline">\(-2^{15}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(+2^{15}-1\)</span></td><td style="text-align: center;">Short</td></tr><tr><td style="text-align: center;">int</td><td style="text-align: center;">32bits</td><td style="text-align: center;"><spanclass="math inline">\(-2^{31}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(+2^{31}-1\)</span></td><td style="text-align: center;">Integer</td></tr><tr><td style="text-align: center;">long</td><td style="text-align: center;">64bits</td><td style="text-align: center;"><spanclass="math inline">\(-2^{63}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(+2^{63}-1\)</span></td><td style="text-align: center;">Long</td></tr><tr><td style="text-align: center;">float</td><td style="text-align: center;">32bits</td><td style="text-align: center;"><spanclass="math inline">\(IEEE754\)</span></td><td style="text-align: center;"><spanclass="math inline">\(IEEE754\)</span></td><td style="text-align: center;">Float</td></tr><tr><td style="text-align: center;">double</td><td style="text-align: center;">64bits</td><td style="text-align: center;"><spanclass="math inline">\(IEEE754\)</span></td><td style="text-align: center;"><spanclass="math inline">\(IEEE754\)</span></td><td style="text-align: center;">Double</td></tr><tr><td style="text-align: center;">void</td><td style="text-align: center;">---</td><td style="text-align: center;">---</td><td style="text-align: center;">---</td><td style="text-align: center;">Void</td></tr></tbody></table><p>在堆区表示基本类型数据, 需要使用包装类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">Charactor</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Charactor</span>(c);</span><br><span class="line"><span class="type">Charactor</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Charactor</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">Charactor</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="comment">//自动开箱</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ch;</span><br></pre></td></tr></table></figure><h4 id="高精度数值">高精度数值</h4><p><code>BigInteger</code> &amp; <code>BigDecimal</code></p><h4 id="数组存储">数组存储</h4><p>Java设计主要目标之一是安全性, 尽管牺牲了部分效率, 但换来了安全性.</p><h3 id="代码注释">代码注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 跨行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单行注释</span></span><br></pre></td></tr></table></figure><h3 id="对象清理">对象清理</h3><h4 id="作用域">作用域</h4><p>C/C++和Java中的作用域由<code>&#123;&#125;</code>决定.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">        <span class="comment">//x &amp; q可用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅x可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是, 以下操作在Java中非法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">114514</span>; <span class="comment">//Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 尽管作者在书中如此说明,但在新版的Java中(笔者使用为JDK17), 该操作是允许的,仅仅是IDE给出一个提示.</p></blockquote><h4 id="对象作用域">对象作用域</h4><p>Java中的对象与基本类型具有不同的生命周期.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作用域终点</span></span><br><span class="line"><span class="comment">// x生命周期结束</span></span><br><span class="line"><span class="comment">// s生命周期独立作用域</span></span><br></pre></td></tr></table></figure><p>Java的内存回收不同于C++, 采用的是垃圾收集器机制,通过不可达的判断回收对象. 可以有效避免<strong>内存泄漏</strong>问题.</p><h3 id="类的创建">类的创建</h3><h4 id="类型">类型</h4><p>Java中使用<code>class</code>关键字描述新对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br></pre></td></tr></table></figure><h4 id="字段field">字段(Field)</h4><p>字段可以是基本类型或引用类型.</p><p>与C++中对应则是<strong>成员变量</strong>.</p><h4 id="基本类型默认值">基本类型默认值</h4><p>默认值仅在Java初始化类时使用.</p><ul><li><p>基本类型会被赋值为<code>0</code>(<code>boolean</code>为<code>false</code>).</p></li><li><p>但局部变量不会被赋默认值, 如果不显式指定初始化,编译器会报错.</p></li></ul><h4 id="方法使用">方法使用</h4><p>对应C++中的成员函数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">return</span> type] [method name](<span class="comment">/*args list*/</span>)&#123;</span><br><span class="line">    <span class="comment">//method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回类型">返回类型</h4><ul><li><strong>方法签名(Signature of the Method)</strong> 是方法的唯一标识,包括方法名和参数列表.(<strong>返回类型不是方法签名的一部分</strong>)</li></ul><h4 id="参数列表">参数列表</h4><p>Java中参数也是通过对象的形式传递, 也就是说,传递的是对象引用(不包括基本类型).</p><h3 id="程序编写">程序编写</h3><h4 id="命名可见性">命名可见性</h4><ul><li><p>C++通过<strong>命名空间(namespace)</strong>解决命名冲突.</p></li><li><p>Java为一个类库生成一个明确的名称来解决冲突.使用反向URL关联命名空间和文件路径会导致源代码管理出现混乱,比如说空目录问题(用于表示反向URL).</p></li></ul><h4 id="import">import</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><h4 id="static">static</h4><p>在类中的使用与C++基本一致.</p><ul><li>有时Java使用<strong>类数据(class data)</strong>和<strong>类方法(class method)</strong> 来表示静态成员.</li></ul><h3 id="编码风格">编码风格</h3><p><strong>Java编程语言编码规范(Code Conventions for the JavaProgramming Language).</strong> 采用驼峰命名法. 其中类首字母大写,字段和方法首字母小写. 对于常量, 可采用全大写 + 下划线的命名方式.</p><h2 id="chapter4-运算符">Chapter4 运算符</h2><blockquote><p><strong>运算符操纵数据.</strong></p></blockquote><h3 id="beginning">Beginning</h3><ul><li><p>运算符接受一个或多个参数并生成新值.</p></li><li><p><strong>副作用(Side Effect):</strong>运算符可改变运算对象的值.</p></li></ul><h3 id="优先级关联性">优先级&amp;关联性</h3><img src="/2024/11/03/BookNote-OnJava8-by-BruceEckel-2/pic2-1.png" class="" title="pic2-1"><blockquote><p><strong>Tips:</strong> 节选自<ahref="https://www.runoob.com/java/java-operators.html"><strong>[菜鸟教程|Java运算符]</strong></a></p></blockquote><h3 id="赋值">赋值</h3><ul><li><p><code>=</code>表示, 将右边的值赋给左边的变量.</p></li><li><p>基本类型的赋值是<strong>值传递</strong>.</p></li><li><p>对象的赋值是<strong>引用传递</strong>.</p><blockquote><p><strong>Tips:</strong> 实际上引用传递也是值传递,只是这里传递的是<strong>内存地址</strong>.</p></blockquote></li></ul><blockquote><p><strong>Additional:</strong> <ahref="https://www.zhihu.com/question/31203609?sort=created"><strong>[知乎|Java到底是值传递还是引用传递？]</strong></a></p></blockquote><h3 id="算术运算符">算术运算符</h3><ul><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,<code>%</code></li></ul><h3 id="自增自减">自增&amp;自减</h3><ul><li><code>++</code>, <code>--</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b == a++; <span class="comment">//先传值后自增, b = 1</span></span><br><span class="line">c == ++a; <span class="comment">//先自增后传值, c = 3</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符">关系运算符</h3><ul><li><p><code>&gt;</code>, <code>&lt;</code>, <code>==</code>,<code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code></p></li><li><p>接受两个操作数,返回一个<code>boolean</code>值表示操作数之间的关系.</p></li></ul><p>尽管<code>==</code>和<code>!=</code>可以比较对象,但更推荐的方法是使用<code>equals()</code>, 需要注意的是,自定义类型使用<code>equals()</code>需要手动<strong>覆写(Override)</strong>.</p><h3 id="逻辑运算符">逻辑运算符</h3><ul><li><p><code>&amp;&amp;</code>, <code>||</code>, <code>!</code></p></li><li><p>根据参数逻辑关系生成布尔值<code>true</code>,<code>false</code>.</p></li></ul><h4 id="短路">短路</h4><p>当逻辑运算符运算结果确定时,便会发生<strong>短路(short-circuiting)</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShortCircuit</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    test() &amp;&amp; test() &amp;&amp; test()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行结果只会得到一条<code>test</code>而非三条,<code>&amp;&amp;</code>在运算时发生了短路.</p><h3 id="字面值常量literal">字面值常量(Literal)</h3><p>可以指定字面值来确定常量的类型.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0x2f</span>; <span class="comment">//16进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">0177</span>; <span class="comment">//8进制</span></span><br><span class="line"><span class="type">long</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">200L</span>; <span class="comment">//long型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1f</span>; <span class="comment">//float</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1d</span>; <span class="comment">//double</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)<span class="number">0b00110101</span>; <span class="comment">//2进制</span></span><br></pre></td></tr></table></figure><h3 id="位运算符">位运算符</h3><ul><li><code>&amp;</code>, <code>|</code>, <code>~</code>(取反),<code>^</code>(异或),<code>&lt;&lt;</code>, <code>&gt;&gt;</code>,<code>&gt;&gt;&gt;</code>(按位右移补零)</li></ul><h3 id="三目运算符">三目运算符</h3><ul><li><code>?:</code> -&gt;<code>variable x = (expression) ? value if true : value if false</code></li></ul><h2 id="chapter5-控制流">Chapter5 控制流</h2><blockquote><p><strong>程序必须在执行过程中控制它的世界并作出选择. 在Java中,程序员需要执行控制语句来做出选择.</strong></p></blockquote><p>Java支持的关键字包括<code>if-else</code>, <code>while</code>,<code>do-while</code>, <code>for</code>, <code>return</code>,<code>break</code>, <code>switch</code>.</p><p>需要注意的是,所有条件语句的Expression应当是<code>boolean</code>类型.</p><h3 id="if-else">if-else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许省略else</span></span><br><span class="line"><span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最常见的形式</span></span><br><span class="line"><span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//允许嵌套</span></span><br><span class="line"><span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-while-do-while">for while do-while</h3><ul><li>循环语句又称迭代语句.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">while</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//do-while</span></span><br><span class="line"><span class="comment">//do-while中do的内容无论while判断是否成立都会被至少执行一次.</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;<span class="keyword">while</span>(Boolean-Expression)</span><br><span class="line"><span class="comment">//for</span></span><br><span class="line"><span class="keyword">for</span>(Initialization; Boolean-Expression; step)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for允许逗号操作符, 使用示例如下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++, j += i)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for-in/for-each</span></span><br><span class="line"><span class="keyword">for</span>(Type x: Contianer)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : range(<span class="number">10</span>))&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line">Container.forEach(</span><br><span class="line">(Var1, Var2, ...) -&gt; &#123;statement&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="return">return</h3><ul><li>退出当前方法, 返回方法返回值.</li></ul><h3 id="breakcontinue">break&amp;continue</h3><ul><li><p><code>break</code>与<code>continue</code>均用在循环体中.</p></li><li><p><code>break</code>表示跳出当前循环;<code>continue</code>表示停止本次循环, 进行下一次循环.</p></li></ul><h4 id="标签">标签</h4><ul><li>源于<code>goto</code>机制, 在Java中,允许为循环体定义<strong>label</strong>,并允许<code>break</code>和<code>continue</code>使用<strong>label</strong>.</li></ul><p>具体规则如下:</p><ul><li><p><code>continue</code>会回退到最内层循环开头, 并继续执行.</p></li><li><p><code>continue label</code>会到达标签位置,并重新进入紧接着那个标签后的循环.</p></li><li><p><code>break</code>会中断当前循环, 并移离当前标签末尾.</p></li><li><p><code>break label</code>会中断当前循环,并移离由那个标签指示的循环末尾.</p></li></ul><p>我们来看两个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            innerLoop:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> outerLoop; <span class="comment">// 跳出外部循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i: &quot;</span> + i + <span class="string">&quot;, j: &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            innerLoop:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> outerLoop; <span class="comment">// 跳过外部循环的当前迭代</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i: &quot;</span> + i + <span class="string">&quot;, j: &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br></pre></td></tr></table></figure><h3 id="switch">switch</h3><p>其基本格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector OR string-selector)&#123;</span><br><span class="line">  <span class="keyword">case</span> int1/string1: statement; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> int2/string2: statement; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> int3/string3: statement; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>switch</code>体中, <code>default</code>可以省略.如果缺少<code>break</code>, <code>switch</code>将会发生穿透.示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span>(x)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 1&quot;</span>).</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 2&quot;</span>).</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 3&quot;</span>).</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 4&quot;</span>).</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>).</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case 2</span><br><span class="line">case 3</span><br><span class="line">case 4</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Java语言假设程序员只进行面向对象编程,
因此Java中(几乎)万物皆对象.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记-OnJava8" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-OnJava8/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://la-pluma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A3-DeadCode Detection</title>
    <link href="http://la-pluma.github.io/2024/11/02/SPA-A3/"/>
    <id>http://la-pluma.github.io/2024/11/02/SPA-A3/</id>
    <published>2024-11-02T14:45:04.000Z</published>
    <updated>2024-11-07T09:59:28.527Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-3 Dead-CodeDetection.</strong></p><span id="more"></span><p>2024.11.7已更新</p><h2 id="实验信息食用指南">实验信息&amp;食用指南</h2><p>见本博客A1 &amp; A2</p><p><strong>Tips:</strong> 实验指南和框架代码仍然是最一手最正确的资料,对于实验指南中已涉及的信息, 本记录不会过多赘述.</p><h2 id="实验目标">实验目标</h2><p>基于<strong>Tai-e</strong> 框架实现一个 <strong>死代码检测</strong>算法.</p><h2 id="实验简析">实验简析</h2><p>实验指南没有给出实现的框架,因此至此已有完成本次知识的全部基础知识(活跃变量分析 &amp;常量传播算法).</p><p>故本次实验主要考察对A1, A2的实验理解,有遗忘或有不清楚的读者还望移步至官方教学视频复习后再完成本次实验.</p><ul><li><p>死代码检测是一个<strong>Must Analysis</strong> ,允许漏报而不允许错报.</p></li><li><p>由分支不可达的特性, 采用<strong>Forward Analysis</strong>比较符合死代码检测的特性.</p></li><li><p>为了走一遍<strong>CFG</strong> 便得到结果,我们可以将全部<code>Stmt</code>加入<code>DeadCodeSet</code>中,将不是死代码的<code>Stmt</code>删去. 留下的便是死代码.</p></li><li><p>此处笔者采用<strong>BFS</strong>算法进行<strong>CFG</strong>遍历,使用<code>Set Traveled</code>避免环路影响.</p></li></ul><h3 id="伪代码框架">伪代码框架</h3><p>死代码检测的大致框架伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">liveVarsResult &lt;- LiveVarsAnalysis(IR)</span><br><span class="line">constantResult &lt;- ConstantAnalysis(IR)</span><br><span class="line">DeadcodeSet &lt;- all stmt in IR</span><br><span class="line">TraveledSet &lt;- empty</span><br><span class="line">BFSlist &lt;- entry</span><br><span class="line"><span class="title function_">while</span><span class="params">(BFSlist is not empty)</span>&#123;</span><br><span class="line">    pickup a stmt from BFSlist</span><br><span class="line">    TraveledSet &lt;- stmt</span><br><span class="line">    <span class="comment">//handle jump Stmt</span></span><br><span class="line">    <span class="keyword">if</span> (stmt is <span class="keyword">if</span> or <span class="keyword">switch</span>)&#123;</span><br><span class="line">        DeadcodeSet remove stmt</span><br><span class="line">        <span class="comment">// ConditionExp is Constant may cause Unreachable DeadCode</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">if</span>/<span class="keyword">switch</span> ConditionExp is Constant by ConstantResult)&#123;</span><br><span class="line">            BFSlist &lt;- Target Stmt of Constant ConditionExp Path</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            BFS &lt;- succ of stmt not in Travaled</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//handle Assign Deadcode</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stmt is AssignStmt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stmt is not DeadAssign by LiveVarsResult || stmt has SideEffect)&#123;</span><br><span class="line">            DeadcodeSet remove stmt</span><br><span class="line">        &#125;</span><br><span class="line">        BFSlist &lt;- succ of stmt not in Travaled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//normal Stmt</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        DeadCodeSet remove stmt</span><br><span class="line">        BFSlist &lt;- succ of stmt not in Travaled</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p><strong><em>更新:</em></strong></p><blockquote><p><strong>Compare:</strong> <code>ir.getStmts()</code> &amp;<code>cfg.getNodes()</code></p><p>笔者一开始未意识到这个问题, <strong>IR</strong>中是不包含<code>Entry</code>和<code>Exit</code>的. 换句话说,<code>Entry</code>和<code>Exit</code>是由<strong>CFG</strong> 生成的.因此, 在初始化时,需要使用<code>ir.getStmts()</code>而不是<code>cfg.getNodes()</code>,否则在面对<strong>Infinity Loop</strong> 时,<code>Exit</code>节点会错误的被当作<code>Dead Code</code>.</p></blockquote><hr /><h2 id="cfg生成细节">CFG生成细节</h2><p>完成本实验最重要的部分莫过于<strong>CFG</strong> 的结构,实验指南没有为我们提供所有的实现细节,而且<code>CFGBuilder</code>部分的代码对我们来说是不公开的.那我们该如何获取关于<strong>CFG</strong> 的细节?</p><h3 id="框架代码提供的接口">框架代码提供的接口</h3><p>好在<strong>tai-e</strong>框架为我们提供了<code>Class Assignment</code>来<ahref="https://tai-e.pascal-lab.net/intro/selfmade-testcases.html"><strong>分析自测样例</strong></a>,输出<code>*.dot</code>文件到<code>./output/</code>目录下, 可以使用<ahref="https://graphviz.org/download/"><strong>[Graphviz]</strong></a>可视化<code>*.dot</code>文件.使用细节见上述链接中的官方文档.</p><p>笔者所使用的<strong>IDE</strong> 为<strong>JetBrian IDEA 2023.1.4Community</strong>版本, <code>Class Assignment</code>运行配置如下.</p><img src="/2024/11/02/SPA-A3/pic1.png" class="" title="pic1"><p>在终端中进入工作目录(此处为<code>output/</code>)执行以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dot -Tpng ClassMethod.dot -o ClassMethod.png</span></span><br></pre></td></tr></table></figure><p>然后我们就可以得到<code>*.dot</code>文件的可视化<strong>CFG</strong>结果.</p><h3id="根据自测样例推测cfg的生成逻辑">根据自测样例推测CFG的生成逻辑</h3><p>经过前两次的实验, 普通节点和跳转的关联顺序在<strong>CFG</strong>中是简单的,<code>for</code>和<code>while</code>的循环结构在<strong>tai-e</strong>中转化为简单的<code>goto stmt</code>.因此此处笔者着重说明<code>If</code>和<code>Switch</code>在<strong>Tai-e</strong>框架中的处理方式.</p><h4 id="控制流不可达代码">控制流不可达代码</h4><p>源代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControlFlowUnreachable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">        dead(); <span class="comment">// unreachable</span></span><br><span class="line">        x = <span class="number">3</span>; <span class="comment">// unreachable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dead</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码对应IR如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;ControlFlowUnreachable: <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] <span class="keyword">return</span> x;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] invokestatic &lt;ControlFlowUnreachable: <span class="keyword">void</span> <span class="title function_">dead</span><span class="params">()</span>&gt;();</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>CFG</strong> 可视结果如下:</p><img src="/2024/11/02/SPA-A3/pic2.png" class="" title="pic2"><blockquote><p>不难发现,控制流不可达代码在可视化图中的表示是独立于<strong>Entry</strong>到<strong>Exit</strong>路径的子图</p></blockquote><h4 id="if-stmt">If Stmt</h4><p>我们先来看看最基础的情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableIfBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            z = <span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            z = <span class="number">200</span>; <span class="comment">// unreachable branch</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;UnreachableIfBranch: <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">10</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] y = <span class="number">1</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L7</span>] <span class="keyword">if</span> (x &gt; y) <span class="keyword">goto</span> <span class="number">4</span>;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">7</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] z = <span class="number">100</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">9</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L10</span>] z = <span class="number">200</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L12</span>] <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure><img src="/2024/11/02/SPA-A3/pic3.png" class="" title="pic3"><blockquote><p>可以从可视化<strong>CFG</strong> 中获取不少信息.</p><ul><li><code>[line]:if(ConditionExp) goto [line]</code>是<code>if stmt</code>结构的入口(图中为<code>2: if(x &gt; y) goto 4</code>),<strong>tai-e</strong>框架会为<code>if stmt</code>结构提供一个统一的<code>nop</code>出口(图中为<code>9: nop</code>).</li><li><code>if</code>结构会根据<code>ConditionExp</code>的<strong>T/F</strong>取值生成<code>Edge</code>,分为<code>IF_FALSE</code>和<code>IF_TRUE</code>,<code>Edge Target</code>分别为<strong>T/F</strong> 的代码块.可以观测到框架会为<strong>T/F</strong>的代码块添加一个<code>nop stmt</code>作为代码块的起始(图中为<code>4: nop</code>和<code>7: nop</code>).</li></ul></blockquote><hr /><p>如果我们不显式指定<code>else</code>结构:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableIfBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            z = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;UnreachableIfBranch: <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">10</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] y = <span class="number">1</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L7</span>] <span class="keyword">if</span> (x &gt; y) <span class="keyword">goto</span> <span class="number">4</span>;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">6</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] z = <span class="number">100</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L8</span>] nop;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L13</span>] <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure><img src="/2024/11/02/SPA-A3/pic4.png" class="" title="pic4"><blockquote><ul><li>可以看到<code>if</code>结构的<code>IF_FALSE</code>对应的代码块消失,<code>IF_FALSE</code>直接跳转到<code>if</code>结构的结束<code>nop</code>语句.(图中为<code>6: nop</code>)</li></ul><blockquote><p><strong>Tips:</strong></p><p>如果显式写出<code>else</code>但<code>else</code>为空体,<strong>tai-e</strong>框架会生成一条<code>nop</code>语句对应该<code>else</code>空体,感兴趣的读者可以自行测试, 笔者在此不再赘述.</p><p>通过阅读框架代码中的<code>Class If extends JumpStmt</code>和<code>Class JumpStmt</code>可以知晓,<code>If</code>将<code>JumpStmt</code>的成员变量<code>target</code>和对应方法(如<code>getTarget()</code>)和<code>If</code>结构中的<code>IF_TRUE</code>对应起来,因此此时的<code>Edge IF_FALSE</code>其实等价于<code>FALL_THROUGH</code>,<code>IF_FALSE</code>的<code>target</code>是一条指向真正<strong>False代码块</strong>的<code>goto stmt</code>.通过阅读框架代码, 便不难理解为何<strong>CFG</strong>要这样处理<code>IF</code>结构.</p></blockquote></blockquote><hr /><p><code>if-else</code>的嵌套等价于普通的<code>if-else</code>的组合.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableIfBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            z = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; y) &#123;</span><br><span class="line">            z = <span class="number">200</span>; <span class="comment">// unreachable branch</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            z = <span class="number">300</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;UnreachableIfBranch: <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">10</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] y = <span class="number">1</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L7</span>] <span class="keyword">if</span> (x &gt; y) <span class="keyword">goto</span> <span class="number">4</span>;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">7</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] z = <span class="number">100</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">16</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L10</span>] <span class="keyword">if</span> (x &lt; y) <span class="keyword">goto</span> <span class="number">10</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">13</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L11</span>] z = <span class="number">200</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">15</span>;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L14</span>] z = <span class="number">300</span>;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L14</span>] nop;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L14</span>] nop;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L16</span>] <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure><img src="/2024/11/02/SPA-A3/pic5.png" class="" title="pic5"><h4 id="switch-stmt">Switch Stmt</h4><p>与<code>If</code>一样, 我们先来看看一般情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableSwitchBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                z = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                z = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                z = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                z = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;UnreachableSwitchBranch: <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] %intconst0 = <span class="number">3</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L5</span>] y = x &lt;&lt; %intconst0;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L9</span>] z = <span class="number">2</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L12</span>] z = <span class="number">4</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L13</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L13</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L15</span>] z = <span class="number">8</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L16</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L16</span>] nop;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L18</span>] z = <span class="number">0</span>;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L19</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">18</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">19</span><span class="meta">@L7</span>] lookupswitch (y) &#123;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">4</span>-&gt;<span class="number">7</span>, <span class="number">8</span>-&gt;<span class="number">10</span>, <span class="keyword">default</span>-&gt;<span class="number">13</span>&#125;;</span><br><span class="line">[<span class="number">20</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">21</span><span class="meta">@L7</span>] <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><img src="/2024/11/02/SPA-A3/pic6.png" class="" title="pic6"><blockquote><ul><li>与<code>If</code>一致,<code>[line]: [method]switch([var]) &#123;[branch]&#125;</code>是<code>Switch</code>结构的起点(图中为<code>19: lookupswitch(y) &#123;2-&gt;4, 4-&gt;7, 8-&gt;10, default-&gt;13&#125;</code>).同样会生成一条<code>nop stmt</code>表示<code>Switch</code>结构的出口.</li><li>经过笔者的多次测试,<strong>tai-e</strong>框架的<code>Switch</code>语句处理有些的微妙的奇怪之处.与<code>If</code>不同,<code>Switch</code>语句的入口在<code>line num</code>上位于<code>Switch</code>结构的最后部分,到达该入口需要经过两条<code>nop stmt</code>,并且会在<code>CASE</code>和<code>DEFAULT</code>代码块之外添加一个到<code>Switch</code>结构出口的<code>goto stmt</code>.然而由于<code>DEFAULT</code>一定存在(下文会解释),因此这条<code>goto</code>语句一定为死代码,不存在一条从<code>Entry</code>到该语句的路径.</li></ul><blockquote><p><strong>Tips:</strong> 笔者认为这是一个非常奇怪的处理,猜测可能跟Soot生成的字节码有关(<strong>Tai-e</strong>框架基于Soot搭建)<strong>该猜想未证实</strong>.</p></blockquote><ul><li>笔者推测<code>CASE</code>和<code>DEFAULT</code>代码块中的第一条<code>nop</code>语句来源是<code>case 2:</code>和<code>default:</code>,即<strong>Tai-e</strong>框架选择保留了原来的控制信息语句(控制信息在<strong>CFG</strong>中体现为<code>Edge</code>),但将其替换成了<code>nop</code>语句(该推测在不显示指定<code>default</code>时得到部分证实).</li></ul></blockquote><hr /><p>不显式指定<code>default</code>时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableSwitchBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                z = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                z = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                z = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;UnreachableSwitchBranch: <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] %intconst0 = <span class="number">3</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L5</span>] y = x &lt;&lt; %intconst0;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">14</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L9</span>] z = <span class="number">2</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L12</span>] z = <span class="number">4</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L13</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L13</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L15</span>] z = <span class="number">8</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L16</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L7</span>] lookupswitch (y) &#123;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">4</span>-&gt;<span class="number">7</span>, <span class="number">8</span>-&gt;<span class="number">10</span>, <span class="keyword">default</span>-&gt;<span class="number">17</span>&#125;;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">18</span><span class="meta">@L7</span>] <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><img src="/2024/11/02/SPA-A3/pic7.png" class="" title="pic7"><blockquote><ul><li>可以观测到<strong>CFG</strong>会添加未被显式写出的<code>default</code>,但不生成<code>default</code>指向的代码块(如果显示写出<code>default</code>但为空体,会保留<code>nop</code>和<code>goto</code>跳转, 笔者在此不再赘述,感兴趣的读者可以自行测试),而是直接指向<code>Switch</code>结构的出口.</li></ul></blockquote><h4 id="case-break">case &amp; break</h4><p>了解java语法性质的读者应该理解笔者在本小结的标题.</p><p>我们来看看如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 1&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 2&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与预期不同, 这段代码的输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java Main</span></span><br><span class="line">Selected 2</span><br><span class="line">Selected 3</span><br><span class="line">Selected other</span><br></pre></td></tr></table></figure><p>当<code>switch</code>匹配2成功时, 如果不加<code>break</code>,会顺次匹配在<code>case 2:</code>之后的所有<code>case</code>.这称为<code>case</code>的<strong>穿透性</strong>.</p><hr /><p>我们来看看<strong>CFG</strong>是如何处理这种情况的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableSwitchBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                z = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// unreachable case</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                z = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// unreachable case</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                z = <span class="number">8</span>;</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                z = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// unreachable case</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;UnreachableSwitchBranch: <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] %intconst0 = <span class="number">3</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L5</span>] y = x &lt;&lt; %intconst0;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">16</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L9</span>] z = <span class="number">2</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L12</span>] z = <span class="number">4</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L13</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L13</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L15</span>] z = <span class="number">8</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L15</span>] nop;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L18</span>] z = <span class="number">0</span>;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L19</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">18</span><span class="meta">@L7</span>] lookupswitch (y) &#123;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">4</span>-&gt;<span class="number">7</span>, <span class="number">8</span>-&gt;<span class="number">10</span>, <span class="keyword">default</span>-&gt;<span class="number">12</span>&#125;;</span><br><span class="line">[<span class="number">19</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">20</span><span class="meta">@L7</span>] <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><img src="/2024/11/02/SPA-A3/pic8.png" class="" title="pic8"><blockquote><ul><li>这是一个符合预期的处理, 也是一个非常自然而然的想法.</li></ul></blockquote><h2 id="deadcodedetection">DeadCodeDetection</h2><p>本次实验只需要完成<code>Class DeadCodeDetection</code>中的<code>analysis()</code>方法.</p><h3 id="准备工作">准备工作</h3><p>将A1,A2中完成的<strong>活跃变量分析</strong>和<strong>常量传播</strong>代码copy到本次实验A3的工作目录中.需要注意的是,本次活跃变量分析部分不使用<code>IteratorSovler</code>而是使用<code>BackwardWorklist</code>,此部分代码需要额外完成.</p><blockquote><p><strong>Tips:</strong>不要过多的依赖诸如<strong>ChatGPT</strong>或<strong>Copilot</strong>的书写代码功能,其生成的代码很可能存在潜在的不易发现的bug(<del>你猜我为什么会加这个Tips</del>).实际上, <code>JetBrain IDEA</code>的成员变量和方法补全功能已经足够好使,使用<strong>Copilot</strong>的代码补全反而可能造成一些不必要的麻烦.</p></blockquote><h3 id="控制流不可达代码实现细节">控制流不可达代码实现细节</h3><p>实验指南已写明该部分的具体原理, 此处涉及一些实现细节.</p><ul><li>通过恰当的维护<code>BFSlist</code>可以仅遍历可达代码(主要处理<code>If</code>和<code>Switch</code>),因此初始化所有的<code>Stmt</code>为<code>DeadCode</code>,遍历到即排除其为死代码是一个不错的选择.</li><li>无论使用<strong>BFS</strong>还是<strong>DFS</strong>,都要处理环路引起的<strong>Infinity Loop</strong>,一个简单的方法是创建一个<code>Traveled Set</code>保证每个<code>Stmt</code>仅会被遍历到一次(同样的,对于<code>BFSList</code>维护也可以通过类似的技巧提升效率).</li><li>遍历一次就能得到结果依托于<strong>不需要处理由删除死代码产生的死代码</strong>(例子可见实验指南).</li><li>关于图的遍历方式,笔者在此推荐使用<code>CFG</code>的顶层方法<code>getSuccOf()</code>和<code>getOutEdge()</code>,而不是<code>If Stmt</code>和<code>Switch Stmt</code>中的方法.这两个跳转语句的实现因为继承自<code>JumpStmt</code>所以细节上可能与想象中有所差异,如果一定要使用,还请小心谨慎的阅读<code>API</code>注释以获取详细信息.</li><li>关于<code>ConditionExp</code>的处理,可以复用A2中实现的<code>evaluate()</code>方法.</li></ul><h3 id="无用赋值代码实现细节">无用赋值代码实现细节</h3><p>同上, 原理部分请参见实验指南.</p><ul><li>继承<code>AssignStmt</code>的子类有足足十几个,可以从lib反编译或者科研版代码中获取相关细节, 关于<strong>副作用(SideEffect)</strong>在框架代码中已给出<code>API</code>,解释了哪些派生类可能引起副作用.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true if given RValue has no side effect, otherwise false.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasNoSideEffect</span><span class="params">(RValue rvalue)</span> &#123;</span><br><span class="line">    <span class="comment">// new expression modifies the heap</span></span><br><span class="line">    <span class="keyword">if</span> (rvalue <span class="keyword">instanceof</span> NewExp ||</span><br><span class="line">            <span class="comment">// cast may trigger ClassCastException</span></span><br><span class="line">            rvalue <span class="keyword">instanceof</span> CastExp ||</span><br><span class="line">            <span class="comment">// static field access may trigger class initialization</span></span><br><span class="line">            <span class="comment">// instance field access may trigger NPE</span></span><br><span class="line">            rvalue <span class="keyword">instanceof</span> FieldAccess ||</span><br><span class="line">            <span class="comment">// array access may trigger NPE(None Pointer Exception)</span></span><br><span class="line">            rvalue <span class="keyword">instanceof</span> ArrayAccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rvalue <span class="keyword">instanceof</span> ArithmeticExp) &#123;</span><br><span class="line">        ArithmeticExp.<span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> ((ArithmeticExp) rvalue).getOperator();</span><br><span class="line">        <span class="comment">// may trigger DivideByZeroException</span></span><br><span class="line">        <span class="keyword">return</span> op != ArithmeticExp.Op.DIV &amp;&amp; op != ArithmeticExp.Op.REM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>小心, 不要忘记判断<code>lValue</code>是否为<code>Var</code>,与之前相同, 我们只需要处理<code>Var</code>类型的语句.</li></ul><h2 id="总结">总结</h2><p>本次实验难度某种意义上低于A1, 是一个比较简单的实验,旨在考察对分析结果的应用能力. 祝早日AC!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-3 Dead-Code
Detection.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-On Java8 Ch0-Ch2</title>
    <link href="http://la-pluma.github.io/2024/10/30/BookNote-OnJava8-by-BruceEckel-1/"/>
    <id>http://la-pluma.github.io/2024/10/30/BookNote-OnJava8-by-BruceEckel-1/</id>
    <published>2024-10-30T11:49:40.000Z</published>
    <updated>2024-10-31T14:56:03.323Z</updated>
    
    <content type="html"><![CDATA[<p><strong>你所使用的编程语言会将你的思维模式固化并逐渐远离其他语言,而且往往发生在潜移默化中. Java作为一门傲娇的语言尤其如此. —— BruceEckel</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter0-简介前言">Chapter0 简介&amp;前言</a></li><li><a href="#chapter1-对象的概念">Chapter1 对象的概念</a><ul><li><a href="#抽象">抽象</a><ul><li><ahref="#所有编程语言都提供抽象机制">所有编程语言都提供抽象机制</a></li><li><a href="#纯粹oop五大基本特征alan-kay">"纯粹"OOP五大基本特征(AlanKay)</a></li><li><a href="#grady-booch对对象的描述">Grady Booch对对象的描述</a></li></ul></li><li><a href="#接口">接口</a></li><li><a href="#服务提供">服务提供</a></li><li><a href="#封装">封装</a><ul><li><a href="#使用访问控制的原因">使用访问控制的原因</a></li><li><a href="#java访问控制关键字">Java访问控制关键字</a></li></ul></li><li><a href="#复用">复用</a><ul><li><a href="#关联关系">关联关系</a></li></ul></li><li><a href="#继承">继承</a><ul><li><a href="#区分基类与派生类">区分基类与派生类</a></li><li><a href="#is-a-与-is-like-a">is-a 与 is-like-a</a></li></ul></li><li><a href="#多态">多态</a></li><li><a href="#单继承结构">单继承结构</a></li><li><a href="#容器">容器</a><ul><li><a href="#泛型">泛型</a></li></ul></li><li><a href="#对象创建与生命周期">对象创建与生命周期</a></li><li><a href="#异常处理">异常处理</a></li></ul></li><li><a href="#chapter2-安装java和本书用例">Chapter2安装Java和本书用例</a></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>Bruce Eckel "最新"力作<em>On Java 8</em>, 笔者因为课程需要遂阅读本书.可以从<ahref="https://github.com/Knn120/OnJava8-PDF"><strong>此处</strong></a>获取电子书文件.</p><p>需要注意的是, 阅读本书需要一定的编程基础.</p><h2 id="chapter0-简介前言">Chapter0 简介&amp;前言</h2><blockquote><p><strong>语言决定世界观. ——路德维希·维特根斯坦(Wittgenstein)</strong></p></blockquote><ul><li><p>Java的最核心变化: <strong>虚拟机</strong> 和<strong>垃圾回收机制</strong></p></li><li><p>编程的过程就是复杂性管理的过程: 业务问题的复杂性,以及依赖的计算机的复杂性.</p></li></ul><p><em>Thing in C</em> 可以在官方地址<ahref="www.OnJava8.com">www.OnJava8.com</a>免费下载.</p><p>示例代码可以通过官方地址<ahref="https://github.com/BruceEckel/OnJava8-examples">https://github.com/BruceEckel/OnJava8-examples</a>中下载.</p><h2 id="chapter1-对象的概念">Chapter1 对象的概念</h2><blockquote><p><strong>我们没有意识到惯用语言的结构有多大力量. 可以毫不夸张地说,它通过语义反应机制奴役我们.语言表现出来并在无意识中给我们留下深刻印象的结构会自动投射到我们周围的世界.—— Alfred Korzybski(1930)</strong></p></blockquote><ul><li>面向对象编程(Object-Oriented Programming,OOP)是一种编程思维方式和编码架构.</li></ul><h3 id="抽象">抽象</h3><h4 id="所有编程语言都提供抽象机制">所有编程语言都提供抽象机制</h4><p>某种程度上, 问题的复杂度直接取决于抽象的类型和质量.</p><ul><li><p>汇编语言是对底层机器的轻微抽象.</p></li><li><p>"命令式"语言(FORTRAN, BASIC, C)是对汇编语言的抽象.</p><blockquote><p><strong>Tips:</strong>命令式语言的抽象原理依然要求程序员着重考虑计算机的结构而非问题本身的结构.</p></blockquote></li></ul><p>程序员必须要在<strong>机器模型(解决方案空间)</strong>和实际解决的<strong>问题模型(问题空间)</strong> 之间建立一种关联.这个过程既费精力, 又脱离编程语言本身的范畴.</p><ul><li><p>问题空间中的元素以及它们在解决方案空间的表示称作<strong>对象(Object)</strong>.</p></li><li><p>OOP允许程序员根据问题来描述问题,而不是根据运行解决方案的计算机.</p><blockquote><p><strong>Tips:</strong> 每个对象都类似一台小计算机,有自己的状态并且可以进行特定的操作; 与现实中的"对象"或"物体"相似,有自己的特征和行为.</p></blockquote></li></ul><h4 id="纯粹oop五大基本特征alan-kay">"纯粹"OOP五大基本特征(AlanKay)</h4><ul><li><p>万物皆对象.</p></li><li><p>程序是一组对象, 通过消息传递来告知彼此该做什么.</p></li><li><p>每个对象有自己的存储空间, 可容纳其他对象.</p></li><li><p>每个对象都有一种类型.</p></li><li><p>同一类所有对象都能接收相同信息.</p><blockquote><p><strong>Tips:</strong> 这个表述有点抽象,结合书中的解释会有所理解.</p><p>由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给“形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。</p></blockquote></li></ul><h4 id="grady-booch对对象的描述">Grady Booch对对象的描述</h4><ul><li>一个对象具有自己的状态, 行为和标识.即对象有自己的内部数据(提供状态), 方法(产生行为),并彼此区分(每个对象[笔者注:称之为实例instance或许更好理解]在内存中有唯一的地址).</li></ul><h3 id="接口">接口</h3><p>我们向对象发出的请求是通过它的<strong>接口(Interface)</strong>定义的,对象的<strong>类型</strong> 或 <strong>类</strong> 规定了接口形式.</p><p>假设我们有一个<code>Class Light</code>,其<strong>统一建模语言(Unified Modeling Language, UML)</strong>设计图如下:</p><img src="/2024/10/30/BookNote-OnJava8-by-BruceEckel-1/pic1-1.png" class="" title="pic1-1"><p>可以通过这样的方式调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Light</span> <span class="variable">lt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>()</span><br><span class="line">lt.on()</span><br></pre></td></tr></table></figure><h3 id="服务提供">服务提供</h3><p>在开发或理解程序设计时, 可以将对象看成是<strong>服务提供者</strong>.程序本身为用户提供服务, 并且能通过调用其他对象提供的服务来实现.</p><p>在开发时, 可以将分体一一分解, 抽象成一组服务,每个对象都提供了一组紧密的服务.</p><p>软件设计的基本原则是<strong>高内聚</strong>: 每个组件内部作用明确,功能紧密相关.</p><h3 id="封装">封装</h3><ul><li>编程的侧重领域可以划分为<strong>研发</strong> 和<strong>应用</strong>.应用程序员调用研发程序员构建的基础工具来做快速开发.</li></ul><h4 id="使用访问控制的原因">使用访问控制的原因</h4><ul><li><p>让应用程序员不要触摸他们不应该触摸的部分.</p></li><li><p>使类库的创建者(研发程序员)在不影响应用程序员使用的情况下完善更新工具库.</p></li></ul><h4 id="java访问控制关键字">Java访问控制关键字</h4><ul><li><p><strong>public</strong>: 任何人都可以访问和使用.</p></li><li><p><strong>private</strong>: 除了类本身和类内部方法,外界无法直接访问.</p></li><li><p><strong>protected</strong>: 允许子类访问protected成员,但不能访问private成员.</p></li><li><p><strong>default</strong>: 包访问,可以被同一包(组件库)中其他类的成员访问.</p></li></ul><h3 id="复用">复用</h3><ul><li><p>一个类经创建和测试后, 理应是可复用的.</p></li><li><p>代码和设计方案的可复用性是OOP的优点之一.</p></li></ul><h4 id="关联关系">关联关系</h4><ul><li><p><strong>组合(Composition)</strong>: 表示<strong>拥有关系(has-arelationship)</strong>.</p></li><li><p><strong>聚合(Aggregation)</strong>: 动态的组合.</p></li></ul><blockquote><p><strong>Tips: 组合与聚合</strong></p><ul><li><p>聚合关系中, 整件不会拥有部件的生命周期,多个整件可以共享同一个部件.</p></li><li><p>组合关系中, 整件拥有部件的生命周期,多个整件不可以共享同一个部件.</p></li></ul></blockquote><p>组合/聚合的设计相较继承, 更简单灵活, 设计更清晰.</p><h3 id="继承">继承</h3><ul><li><strong>基类(父类, 超类)</strong>包含派生自它的类型之间的共享特征和行为, 表示思想的核心.</li><li><strong>派生类(子类, 继承类)</strong>从基类中派生以表示核心的不同方式.</li></ul><p><strong>类的层次结构体现了class之间的相似性和差异性.</strong></p><h4 id="区分基类与派生类">区分基类与派生类</h4><ul><li><p>派生类中添加新功能.</p></li><li><p>派生类改变基类现有方法的行为,即<strong>覆盖(overriding)</strong>.</p></li></ul><h4 id="is-a-与-is-like-a">is-a 与 is-like-a</h4><ul><li><p><strong>is-a</strong>: 继承只覆盖基类的方法,不添加基类没有的方法.此时派生类和基类可以认为是<strong>同一种类型</strong>(具有完全相同的接口).称为<strong>纯粹替代</strong>.</p></li><li><p><strong>is-like-a</strong>: 派生类中添加了新的接口元素,此时基类无法访问这些新的接口元素.</p></li></ul><blockquote><p><strong>Tips:</strong> 此处笔者直接使用原书中的例子.</p><img src="/2024/10/30/BookNote-OnJava8-by-BruceEckel-1/pic1-2.png" class="" title="pic1-2"><img src="/2024/10/30/BookNote-OnJava8-by-BruceEckel-1/pic1-3.png" class="" title="pic1-3"><img src="/2024/10/30/BookNote-OnJava8-by-BruceEckel-1/pic1-4.png" class="" title="pic1-4"></blockquote><h3 id="多态">多态</h3><p>处理类的层次结构时, 通常把一个对象看成他所属的基类而不是具体类.这样可以编写出不局限于特定类型的代码.</p><blockquote><p>在此给出一个多态的例子:</p><img src="/2024/10/30/BookNote-OnJava8-by-BruceEckel-1/pic1-5.png" class="" title="pic1-5"><p><code>Birld Controller</code>在<code>Relocate()</code>时不知道也不需要知道<code>Bird</code>的具体类,也不需要知道执行的是<code>Goose move()</code>还是<code>Penguin move()</code>.</p></blockquote><ul><li><p><strong>早期绑定</strong>: 非OOP编译器产生的函数调用,其地址在程序运行前就已确定, 调用会被解析为执行代码的绝对地址.</p></li><li><p><strong>后期绑定</strong>: 被调用的代码直到运行时才确定.编译器确保方法存在, 对参数和返回值进行类型检测.</p></li></ul><p>多态的机制就是由后期绑定实现的.(在部分语言, 如C++中,必须使用<code>virtual</code>关键字显示授予方法后期绑定属性)</p><p><strong>编译器和运行时系统会负责对所有细节的控制,程序员只需要知道要做什么,以及如何利用多态性来更好地设计程序.</strong></p><h3 id="单继承结构">单继承结构</h3><p>Java中所有的类都默认继承自一个基类<code>Object</code>. 与之相对的,C++允许多继承方案.</p><h3 id="容器">容器</h3><p>通常我们不知道解决某个具体问题需要的对象数量和持续时间,以及对象的存储方式. 所以我们该如何获知程序在运行时分配的内存对象?</p><p>在OOP中, 创建一个新类型的对象来引用, 容纳其他对象.Java中通常使用<strong>容器(Collection)</strong>.</p><blockquote><p><strong>Tips</strong>: 笔者完全不知道翻译时为何要使用"集合"这个术语,很容易与 <strong>set</strong> 混淆. C++中的<strong>STL(Standard TemplateLibrary)</strong> 亦翻译为容器, 故笔者在此统一使用容器这个表述.</p></blockquote><p>使用容器的经验告诉我们, 不存在一种容器可以满足所有需求,针对具体的问题, 需要选择能解决这个问题的容器. 需要注意的是:</p><ul><li><p>容器可以提供不同类型的接口和外部行为.</p></li><li><p>不同集合对某些操作有不同的效率.</p></li></ul><h4 id="泛型">泛型</h4><p>Java5 之前的容器都只保存<code>Object</code>类型,使用容器时需要对元素做"向上转型", 取出元素时需要做"向下转型".但遗憾的是"向下转型" <strong>IS NOT SAFE</strong>.</p><p>Java5开始提供了<strong>泛型(Generic)</strong>的<strong>参数化类型机制(ParameterizedType Mechanism)</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="对象创建与生命周期">对象创建与生命周期</h3><p>对象可以放在<strong>栈(Stack, 自动变量/作用域变量)</strong> 或<strong>静态存储域(Static Storage Area)</strong> 静态确定; 也可以在<strong>堆(Heap)</strong>上动态创建.</p><p>C++中需要程序员自己处理对象的创建与回收的一整个生命周期,以此保证效率.</p><p>Java使用动态内存分配, 其内存管理建立在垃圾回收器机制上,提供了更高级别的保险, 防止了潜在的内存泄漏问题.</p><h3 id="异常处理">异常处理</h3><p>异常处理机制将程序错误直接交给编程语言甚至操作系统.</p><p><strong>异常(Exception)</strong>是一个从出错点<strong>抛出(Thrown)</strong>后能被特定类型的异常处理程序<strong>捕获(Catch)</strong> 的一个对象.</p><p>异常机制提供了一种可靠的从错误状态中恢复的方法.</p><h2 id="chapter2-安装java和本书用例">Chapter2 安装Java和本书用例</h2><p>笔者在此略去这部分内容, 有需要的读者可以查阅原书内容.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;你所使用的编程语言会将你的思维模式固化并逐渐远离其他语言,
而且往往发生在潜移默化中. Java作为一门傲娇的语言尤其如此. —— Bruce
Eckel&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记-OnJava8" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-OnJava8/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://la-pluma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A2-Constant Propagation</title>
    <link href="http://la-pluma.github.io/2024/10/28/SPA-A2/"/>
    <id>http://la-pluma.github.io/2024/10/28/SPA-A2/</id>
    <published>2024-10-28T12:59:35.000Z</published>
    <updated>2024-10-28T16:46:51.367Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-2 ConstantPropagation &amp; WorlistSolver.</strong></p><span id="more"></span><h2 id="实验信息与食用指南">实验信息与食用指南</h2><p>请翻阅<ahref="https://la-pluma.github.io/2024/10/20/SPA-A1/#more"><strong>[NJU静态分析|A1-LiveVariable Analysis]</strong></a>.</p><p>在此进行一点补充, 笔者的这份实验记录更像是FreeStyle版的<strong>FAQ</strong>. 因此请 <strong><em>确保</em></strong>在理解了<strong>理论知识</strong>, <strong>实验指南</strong> 和<strong>框架代码</strong> 后再参考本记录, 与A1相同, 本记录<strong><em>不提供</em></strong> 源代码(<del>或者说暂时没有</del>).</p><p><del>如果您对本实验记录中的内容感到困惑,可能是因为笔者能力不足或您未能理解实验指南和框架代码,同时本试验记录难以涵盖所有的坑, 还望海涵.</del></p><h2 id="实验目标">实验目标</h2><p>基于<strong>Tai-e</strong>框架实现<strong>常量传播算法</strong>和<strong>worklist求解器</strong>.</p><p>大致的框架代码如下:</p><img src="/2024/10/28/SPA-A2/pic1.png" class="" title="pic1"><p>注意常量传播算法是<strong>Forward &amp; Must analysis</strong>.</p><h2 id="部分重要框架代码带读">部分重要框架代码带读</h2><p><del>我知道你们有些人肯定是不看框架代码的,除非不得不用或者报错的时候.</del></p><h3 id="ir-irbuilder">IR &amp; IRBuilder</h3><p>Tai-e框架中的<code>IR</code>与课上教授的IR稍有不同, 以A2test中的<strong>Assign.java</strong>为例,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   From A2 test/Assign.java   */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assign</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">        x = <span class="number">4</span>;</span><br><span class="line">        y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过tai-e框架的分析后会得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> &lt;init&gt;()&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L1</span>] invokespecial %<span class="built_in">this</span>.&lt;java.lang.Object: <span class="keyword">void</span> &lt;init&gt;()&gt;(); &#123;&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L1</span>] <span class="keyword">return</span>; &#123;&#125;</span><br><span class="line"></span><br><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span>&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;   &#123;x=<span class="number">1</span>&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] x = <span class="number">2</span>;   &#123;x=<span class="number">2</span>&#125;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] x = <span class="number">3</span>;   &#123;x=<span class="number">3</span>&#125;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">4</span>;   &#123;x=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L8</span>] y = x;   &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] <span class="keyword">return</span>;  &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合<strong>IR</strong> &amp; <strong>IRBuilder</strong>(可翻阅<ahref="https://tai-e.pascal-lab.net/docs/index.html"><strong>[官方手册]</strong></a>),</p><img src="/2024/10/28/SPA-A2/pic2.png" class="" title="pic2"><p><del>IR我懒得贴了</del></p><p><code>IR</code>的基本单元是<strong>method</strong>(请意识到java是oop语言),<code>IRBuilder</code>提供了分析单个方法的API<code>buildIR(JMethod method)</code>和分析整个<code>class hierarchy</code>(不明白,等到A4就明白了, 笑)中的所有方法的API<code>buildAll()</code></p><p>结合<code>Stmt</code> <code>Exp</code> 和 <code>CFG</code>,我们可以得到这样的一个示意图(由于笔者未阅读全部的源码实现,可能会有所出入, 但大致如此).</p><img src="/2024/10/28/SPA-A2/pic3.png" class="" title="pic3"><blockquote><p><strong>Tips:</strong>严格来说<code>CFG</code>并不存储<code>Node</code>(本实验中指<code>Stmt</code>,见A1试验记录说明), 只存储<code>Stmt</code>的关联信息,但为了方便图示遂如此展示. 至于为何左值和右值都是<code>Exp</code>,请翻阅A1官方实验指南中对<code>Exp</code>的图示表示部分.</p></blockquote><h3 id="definitionstmt">DefinitionStmt</h3><p>尽管理论上不需要这个类也可以完成实验(<code>Stmt</code>中的顶层方法足以实现),但既然框架提供了这么好用的API, 方便我们写出更优雅的代码,为什么不用呢?</p><img src="/2024/10/28/SPA-A2/pic4.png" class="" title="pic4.png"><p><code>DefinitionStmt</code>为我们提供了两个非常好用的API,<code>getLValue()</code>和<code>getRValue</code>可以直接获取到左右式的<code>Exp</code>(希望你还记得<code>LValue</code>&amp;<code>RValue</code>extends <code>Exp</code>),而不需要像<code>Stmt</code>中的<code>getDef()</code> &amp;<code>getUses()</code>做较为繁琐的判断和筛选(如果对<code>getUses()</code>感到困惑,也还请翻阅A1实验记录, 里面有解释和参考来源).</p><p>需要注意的是,<code>getLValue()</code>可能会返回<code>null</code>.</p><h2 id="constantpropagation">ConstantPropagation</h2><p>与活跃变量分析类似, 我们需要完成5个API的功能.</p><h3 id="newboundaryfact-newinitialfact">newBoundaryFact() &amp;newInitialFact()</h3><p>需要注意的是, 本次存储分析结果的数据结构是<code>CPFact</code>,与A1相同, 在完成本次实验代码之前需要了解相关API的用法.</p><p>既然是<strong>Must Analysis</strong>, 我们需要将初值赋为空,但需要注意的是, 我们的<strong>Analysis</strong>仅分析语句,在进入第一条语句之前, 是否有什么东西需要初始化?</p><p>这个问题就对应了指南中为什么<code>BoundaryInit</code> 要通过<code>getIR().getParas()</code>获取参数并赋值<code>NAC</code>的提示.</p><p>在对<code>IR</code>的解释中我们提到过,<code>IR</code>的基本分析单元是<strong>method</strong>, 即函数,函数就可能有传入的参数, 这些参数易见<strong>不是Constant</strong>,因此要赋值为<code>NAC</code></p><blockquote><p><strong>Tips:</strong> 如果是Constant干嘛还要传参, 即便真的这么做了,我们的分析也可以满足<strong>safe-approximation</strong>.</p></blockquote><p>这部分是在方法体(函数语句)执行前就完成的初始化,因此我们需要赋值给<code>Entry</code>的<code>outFact</code>.</p><h3 id="meetvalue-meetinto">meetValue() &amp; meetInto()</h3><p><code>meetValue()</code>的完成没有任何难点,只需要照抄ppt中的规则即可.</p><img src="/2024/10/28/SPA-A2/pic5.png" class="" title="pic5"><p>同样的,完成这部分代码需要阅读<code>Class Value</code>的源码API和注释.</p><p>关于<code>meetInto()</code>,如果没有阅读<code>CPFact</code>中的<code>update()</code>方法注释,就不知道可以写出如此优雅的代码来合并<code>Var</code>的<code>Value</code>值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.update(<span class="keyword">var</span>, meetValue(fact.get(<span class="keyword">var</span>), target.get(<span class="keyword">var</span>)));</span><br></pre></td></tr></table></figure><img src="/2024/10/28/SPA-A2/pic6.png" class="" title="pic6"><h3 id="transfernode-evaluate">transferNode() &amp; evaluate()</h3><p>毫无疑问, 这是本次实验中最难最核心的一部分, 细节非常多, 当被卡hiddentest的时候, 大概率寄在这里.</p><p>笔者建议在<code>transferNode()</code>中处理<code>Stmt</code>的左值def部分,在<code>evaluate()</code>中处理右值exp部分. 这是比较符合功能分离的写法,当然, 也可以选择在<code>transferNode()</code>中处理<code>Var</code>和<code>IntLiteral</code>,<code>evaluate()</code>只负责处理<code>BinaryExp</code>的计算值.笔者在此按第一种写法进行说明.</p><h4 id="transfernode">transferNode()</h4><p>这个函数中你需要依次做(次流程可能存在可以优化的部分,不必完全照做):</p><ul><li><p>保存<code>outFact</code>原值,将<code>inFact</code>赋值给<code>outFact</code>.</p></li><li><p>判断<code>Node</code>(<code>Stmt</code>)是否为<code>DefinitionStmt</code></p></li><li><p>判断是否拥有<strong>合法</strong>左值,包括<code>def</code>的类型<code>Var</code>和<code>Var</code>中的<code>ValueType</code>是否为<code>Int</code>,如果不是, 本次实验中可以认为是<code>nop</code>空操作.不需要为这个<code>Stmt</code>做任何分析, 直接将<code>inFact</code>copy给 <code>outFact</code>即可.</p><blockquote><p><strong>Tips:</strong> IDEA教给我一个很有意思的语法糖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> DefinitionStmt def_stmt)&#123;</span><br><span class="line">    <span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> def_stmt.getLValue();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用法可以避开繁琐的类型转化, 在判断类型时便做了类型转化.</p></blockquote></li><li><p>计算<code>Stmt</code>的右值(通过<code>evaluate()</code>获得),并更新<code>outFact</code>中的相应<code>Var def</code>(笔者在此并未使用<code>update</code>方法的返回值,或许可从此处入手优化效率, 但笔者不能保证其正确性)</p></li><li><p>比较<code>outFact</code>是否更新返回布尔值.</p></li></ul><h4 id="evaluate">evaluate()</h4><p>为了完成这个方法, 代码的大致框架应该是这个样子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Value <span class="title function_">evaluate</span><span class="params">(Exp exp, CPFact in)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> Var)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*Value*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> IntLiteral)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*Value*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> BinaryExp binary_exp)&#123;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">right</span> <span class="operator">=</span> ...;</span><br><span class="line">        <span class="comment">// Operand may not Int or may not Constant</span></span><br><span class="line">        <span class="comment">// you&#x27;d better do it first</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*left HoldInt &amp;&amp; right HoldInt*/</span>)&#123;</span><br><span class="line">            <span class="comment">//you can get Condition Info form ppt</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*left is Constant &amp;&amp; right is constant*/</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (binary_exp <span class="keyword">instanceof</span> ArithmeticExp arithmetic_exp)&#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="comment">//also should attention to DIV 0 return Undef</span></span><br><span class="line">                        <span class="keyword">case</span> ADD: ...</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binary_exp <span class="keyword">instanceof</span> BitwiseExp bitwise_exp)&#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="keyword">case</span> AND: ...</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(...)</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*left is NAC || right is NAC*/</span>)&#123;</span><br><span class="line">                <span class="comment">//you should do DIV &amp; REM for 0 judgement there</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*other condition*/</span>)&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*other condition*/</span>)&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for over-approximation</span></span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//such as x = o.f()</span></span><br><span class="line">    <span class="comment">//for over-approximation</span></span><br><span class="line">    <span class="keyword">return</span> Value.getNAC(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中二元表达式计算规则见ppt所示,</p><img src="/2024/10/28/SPA-A2/pic7.png" class="" title="pic7"><p>笔者在此给出一些细节和边界条件,也可以通过阅读上述代码框架获得细节提示:</p><ul><li><p><code>exp</code>中的操作数可能不是<code>IntType</code>,所以你需要做一个<code>canHoldInt()</code>判断,非法<code>exp</code>为了安全性应赋值为<code>NAC</code></p></li><li><p>实验指南中提到, 对于<code>/</code>和<code>%</code>的除零错误,应当给出<code>Undef</code>,<strong>即使</strong>被除数是<code>NAC</code>.</p></li></ul><h2 id="sovler-worklistsolver">Sovler &amp; WorkListSolver</h2><h3 id="sovler-init">Sovler Init</h3><p>照着算法流程前三行写便是,但这里要提到框架代码的"<strong>robustness</strong>".</p><p>尽管从分析流程上来看, 我们不应该分析<code>Node Entry</code>,但是框架代码允许我们这样做.这时框架代码会认为<code>Node Entry</code>是一条<code>nop Stmt</code>,不会做constant update,因此只要在<code>Init</code>部分对<code>Entry</code>的<code>inFact</code>和<code>outFact</code>都赋上初值,就不需要在worklist中考虑<code>Entry</code>的处理了.</p><h3 id="worklistsolver-dosolveforward">WorkListSolverdoSolveForward</h3><p><strong>worklist</strong>是一种非常简单的算法,笔者在此不对算法实现过多赘述.注意在实现worklist的时候可以使用java自带的容器<code>Queue</code> &amp;<code>ArrayList</code>.</p><p>关于<strong>worklist</strong>的初始化问题,需要注意的是应当为其加入所有的<code>Node</code>,如果只加入<code>Entry</code>的后继, 会产生问题, 笔者在此给出一个例子.(感谢课程群中<ahref="https://github.com/rijuyuezhu"><strong>日居月诸</strong></a>大佬和另一位不知道github链接的大佬构造的反例)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span>&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] nop;     &#123;&#125;</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;   &#123;x=<span class="number">1</span>&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] x = <span class="number">2</span>;   &#123;x=<span class="number">2</span>&#125;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] x = <span class="number">3</span>;   &#123;x=<span class="number">3</span>&#125;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">4</span>;   &#123;x=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L8</span>] y = x;   &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] <span class="keyword">return</span>;  &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中,<code>Entry outFact</code>初始化为<code>&#123;&#125;</code>(没有参数),然而<code>Stmt0</code> 的 <code>outFact</code>同样初始化为<code>&#123;&#125;</code>,如果只添加<code>Entry</code>的后继<code>&#123;Stmt0&#125;</code>,会导致worklist在分析完<code>Stmt0</code>后错误终止.</p><h2 id="总结">总结</h2><p>本次实验应该是所有Assignment中代码量最多的一次, 细节也是让人头皮发麻,还望能静下心来看代码和debug, 祝早日AC!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-2 Constant
Propagation &amp;amp; WorlistSolver.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A1-Live Variable Analysis</title>
    <link href="http://la-pluma.github.io/2024/10/20/SPA-A1/"/>
    <id>http://la-pluma.github.io/2024/10/20/SPA-A1/</id>
    <published>2024-10-19T16:04:07.000Z</published>
    <updated>2024-10-28T16:59:48.587Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-1 Live VariableAnalysis &amp; IterativeSolver.</strong></p><span id="more"></span><h2 id="实验信息">实验信息</h2><p>NJU软件分析, 实际上是静态分析(Static Program Analysis),是由李樾和谭添老师开设的面向本科生和研究生的一门课程,因为是本研共修选修课, 因此本课程内容较为基础,比较适合对静态分析感兴趣的初学者快速入门. 课程网站<ahref="https://tai-e.pascal-lab.net/lectures.html"><strong>[StaticProgram Analysis]</strong></a>, 配套课程<ahref="https://www.bilibili.com/video/BV1b7411K7P4"><strong>[Bilibili|南京大学《软件分析》]</strong></a>.</p><p>本课程实验(Assignments)基于Tai-e教学版框架,框架代码的获取和实验环境配置见课程网站, 笔者在约一年前曾自学过本课程,现今跟随2024Fall课程进度再次学习,由于上次学习中受到了多位前辈留下的实验记录帮助,遂于此记录笔者对各个实验的理解和记录. 限于笔者个人能力水平,恐难完整覆盖实验中的所有要点, 记录内容仅供参考, 如能帮助到您,乃笔者荣幸.</p><p>鉴于 <strong>学术诚信(Academic Integrity)</strong> 要求, 笔者暂且<strong><em>不</em></strong> 公开源代码.</p><h2 id="食用指南">食用指南</h2><p>本试验记录 <strong><em>不会</em></strong>从零开始讨论完成实验的知识点, 框架理解和注意事项.食用前请确保观看并理解了课程的P1-4内容, 尤其是对活跃变量分析(LiveVariable Analysis)的算法和原理的基本掌握; 完整阅读过<ahref="https://tai-e.pascal-lab.net/pa1.html"><strong>实验指南</strong></a>和框架代码后,再来参考本实验记录, 效果最佳.</p><h2 id="任务目标">任务目标</h2><p>基于已有框架为java实现一个<strong>活跃变量分析</strong>,使用<strong>迭代求解器(Iterative Solver)</strong>.</p><p>具体来说, 实现YourTask中涉及的三份文件中的6个<code>TODO API</code>.</p><p>涉及的主要算法如下图所示:</p><img src="/2024/10/20/SPA-A1/pic1.png" class="" title="pic1"><p>作为第一个实验, 总体难度不高, 关键在于熟悉Tai-e框架,还望读者耐心阅读框架代码. 不妨善用GithubCopilot或者ChatGPT帮助理解框架代码.</p><h2 id="livevariableanalysis">LiveVariableAnalysis</h2><p>活跃变量分析算法中需要用到的具体方法, 实验指南中已有较为详细的说明,笔者在此不再赘述.</p><img src="/2024/10/20/SPA-A1/pic2.png" class="" title="pic2"><p>关于实现该部分所需的<code>API</code>,请阅读<code>Class SetFact</code>源码.</p><p>笔者在此补充一些本实验所需java语法性质或语法糖.</p><h3 id="class-optional">Class Optional</h3><p>Java 8引入的性质, 详细信息可查询文档或教程, 笔者在此给出其一<ahref="https://www.runoob.com/java/java8-optional-class.html"><strong>[菜鸟教程|JavaOptional]</strong></a>.</p><p>与之类似的还有<code>java.util.List</code>,学习java语法来获得<code>Optional</code>和<code>List</code>中的内容.</p><p>使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> stmt.getDef().orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="instanceof操作符">instanceof操作符</h3><p>java中用于判断类型的操作符, 详细信息可参考<ahref="https://www.baeldung.com/java-instanceof"><strong>[Baeldung|Javainstanceof Operator]</strong></a>.</p><p>使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(def <span class="keyword">instanceof</span> Var)</span><br></pre></td></tr></table></figure><p>需要注意的是, 如指南所示</p><img src="/2024/10/20/SPA-A1/pic3.png" class="" title="pic3"><p><code>Exp</code>下的<code>LValue</code><code>RValue</code>包括多种类型,我们只需要关注<code>Var</code>类型的使用.</p><blockquote><p><strong>Tips:</strong> 为什么不需要考虑别的类型?</p><p><code>LValue</code>只需要关注<code>Var</code>, 这是手册告诉我们的.<code>RValue</code>尽管有多种类型,但可以通过<code>getUses()</code>方法将Exp中涉及的变量等信息全部获取,此时右式是<code>UnaryExp</code>or<code>BinaryExp</code>对我们来说都不重要了,只需要将<code>getUses()</code>中的<code>Var</code>筛选出来处理即可.</p></blockquote><blockquote><p><strong>Additional:</strong> <code>getUses()</code>究竟返回什么?</p><p>笔者在此引用<ahref="https://github.com/RicoloveFeng">RicoloveFeng</a>在<ahref="https://github.com/RicoloveFeng/SPA-Freestyle-Guidance">SPA-Freestyle-Guidance</a>中的解释</p><p>你可能想知道 <code>getUses()</code> 除了 <code>x = y</code>这条语句之外还返回些什么东西.我们举点例子吧:</p><ul><li><p><code>x = y op z</code>: <code>[y, z, y op z]</code></p></li><li><p><code>x = m(n)</code>:<code>[mClass, n, invokevirtual mClass.m(n)]</code></p></li></ul></blockquote><h3 id="java引用机制">java引用机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//in = out.copy();</span></span><br><span class="line">        in.set(out);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管两行代码"看起来"是一致的,但注释掉的代码只会改变形参<code>in</code>的取值,不会改变实际的<code>Fact in</code>. 详细原理可以参考<ahref="https://zhuanlan.zhihu.com/p/453857961"><strong>[知乎|java引用详解]</strong></a>.</p><h2 id="solver-iterativesolver">Solver &amp; IterativeSolver</h2><p>本部分对应具体的算法流程.</p><p>实际上指南写的已足够详细,包括如何从<code>cfg</code>中获取信息的方法和两处<code>TODO</code>对应的具体部分,使得即便对框架不甚理解, 仍然能完成该部分.</p><p>唯一需要阅读代码知道的是可以通过<code>analysis.xx</code>的方式调用我们在上一节中实现的<code>API</code>.</p><p><code>Solver</code>的<code>Init</code>需要注意的是由于我们<code>analysis.meetInto()</code>与算法中不完全相同,在初始化阶段我们同样要对<code>out Fact</code>进行赋空初始化.</p><p><code>IterativeSovlver</code>部分是算法的循环部分,由于我们的分析器<code>BB</code>是<code>stmt</code>,因此不需要考虑Block内部的执行顺序,直接使用<code>analysis.transferNode</code>即可.</p><p>另外, 上课时遍历迭代顺序取的是较优结果, 我们不需要过多考虑性能问题,因此以任意节点顺序迭代仍然可以得到结果, 这大大降低了代码实现的复杂性,只需要使用简单的<code>for(Node node : cfg)</code>即可.</p><p>笔者同样补充一些可能对本实验理解有帮助的细节部分.</p><h3 id="dataflowresult">DataflowResult</h3><p>其本质是两个<code>Nodes</code>对应的<code>inFacts</code><code>outFacts</code>的集合, 通过给定的API获取和设置其中的值,其中<code>inFacts</code>和<code>outFacts</code>不过是<code>set</code>的封装,在抽象层面上意义和课程中的那个代表变量的二进制串相同.</p><h3id="cfgnode-cfg-中的-node具体指什么"><code>CFG&lt;Node&gt; cfg</code>中的 <code>Node</code>具体指什么?</h3><p>在本次实验中, <code>Node node</code>指的是<code>stmt</code>,从指南中可以推测出这点. 通过阅读源代码, 也可以得知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiveVariableAnalysis</span> <span class="keyword">extends</span></span><br><span class="line">        <span class="title class_">AbstractDataflowAnalysis</span>&lt;Stmt, SetFact&lt;Var&gt;&gt;</span><br></pre></td></tr></table></figure><p>所以我们可以直接使用以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Node node : cfg)&#123;</span><br><span class="line">    ...</span><br><span class="line">    analysis.transferNode(node, in, out);</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>总的来说这次实验的难点在于框架代码的理解,笔者在记录中提及了部分关键定义和代码理解, 只要耐心阅读框架代码,相信一定会AC.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;NJU Static Program Analysis | Assignment-1 Live Variable
Analysis &amp;amp; IterativeSolver.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-机器学习 Ch2</title>
    <link href="http://la-pluma.github.io/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/"/>
    <id>http://la-pluma.github.io/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/</id>
    <published>2024-09-24T15:38:02.000Z</published>
    <updated>2024-10-30T11:53:35.681Z</updated>
    
    <content type="html"><![CDATA[<p><strong>有多个算法和参数生成的模型, 哪个才是好的模型?</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#chapter-2-模型评估与选择">Chapter 2: 模型评估与选择</a><ul><li><a href="#-21-经验误差与过拟合">$ 2.1 经验误差与过拟合</a></li><li><a href="#-22-评估方法">$ 2.2 评估方法</a><ul><li><a href="#-221-留出法hold-out">$ 2.2.1 留出法(Hold-Out)</a></li><li><a href="#-222-交叉验证法cross-validation">$ 2.2.2 交叉验证法(CrossValidation)</a></li><li><a href="#-223-自助法bootstapping">$ 2.2.3自助法(Bootstapping)</a></li><li><a href="#-224-调参与最终模型">$ 2.2.4 调参与最终模型</a></li></ul></li><li><a href="#-23-性能度量">$ 2.3 性能度量</a><ul><li><a href="#-231-错误率与精度">$ 2.3.1 错误率与精度</a></li><li><a href="#-232-查准率precision-查全率recall-f1">$ 2.3.2查准率(Precision), 查全率(Recall), F1</a></li><li><a href="#-233-roc与auc">$ 2.3.3 ROC与AUC</a></li><li><a href="#-234-代价敏感错误率与代价曲线">$ 2.3.4代价敏感错误率与代价曲线</a></li></ul></li><li><a href="#-24-比较检验">$ 2.4 比较检验</a><ul><li><a href="#-241-假设检验">$ 2.4.1 假设检验</a></li><li><a href="#-242-多学习器比较">$ 2.4.2 多学习器比较</a></li></ul></li><li><a href="#25-偏差与方差">2.5 偏差与方差</a></li></ul></li></ul><hr /><h2 id="chapter-2-模型评估与选择">Chapter 2: 模型评估与选择</h2><h3 id="经验误差与过拟合">$ 2.1 经验误差与过拟合</h3><ul><li><p><strong>错误率(Error Rate):</strong>分类错误的样本数占样本总数的比例, 记样本数为<spanclass="math inline">\(m\)</span>, <spanclass="math inline">\(a\)</span>个错误分类的样本, 错误率 <spanclass="math inline">\(E=\frac{a}{m}\)</span> .</p></li><li><p><strong>精度(Accuracy):</strong> <span class="math inline">\((1 -\frac{a}{m}) \times 100\%\)</span> 称为精度, 即 "精度 = 1 -错误率".</p></li><li><p><strong>误差(Error):</strong> 更一般地,我们把<strong>学习器的实际预测输出</strong>与<strong>样本的真实输出</strong>之间的差异称为误差,学习器在训练集上的误差称为 <strong>训练误差(TrainingError)/经验误差(Empirical Error)</strong>,在新样本上的误差称为<strong>泛化误差(Generalization Error)</strong>.</p><blockquote><p><strong>Tips:</strong> 这里的误差均指<strong>误差期望</strong>.</p></blockquote></li></ul><p>尽管我们希望得到一个泛化误差小的学习器, 使得其在新样本上表现很好,但我们并不能预测新样本, 因此我们只能尝试降低经验误差.但经验误差很小的学习器往往在泛化误差的表现上都很糟糕.这样的学习器发生了<strong>过拟合</strong>.</p><ul><li><p><strong>过拟合(Overfitting):</strong>学习器可能将训练样本自身的一些特点当作了所有潜在样本都具有的一般性质,导致泛化能力下降的现象.</p></li><li><p><strong>欠拟合(Underfitting):</strong> 与过拟合相对,指对训练样本的一般性质尚未学好.</p></li></ul><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-1.png" class="" title="pic2-1"><blockquote><p><strong>Tips:</strong> 导致过拟合的原因很多,最常见的原因是学习能力过强; 欠拟合则相反, 因为学习能力低下.欠拟合容易克服, 但过拟合很难解决, 且过拟合无法彻底避免.</p></blockquote><ul><li><strong>模型选择(Model Selection):</strong> 在实际中,面对同一个问题, 往往有多种学习算法可以选择,参数配置也会对模型产生影响.</li></ul><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-2.png" class="" title="spic2-2"><h3 id="评估方法">$ 2.2 评估方法</h3><p>通常我们可以通过实验测试对学习器的泛化误差进行评估,使用<strong>测试集(Testing Set)</strong>测试学习器对新样本的判别能力,以测试集上<strong>测试误差(Testing Error)</strong>作为泛化误差的近似.但需要注意的是, 测试集应尽可能与训练集互斥.</p><blockquote><p>假设我们有且只有一个包含<spanclass="math inline">\(m\)</span>个样例的数据集<spanclass="math inline">\(D = \{(x_1,y_1),(x_2,y_2), ...,(x_m,y_m)\}\)</span>, 既要训练, 又要测试, 这样就需要对<spanclass="math inline">\(D\)</span>进行适当处理, 从中产生<strong>训练集</strong> <span class="math inline">\(S\)</span>和<strong>测试集</strong> <span class="math inline">\(T\)</span>.</p></blockquote><h4 id="留出法hold-out">$ 2.2.1 留出法(Hold-Out)</h4><p>留出法的思路很简单, 直接将数据集<spanclass="math inline">\(D\)</span>划分成两个互斥的集合, 即<spanclass="math inline">\(D = S \cup T, S \cap T = \emptyset\)</span>.</p><p>使用留出法时需要注意训练集和测试集的划分需要保持数据分布一致性,避免因数据划分引入额外偏差对结果产生影响.同时单次留出法得到的估计往往并不够准确可靠, 一般采用若干次随机划分,重复进行实验评估取平均值作为留出法评估结果. 关于划分比例, 通常取2/3 ~4/5的样本用于训练, 其余用于测试.</p><h4 id="交叉验证法cross-validation">$ 2.2.2 交叉验证法(CrossValidation)</h4><p>交叉验证法可以看作是一种具体的留出法, 其方法过程是:</p><p>先将数据集<span class="math inline">\(D\)</span>划分为<spanclass="math inline">\(k\)</span>个大小相似的互斥子集, <spanclass="math inline">\(D = D_1 \cup D_2 \cup ... \cup D_k, D_i \cap D_j =\emptyset (i \neq j)\)</span>, 子集<spanclass="math inline">\(D_i\)</span>通过保留类别比例的<strong>分层采样(StratifiedSampling)</strong>来尽可能保持数据分布一致性.</p><p>接下来每次取<span class="math inline">\(k-1\)</span>个子集作为训练集,余下一个作为测试集, 进行<spanclass="math inline">\(k\)</span>次训练和测试, 最终结果取<spanclass="math inline">\(k\)</span>个结果的均值.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-2.png" class="" title="pic2-2"><p>显然交叉验证法评估结果的<strong>稳定性(Stability)</strong>和<strong>保真性(Fidelity)</strong>与<spanclass="math inline">\(k\)</span>的取值强相关.故而交叉验证法又称<strong>k折交叉验证(k-fold Cross Validation)</strong>.最常见的取值是 <span class="math inline">\(k=10\)</span>.</p><p>由于<span class="math inline">\(D\)</span>的<spanclass="math inline">\(k\)</span>划分不唯一, k折交叉验证通常也要重复多次,记为<span class="math inline">\(p\)</span>, 最终结果取这<spanclass="math inline">\(p\)</span>次k折交叉验证结果的均值.</p><p><strong>留一法(Leave-One-Out, LOO)</strong>, <spanclass="math inline">\(|D| = m\)</span>, 则令<spanclass="math inline">\(k = m\)</span> 就得到了留一法.</p><p>留一法的优势是不受样本划分影响(有且仅有一种划分方式), 训练集仅比<spanclass="math inline">\(D\)</span>少一个样本,绝大多数情况下留一法中被评估的模型与期望用<spanclass="math inline">\(D\)</span>训练的模型相似.因此认为留一法评估结果较为准确. 缺点是当<spanclass="math inline">\(m\)</span>较大时, 计算开销过大以致无法接受.</p><h4 id="自助法bootstapping">$ 2.2.3 自助法(Bootstapping)</h4><p>留出法和交叉验证法都保留了一部分样本用于测试,因此实际评估的模型所使用的训练集比<spanclass="math inline">\(D\)</span>小,必然会引入一些因训练样本规模不同而导致的估计偏差.留一法的计算复杂度又太高了. 自助法提供了一个较好的解决方案.</p><p>自助法直接以 <strong>自助采样法(Bootstrap Sampling)</strong> 为基础.给定包含<span class="math inline">\(m\)</span>个样本的数据集<spanclass="math inline">\(D\)</span>, 对其进行采样产生数据集<spanclass="math inline">\(D&#39;\)</span>. 采样过程每次随即从<spanclass="math inline">\(D\)</span>中挑选一个样本, 将拷贝放入<spanclass="math inline">\(M&#39;\)</span><strong>(意味着下次采样该样本仍有可能被采样到)</strong>. 重复该过程<spanclass="math inline">\(m\)</span>次, 得到了包含<spanclass="math inline">\(m\)</span>个样本的数据集<spanclass="math inline">\(D&#39;\)</span>.</p><blockquote><p><strong>Tips:</strong> 此处"自助"为意译,称<strong>可重复采样/有放回采样</strong>更符合其原理.</p></blockquote><p>不难看出, 可能存在部分样本被多次采样到, 部分样本未被采样到.我们关注某个样本在<spanclass="math inline">\(m\)</span>次中未被采样的概率,有</p><p><span class="math display">\[\begin{equation}\lim_{m \rightarrow \infty}(1 - \frac{1}{m})^m  = \frac{1}{e} \approx0.368 \tag{2.1}\end{equation}\]</span></p><p>通过自主采样, 初始数据集<spanclass="math inline">\(D\)</span>中约有<spanclass="math inline">\(36.8\%\)</span>的样本未出现在采样数据集<spanclass="math inline">\(D&#39;\)</span>中, 将<spanclass="math inline">\(D&#39;\)</span>作为训练集, <spanclass="math inline">\(D \backslash D&#39;\)</span>作为测试集.这样的测试结果称为<strong>包外估计(Out-Of-Bagestimate)</strong>.</p><p>自助法在数据集较小, 难以有效划分训练和测试集的时候具有优势.但自助法产生的数据集改变了初始数据集的分布, 会引入估计误差.初始数据集较大时更常用留出法和交叉验证法.</p><h4 id="调参与最终模型">$ 2.2.4 调参与最终模型</h4><p><strong>参数(Parameter)</strong>和<strong>调参(ParameterTuning)</strong>释义见名称.</p><blockquote><p><strong>Tips:</strong> 机器学习常涉及两类参数:算法参数和模型参数.</p></blockquote><ul><li><p><strong>验证集(Validation Set):</strong>模型评估与选择中用于评估测试的数据集常称为验证集.</p><blockquote><p><strong>Additonal:</strong> 关于训练集, 测试集和验证集的区别,笔者在此参考<ahref="https://zhuanlan.zhihu.com/p/98532085"><strong>[知乎|训练集、验证集、测试集]</strong></a></p></blockquote></li></ul><h3 id="性能度量">$ 2.3 性能度量</h3><ul><li><strong>性能度量(Performance Measure):</strong>衡量模型泛化能力的评价标准. 显然该标准取决于任务需求.</li></ul><p>以预测任务为例, 给定样例集<span class="math inline">\(D =\{(\boldsymbol{x_1}, y_1), (\boldsymbol{x_2}, y_2), ...,(\boldsymbol{x_m}, y_m)\}\)</span>, 其中<spanclass="math inline">\(y_i\)</span>是<spanclass="math inline">\(\boldsymbol{x_i}\)</span>的真实标记,评估学习器<span class="math inline">\(f\)</span>的性能,需要比较预测结果<span class="math inline">\(f(x)\)</span>与真实标记<spanclass="math inline">\(y\)</span>.</p><p>回归任务常用性能度量<strong>均方误差(Mean Squared Error)</strong></p><p><span class="math display">\[\begin{equation}E(f;D) = \frac{1}{m} \sum_{i=1}^{m}(f(\boldsymbol{x_i}) - y_i)^2\tag{2.2}\end{equation}\]</span></p><p>更一般地, 对于数据分布<spanclass="math inline">\(\mathcal{D}\)</span>和概率密度函数<spanclass="math inline">\(p(\cdot)\)</span>, 均方误差描述为</p><p><span class="math display">\[\begin{equation}E(f;\mathcal{D}) = \int_{x \sim \mathcal{D}}^{}(f(\boldsymbol{x}) - y)^2p(\boldsymbol{x}) d\boldsymbol{x} \tag{2.3}\end{equation}\]</span></p><h4 id="错误率与精度">$ 2.3.1 错误率与精度</h4><p>错误率和精度是分类任务中最常用的两种性能度量.</p><p>对于样例集<span class="math inline">\(\mathcal{D}\)</span>,错误率和精度定义为</p><p><span class="math display">\[\begin{equation}E(f;D) = \frac{1}{m} \sum_{i=1}^{m}\mathbb{I}(f(\boldsymbol{x_i}) \neqy_i) \tag{2.4}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}acc(f;D) = \frac{1}{m} \sum_{i=1}^{m}\mathbb{I}(f(\boldsymbol{x_i}) =y_i) = 1 - E(f;D) \tag{2.5}\end{equation}\]</span></p><p>对于数据分布<spanclass="math inline">\(\mathcal{D}\)</span>和概率密度函数<spanclass="math inline">\(p(\cdot)\)</span>, 错误率和精度定义为</p><p><span class="math display">\[\begin{equation}E(f;\mathcal{D}) = \int_{x \sim\mathcal{D}}^{}\mathbb{I}(f(\boldsymbol{x}) \neq y) p(\boldsymbol{x})d\boldsymbol{x} \tag{2.6}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}acc(f;\mathcal{D}) = \int_{x \sim\mathcal{D}}^{}\mathbb{I}(f(\boldsymbol{x}) = y) p(\boldsymbol{x})d\boldsymbol{x} = 1 - E(f;\mathcal{D}) \tag{2.7}\end{equation}\]</span></p><h4 id="查准率precision-查全率recall-f1">$ 2.3.2 查准率(Precision),查全率(Recall), F1</h4><p>有时我们更关心模型的正确率,比如说"挑选出来的瓜有多少是好瓜","有多少好瓜被挑选出来了",查准率和查全率更适合用来度量.</p><p>对于二分类问题, 我们有<strong>混淆矩阵(Confusion Matrix)</strong></p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/tab2-1.png" class="" title="tab2-1"><p>定义查准率<span class="math inline">\(P\)</span>, 查全率<spanclass="math inline">\(R\)</span></p><p><span class="math display">\[\begin{equation}P = \frac{TP}{TP + FP}\tag{2.8}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}P = \frac{TP}{TP + FN}\tag{2.9}\end{equation}\]</span></p><blockquote><p><strong>Tips:</strong> 自然语言解释就是,查准率是在预测正确中实际正确的比率,查全率是在实际正确中预测正确的比率.</p></blockquote><p>查准率和查全率是一对矛盾的度量, 二者负相关.是<strong>sound</strong>和<strong>complete</strong>的关系</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-1.png" class="" title="spic2-1"><blockquote><p><strong>Tips:</strong> 该图片截选自NJU软件分析课件,<del>ly和tt老师应该不会在意吧(雾)</del></p><p>课程地址链接<ahref="https://tai-e.pascal-lab.net/lectures.html"><strong>[StaticProgram Analysis]</strong></a></p></blockquote><p>查准率和查全率的关系可以用<strong>P-R图</strong>表示</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-3.png" class="" title="pic2-3"><ul><li><strong>平衡点(Break-Even Point, BEP):</strong> <spanclass="math inline">\(P=R\)</span>时的取值,可基于BEP评估两个学习器的优劣, 如图2-3, 可认为<spanclass="math inline">\(A&gt;B&gt;C\)</span></li></ul><p>比BEP更常用的是<span class="math inline">\(F1\)</span>度量定义为</p><p><span class="math display">\[\begin{equation}F1 = \frac{2 \times P \times R}{P + R} = \frac{2 \times TP}{样例总数 +TP - TN}\tag{2.10}\end{equation}\]</span></p><p><span class="math inline">\(F_{\beta}\)</span>是<spanclass="math inline">\(F_1\)</span>的一般形式, 定义为</p><p><span class="math display">\[\begin{equation}F_{\beta} = \frac{(1 + \beta^2) \times P \times R}{(\beta^2 \times P) +R}\tag{2.11}\end{equation}\]</span></p><p>其中<span class="math inline">\(\beta &gt;0\)</span>度量了查全率对查准率的相对重要性, <spanclass="math inline">\(\beta = 1\)</span>时退化为<spanclass="math inline">\(F_1\)</span>, <span class="math inline">\(\beta&gt; 1\)</span>时查全率影响更大, <span class="math inline">\(\beta &lt;1\)</span>时查准率影响更大.</p><blockquote><p><strong>Tips:</strong></p><p><span class="math inline">\(F_1\)</span>基于调和平均定义, <spanclass="math inline">\(\frac{1}{F_1} = \frac{1}{2} \cdot (\frac{1}{P} +\frac{1}{R})\)</span>.</p><p><span class="math inline">\(F_\beta\)</span>基于加权调和平均定义,<span class="math inline">\(\frac{1}{F_\beta} = \frac{1}{1 + \beta^2}\cdot (\frac{1}{P} + \frac{\beta^2}{R})\)</span></p></blockquote><p>若在n个二分类混淆矩阵上考察准确率和查全率,我们有<strong>macro</strong>和<strong>micro</strong>两种选择.</p><p>对于<strong>宏(macro)</strong>, 在各个混淆矩阵上分别计算<spanclass="math inline">\(P\)</span>和<spanclass="math inline">\(R\)</span>,再取平均.得到<strong>宏查准率(macro-P)</strong>,<strong>宏查全率(macro-R)</strong>, <strong>宏F1(macro-F1)</strong></p><p><span class="math display">\[\begin{equation}macro\text{-}P = \frac{1}{n} \sum_{i=1}^{n} P_i\tag{2.12}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}macro\text{-}R = \frac{1}{n} \sum_{i=1}^{n} R_i\tag{2.13}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}macro\text{-}F1 = \frac{2 \times macro\text{-}P \timesmacro\text{-}R}{macro\text{-}P + macro\text{-}R}\tag{2.14}\end{equation}\]</span></p><p>对于<strong>微(micro)</strong>, 先平均混淆矩阵得到$, , , $,再计算出<strong>微查准率(micro-P)</strong>,<strong>微查全率(micro-R)</strong>, <strong>微F1(micro-F1)</strong></p><p><span class="math display">\[\begin{equation}micro\text{-}P =\frac{\overline{TP}}{\overline{TP}+\overline{FP}}\tag{2.15}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}micro\text{-}R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}\tag{2.16}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}micro\text{-}F1 = \frac{2 \times micro\text{-}P \timesmicro\text{-}R}{micro\text{-}P + micro\text{-}R}\tag{2.17}\end{equation}\]</span></p><h4 id="roc与auc">$ 2.3.3 ROC与AUC</h4><p>现重新考虑查准率和查全率, 首先我们来看看学习器如何给正/反的分类.</p><p>很多学习器为测试样本产生一个实值或概率预测,将预测值与<strong>分类阈值(Threshold)</strong>比较, 大于阈值则为正类,否则为反类. 根据该实值或概率预测进行排序, 概率高的在前, 概率低的在后,则这个分类阈值就是<strong>截断点(Cut Point)</strong>, 前一部分为正例,后一部分为负例.</p><p>不难得到以下结论: 截断点越靠前, 查准率增高而查全率降低; 截断点越靠后,查准率降低而查全率增高. 同时,排序质量越好的学习器"在一般情况下"泛化性能越好,ROC基于此度量模型的泛化能力.</p><p><strong>受试者工作特征(Receiver Operating Characteristic,ROC)</strong>, 根据学习器的预测结果对样例进行排序,顺序逐个把样本作为正例进行预测(选择不同的截断点),计算<strong>真正例率(True Positive Rate, TPR)</strong>,<strong>假正例率(False Positive Rate, FPR)</strong> 作为纵横轴.</p><p><span class="math display">\[\begin{equation}TPR = \frac{TP}{TP + FN}\tag{2.18}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}FPR = \frac{FP}{TN + FP}\tag{2.19}\end{equation}\]</span></p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-4.png" class="" title="pic2-4"><p>对角线对应随即猜测模型, 点(0, 1)对应所有正例在负例前的理想模型.</p><ul><li><strong>AUC(Area Under ROC Curve):</strong> ROC曲线下面积.为依据两个模型绘制的ROC曲线比较两个模型的优劣而引入.</li></ul><p>对于离散样本, 计算AUC:</p><p><span class="math display">\[\begin{equation}AUC = \frac{1}{2} \sum^{m - 1}_{i=1}(x_{i+1} - x_i)\cdot(y_i + y_{i + 1})\tag{2.19}\end{equation}\]</span></p><p>形式化上AUC度量排序质量, 记有<spanclass="math inline">\(m^+\)</span>个正例, <spanclass="math inline">\(m^-\)</span>个反例, 令<spanclass="math inline">\(D^+\)</span>为正例集合, <spanclass="math inline">\(D^-\)</span>为负例集合,定义排序<strong>损失(loss):</strong></p><p><span class="math display">\[\begin{equation}\mathscr{l}_{rank} = \frac{1}{m^+ m^-}\sum_{x^+ \in D^+} \sum_{m^- \inD^-}\left(\mathbb{I}(f(x^+)&lt;f(x^-)) + \frac{1}{2} \mathbb{I}(f(x^+)=f(x^-))\right)\tag{2.21}\end{equation}\]</span></p><p>如何理解这个式子? 考虑每一对正反例, 若正例小于反例记一个"罚分",相等则记半个. 不难看出, 对于每个正例/负例, 可能造成的"罚分"与其"位置",越"错误"的位置会引起越多的"罚分", 这与AUC计算过程及其相似. 实际上, <spanclass="math inline">\(\mathscr{l}_{rank}\)</span>对应ROC曲线上方的面积,有</p><p><span class="math display">\[\begin{equation}AUC = 1 - \mathscr{l}_{rank}\tag{2.22}\end{equation}\]</span></p><h4 id="代价敏感错误率与代价曲线">$ 2.3.4 代价敏感错误率与代价曲线</h4><p>为权衡不同类型错误所造成的不同损失,我们为错误赋予<strong>非均等代价(UnEqual Cost)</strong>.</p><p>以二分类为例, <strong>代价矩阵(Cost Matrix)</strong>如下:</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/tab2-2.png" class="" title="tab2-2"><p>若将0类记为正例, 1类记为负例, 定义<span class="math inline">\(D^+,D^-\)</span>, <strong>代价敏感(Cost-Sensitive)</strong> 错误率为</p><p><span class="math display">\[\begin{equation}E(f;D;cost) = \frac{1}{m} \left(\sum_{\boldsymbol{x}_i \in D^+}\mathbb{I}(f(\boldsymbol{x}_i) \neq y_i) \times cost_{01} +\sum_{\boldsymbol{x}_i \in D^-} \mathbb{I}(f(\boldsymbol{x}_i) \neq y_i)\times cost_{10}\right)\tag{2.23}\end{equation}\]</span></p><p>非均等情况下, <strong>代价曲线(CostCurve)</strong>可以解决ROC曲线不能反映出学习器的期望<strong>总体代价(TotalCost)</strong>问题.</p><p>其横轴是取值为<spanclass="math inline">\([0,1]的\)</span>正例概率代价, 其中<spanclass="math inline">\(p\)</span>为样例是正例的概率</p><p><span class="math display">\[\begin{equation}P(+)cost=\frac{p \times cost_{01}}{p \times cost_{01} + (1 - p) \timescost_{10}}\tag{2.24}\end{equation}\]</span></p><p>纵轴是取值为<spanclass="math inline">\([0,1]\)</span>的归一化代价,FPR为假正例率,FNR为假反例率</p><p><span class="math display">\[\begin{equation}cost_{norm} = \frac{FNR \times p \times cost_{01} + FPR \times (1 - p)\times cost_{10}}{p \times cost_{01} + (1 - p) \times cost_{10}}\tag{2.25}\end{equation}\]</span></p><p>绘制代价曲线时, ROC曲线上每个点对应代价平面上的一条线段,设ROC点坐标为<span class="math inline">\((FPR, TPR)\)</span>,然后在代价平面上绘制一条从<span class="math inline">\((0,FPR)\)</span>到<span class="math inline">\((1, FNR)\)</span>的线段,线段下面积代表了该条件下的期望总体代价.如此为每个点绘制线段, 取线段下界,围成面积即为在所有条件下学习器的总体期望代价.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-5.png" class="" title="pic2-5"><blockquote><p><strong>Addtional:</strong> 如何理解代价曲线?</p><p>笔者在此给出一篇参考<ahref="https://www.zhihu.com/question/63492375"><strong>[知乎|代价曲线的理解]</strong></a>.这篇参考中对大部分问题给到了解释.</p><p>在此额外补充一点困惑笔者许久的问题, 每一条线段代表什么?</p><p>每一条线段代表当前<strong>阈值</strong>条件下,对不同样本集的期望代价. 具体来说,是以FPR和FNR为预测值对不同样本集的预测.</p></blockquote><h3 id="比较检验">$ 2.4 比较检验</h3><p><strong>统计假设检验(Hypothesis Test)</strong>为比较学习器性能提供了重要依据. 本节默认以错误率为性能度量, 用<spanclass="math inline">\(\epsilon\)</span>表示.</p><h4 id="假设检验">$ 2.4.1 假设检验</h4><p>现实中我们无法知道学习器的泛化错误率 <spanclass="math inline">\(\epsilon\)</span>, 只能获知其测试错误率 <spanclass="math inline">\(\hat{\epsilon}\)</span>.常用测试错误率估推出泛化错误率.</p><p>对于 <span class="math inline">\(m\)</span> 个测试样本,如果测试错误率为 <span class="math inline">\(\hat{\epsilon}\)</span>,则被误分类的样本数量 <span class="math inline">\(m&#39;=\hat{\epsilon}\times m\)</span>, 假定测试样本从样本总体分布中独立采样获得,由<strong>二项(Binomial)分布</strong>, 泛化错误率为 <spanclass="math inline">\(\hat{\epsilon}\)</span> 的学习器恰有 <spanclass="math inline">\(m&#39;\)</span> 个样本被误分类的概率是 <spanclass="math inline">\(\binom{m}{m&#39;}\epsilon^{m&#39;}(1-\epsilon)^{m-m&#39;}\)</span>. 同时, 这也表示泛化错误率为 <spanclass="math inline">\(\epsilon\)</span> 的学习器在<spanclass="math inline">\(m\)</span>个样本上测试得到测试错误率为 <spanclass="math inline">\(\hat{\epsilon}\)</span> 的概率:</p><p><span class="math display">\[\begin{equation}P(\hat{\epsilon};\epsilon)=\binom{m}{\hat{\epsilon} \times m}\epsilon^{\hat{\epsilon} \times m} (1 - \epsilon)^{m - \hat{\epsilon}\times m}\tag{2.26}\end{equation}\]</span></p><p>由二项分布性质, 或者计算 <spanclass="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 对 <spanclass="math inline">\(\epsilon\)</span> 的偏导, 可以知道 <spanclass="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 在 <spanclass="math inline">\(\epsilon = \hat{\epsilon}\)</span> 时最大, <spanclass="math inline">\(|\epsilon - \hat{\epsilon}|\)</span> 增大时 <spanclass="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 减小.</p><p>若取 <span class="math inline">\(m=10, \epsilon = 0.3\)</span>,示意图如2.6所示.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-6.png" class="" title="pic2-6"><blockquote><p><strong>Tips:</strong><del>死去的《概率论与数理统计》突然复活起来攻击我</del>, 推荐复习笔记<ahref="https://zhuanlan.zhihu.com/p/243215469"><strong>[知乎|概率论与数理统计复习整理]</strong></a>.</p></blockquote><p>由<strong>二项检验(Binomial Test)</strong>, 考虑假设<spanclass="math inline">\(\epsilon \leq \epsilon_0\)</span>, 在 <spanclass="math inline">\(1 - \alpha\)</span>的概率内能观测到的最大错误率为</p><p><span class="math display">\[\begin{equation}\bar{\epsilon} = \min \epsilon \ \ \text{s.t.} \ \ \sum_{i = \epsilon\times m + 1}^{m} \binom{m}{i}\epsilon_0^i (1 - \epsilon_0)^{m - i} &lt;\alpha\tag{2.27}\end{equation}\]</span></p><p>其中 <span class="math inline">\(1-\alpha\)</span>为<strong>置信度(Confidence)</strong>, 直观上对应图2.6的非阴影部分;"s.t."是"subject to", 使左边式子在右边式子条件满足时成立.</p><p>若测试错误率 <span class="math inline">\(\hat{\epsilon}\)</span>大于临界值 <span class="math inline">\(\bar{\epsilon}\)</span>,由二项检验, 我们可以认为在 <span class="math inline">\(\alpha\)</span>的显著度下, 假设 <span class="math inline">\(\epsilon \leq\hat{\epsilon}\)</span> 不能被拒绝, 即能以 <spanclass="math inline">\(1-\alpha\)</span> 的置信度认为,学习器的泛化错误率不高于 <spanclass="math inline">\(\epsilon_0\)</span>; 否则可以拒绝假设, 在 <spanclass="math inline">\(\alpha\)</span>的显著度下可认为学习器的泛化错误率大于 <spanclass="math inline">\(\epsilon_0\)</span>.</p><p>在通过多次测试中中我们会获得多个测试错误率,此时可使用<strong>t检验(t-test)</strong>.</p><p>设<span class="math inline">\(k\)</span>个错误率 <spanclass="math inline">\(\hat{\epsilon_1}, \hat{\epsilon_2}, ...,\hat{\epsilon_k}\)</span>, 则平均错误率 <spanclass="math inline">\(\mu\)</span>, 方差 <spanclass="math inline">\(\sigma^2\)</span> 为</p><p><span class="math display">\[\begin{equation}\mu = \frac{1}{k} \sum_{i=1}^k \hat{\epsilon_i}\tag{2.28}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\sigma^2=\frac{1}{k-1} \sum^{k}_{i=1}(\hat{\epsilon_i} - \mu)^2\tag{2.29}\end{equation}\]</span></p><p><span class="math inline">\(k\)</span> 个测试错误率可看作是泛化错误率<span class="math inline">\(\epsilon_0\)</span> 的独立采样, 则变量</p><p><span class="math display">\[\begin{equation}\tau_t=\frac{\sqrt{k} (\mu - \epsilon_0)}{\sigma}\tag{2.30}\end{equation}\]</span></p><p>服从自由度为 <span class="math inline">\(k-1\)</span> 的 <spanclass="math inline">\(t\)</span> 分布.</p><blockquote><p><strong>Addtional:</strong> <strong>基础知识补充</strong></p><p><span class="math inline">\(\chi^2\)</span> 分布: <spanclass="math inline">\(X_1, X_2, ..., X_n\)</span> 为独立同分布随机变量,服从 <span class="math inline">\(N(0, 1)\)</span>, 则 <spanclass="math inline">\(\chi^2_n = \sum_{i=1}^n X^2_i\)</span>为服从自由度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(\chi^2\)</span> 分布</p><p><span class="math inline">\(t\)</span> 分布: <spanclass="math inline">\(X \sim N(0,1), Y \sim \chi^2(n)\)</span>, <spanclass="math inline">\(X,Y\)</span> 独立, 称 <spanclass="math inline">\(T = \frac{X}{\sqrt{\frac{Y}{n}}}\)</span>为服从自由度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(t\)</span> 分布.</p></blockquote><blockquote><p><strong>Tips:</strong> <strong>推导补充</strong></p><p>原书中没有关于这个<spanclass="math inline">\(\tau_t\)</span>服从<spanclass="math inline">\(t\)</span>分布的推导, 笔者在此给出补充.</p><p>假设<spanclass="math inline">\(X_1,X_2,...X_n\)</span>是来自正态总体<spanclass="math inline">\(N(\mu,\sigma^2)\)</span>的样本.我们有以下重要统计量:</p><p><span class="math display">\[\begin{align}\nonumber\text{样本均值}&amp; \ \bar{X}=\frac{1}{n}\sum_{i=1}^n &gt;X_i\\\nonumber\text{样本方差}&amp; \S^2=\frac{1}{n-1}\sum_{i-1}^{n}(X_i-\bar{X})^2\end{align}\]</span></p><p>我们有几个重要结论:</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-3.png" class="" title="spic2-3"><p>故而有推论:</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-4.png" class="" title="spic2-4"></blockquote><p>对假设<spanclass="math inline">\(\mu=\epsilon_0\)</span>和显著度<spanclass="math inline">\(\alpha\)</span>, 可以算出临界值——在<spanclass="math inline">\(1-\alpha\)</span>内能观测到的最大错误率.考虑<strong>双边假设(Two-Tailed)</strong>, 若<spanclass="math inline">\(\tau_t\)</span>位于临界区<spanclass="math inline">\([t_{-\alpha/2},t_{\alpha/2}]\)</span>内(如图2.7所示),则不能拒绝假设<span class="math inline">\(\mu=\epsilon_0\)</span>.我们可以认为泛化错误率为<spanclass="math inline">\(\epsilon_0\)</span>.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-7.png" class="" title="pic2-7"><h4 id="多学习器比较">$ 2.4.2 多学习器比较</h4><p>笔者对这部分不做过多记录, 翻阅原书该部分即可.</p><p>对于两个学习器,我们有</p><ul><li>交叉验证t检验(基于成对t 检验)</li><li>McNember检验(基于列联表，卡方检验)</li></ul><p>对于多个学习器,我们有</p><ul><li>Friedman检验(基于序值，F检验; 判断”是否都相同”)</li><li>Nemenyi后续检验(基于序值，进一步判断两两差别)</li></ul><h3 id="偏差与方差">2.5 偏差与方差</h3><ul><li><strong>偏差-方差分解(Bias-variance Decomposition)</strong></li></ul><p>对测试样本<span class="math inline">\(\boldsymbol{x}\)</span>,令<span class="math inline">\(y_D\)</span>为<spanclass="math inline">\(\boldsymbol{x}\)</span>在数据集的集中标记, <spanclass="math inline">\(y\)</span>为<spanclass="math inline">\(\boldsymbol{x}\)</span>的真实标记, <spanclass="math inline">\(f(\boldsymbol{x};D)\)</span>为训练集<spanclass="math inline">\(D\)</span>上的学得模型<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}\)</span>上的预测输出.</p><p>以回归算法为例, 我们有如下定义(符号定义见<ahref="http://localhost:4000/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/#chapter-0-%E4%B8%BB%E8%A6%81%E7%AC%A6%E5%8F%B7%E8%A1%A8"><strong>[Lapluma|读书笔记-机器学习Ch0-Ch1]</strong></a>):</p><p>学习算法的期望预测.</p><p><span class="math display">\[\begin{equation}\bar{f}(\boldsymbol{x})=\mathbb{E}_D[f(\boldsymbol{x};D)]\tag{2.37}\end{equation}\]</span></p><p>使用样本数相同的不同训练集产生的方差,度量了同样大小的训练集变动导致的学习性能变化,刻画了数据扰动造成的影响.</p><p><span class="math display">\[\begin{equation}\mathcal{var}(\boldsymbol{x})=\mathbb{E}_D[(f(\boldsymbol{x};D)-\bar{f}(x))^2]\tag{2.38}\end{equation}\]</span></p><p>噪声, 在当前学习任务上任何学习算法所能达到的期望泛化误差下界,刻画了学习问题本身的难度.</p><p><span class="math display">\[\begin{equation}\varepsilon^2=\mathbb{E}_D[(y_D-y)^2]\tag{2.39}\end{equation}\]</span></p><p>期望输出与真实标记的差别称为偏差,度量了学习算法的期望预测与真是结果的偏离程度,刻画了学习算法本身的拟合能力.</p><p><span class="math display">\[\begin{equation}\mathcal{bias}^2(\boldsymbol{x})=(\bar{f}(\boldsymbol{x})-y)^2\tag{2.40}\end{equation}\]</span></p><p>便于讨论,我们假定噪声期望为0, 即<spanclass="math inline">\(\mathbb{E}_D[y_D-y]=0\)</span>,对期望泛化误差进行分解(推导略, 见原书), 有</p><p><span class="math display">\[\begin{equation}E(f;D)=bias^2(\boldsymbol{x})+var(\boldsymbol{x})+\varepsilon ^2\tag{2.42}\end{equation}\]</span></p><p>即泛化误差可以分解为偏差, 方差和噪声之和.</p><p>一般来说, 偏差和方差存在冲突, 称为<strong>偏差-方差窘境(Bias-VarianceDilemma)</strong>,见图2-9.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-9.png" class="" title="pic2-9"><p>训练不足时, 学习器拟合能力不足,训练数据的扰动不足以使学习器产生显著变化,此时偏差主导了泛化错误率;训练程度加深, 学习器拟合能力增强,训练数据发生的扰动被学习器学习到, 方差逐渐主导了泛化错误率;训练充足后,学习器拟合能力非常强. 训练数据发生轻微扰动都会导致学习器发生显著变化,此时训练数据自身,非全局的性质被学习器学习, 发生过拟合.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;有多个算法和参数生成的模型, 哪个才是好的模型?&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记-机器学习" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="机器学习" scheme="http://la-pluma.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode个人题解[C++] P4 寻找两个正序数组的中位数</title>
    <link href="http://la-pluma.github.io/2024/09/21/LeetCode-P4/"/>
    <id>http://la-pluma.github.io/2024/09/21/LeetCode-P4/</id>
    <published>2024-09-21T12:29:30.000Z</published>
    <updated>2024-09-21T18:20:42.472Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong> <ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><strong>LeetCode|4.寻找两个正序数组的中位数</strong></a></p><span id="more"></span><hr /><h2 id="题面解释">题面解释</h2><p>找出两个有序数组合并后的中位数. 但要求时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><h2 id="解法一-二分">解法一 二分</h2><p>笔者看到复杂度<span class="math inline">\(\mathit{O}(log(m +n))\)</span>第一想法便是二分, 但怎么二分? 两个数组只是内部有序,两个数组并不有序, 常规对数组二分的思路肯定是不行的.</p><p>那该如何进行二分呢, 对答案进行二分. 令k为所寻找的k阶数, 初始为中位数,则此时我们取两个数组的前<spanclass="math inline">\(k/2\)</span>部分出来, 比较<spanclass="math inline">\(nums1[k/2]\)</span>和<spanclass="math inline">\(nums2[k/2]\)</span>, 则可以直接排除<spanclass="math inline">\(k/2\)</span>个数. 我们以下图例子来解释.</p><img src="/2024/09/21/LeetCode-P4/p1.png" class="" title="p1"><p><span class="math inline">\(m = n = 4\)</span>, 我们有 <spanclass="math inline">\(k = 4, k/2 = 2\)</span>,于是我们取两个数组的前两位, 比较3和5, 不难看出, 1和3不可能是中位数.为什么? 因为1和3的阶必定小于<span class="math inline">\(k = 4\)</span>,即便第一个数组的3比第二个数组的5前面所有数都大, 3的阶也只能是3,1就更不必说了. 而5前面的数可能大于3后面的数(例子中未能体现,读者可以自行构造一个满足这种情况的简单例子). 因此通过这种操作,我们可以排掉 <span class="math inline">\(k/2\)</span>个不可能是中位数的元素, 接着我们令<span class="math inline">\(k = k -k/2\)</span>, 将被排除的数去掉, 重新进行上述过程.</p><img src="/2024/09/21/LeetCode-P4/p2.png" class="" title="p2"><p>选取两个数组的前1位.比较2 和 4, 可以排除掉2. 此时过程进行到了边界处,接下来<span class="math inline">\(k = 1\)</span>无法继续了.而此时剩下的4和5正是我们需要的中位数.</p><blockquote><p><strong>Tips:</strong> 为什么第二个数组不是选择2, 5, 7?</p><p>因为我们在上面的步骤中无法确定2和5是中位数与否, 此时的有效信息不足.而把2 5 7都放进来与4进行比较会出现bug, 以上例, 4会被错误的排除掉</p></blockquote><p>k为奇数时情况稍有不同, 但大多是一些细节问题, 笔者在此不再赘述.推荐读者自己构建一个例子去推算上面的过程, 相信不难理解其中要义.</p><p>每次排除<span class="math inline">\(k/2\)</span>, 而 <spanclass="math inline">\(k = (m + n + 1) / 2\)</span>, 故时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><p>参考代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; m; i++)&#123;cout &lt;&lt; nums1[i] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; n; j++)&#123;cout &lt;&lt; nums2[j] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = (m + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 排除掉小于中位数的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组被清空</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// 注意循环条件 k &gt; 1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 边界情况，剩余数组大小不足k</span></span><br><span class="line">            <span class="keyword">if</span> (left1 + mid &gt; m) &#123; <span class="comment">// 等价于 left1 + mid - 1 &gt;= m</span></span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 + mid &gt; n) &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                k -= mid2 - left2 + <span class="number">1</span>; <span class="comment">// 一轮可以排除掉一半</span></span><br><span class="line">                left2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= mid1 - left1 + <span class="number">1</span>;</span><br><span class="line">                left1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 k == 1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                    left2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="built_in">return</span> (nums2[left2] + nums2[left2 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[left1] + nums1[left1 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num1;</span><br><span class="line">            <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                num1 = nums2[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = nums1[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                num2 = nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                num2 = nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (num1 + num2) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 本题思路并不难想出或者说并不难理解,但非常考验代码功底, 对细节和边界情况的考察更像是此题的侧重点.还望看到此处的读者能静下心来调试代码, 祝早日AC.</p></blockquote><h2 id="解法二-分割">解法二 分割</h2><blockquote><p>笔者阅读题解时注意到的巧妙的解法, 原链接在此<ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/"><strong>P4|windliang</strong></a></p></blockquote><p>更详细的数学证明, 思路和代码请阅读原文,笔者在此只给出自己对其的理解.</p><p>本质来说, 两种方法殊途同归, 但分割的方法较为巧妙一些. 中位数,或者说k阶数, 就是将数组分为两个部分, 其一是比k阶数小的部分,其二是比k阶数大的部分.</p><p>对于有序的一个数组, 其性质本身就已经满足,我们不妨将两部分简称为左半部分(小)和右半部分(大). 对于两个有序数组,情况是一样的, 如果存在一种划分, 满足左边最大MaxLeft小于右边最小MinRight,我们则认为这是关于k阶数的一种有效划分.</p><p>因此, 这道题就被转化为寻找数组中满足中位数的有效划分,关于特定k阶数划分, 还需要满足左半部分和右半部分的数量关系,若规定将k阶数划在左半部分, 则左半部分有k个元素, 右半部分有 n - k个元素.</p><p>后面的事情就简单了, 固定数组1的划分位置,根据数量关系找到数组2待判定划分位置,根据MaxLeft和MinRight的大小关系决定数组1划分位置的左移或右移,该过程可以通过二分完成.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt; &lt;a
href=&quot;https://leetcode.cn/problems/median-of-two-sorted-arrays/&quot;&gt;&lt;strong&gt;LeetCode|4.寻找两个正序数组的中位数&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode刷题记录" scheme="http://la-pluma.github.io/categories/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="http://la-pluma.github.io/tags/LeetCode/"/>
    
    <category term="二分" scheme="http://la-pluma.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-机器学习 Ch0-Ch1</title>
    <link href="http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/"/>
    <id>http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/</id>
    <published>2024-09-18T15:04:27.000Z</published>
    <updated>2024-10-30T11:50:42.059Z</updated>
    
    <content type="html"><![CDATA[<p><strong>机器学习所研究的主要内容,是关于在计算机上从数据中产生"模型"(model)的算法, 即"学习算法"(learningalgorithm).</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter-0-主要符号表">Chapter 0: 主要符号表</a></li><li><a href="#chapter-1-绪论">Chapter 1: 绪论</a><ul><li><a href="#-11-基本术语">$ 1.1 基本术语</a></li><li><a href="#-13-假设空间">$ 1.3 假设空间</a></li><li><a href="#-14-归纳偏好">$ 1.4 归纳偏好</a></li></ul></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>《机器学习》周志华 2016.</p><p>大名鼎鼎的西瓜书, 笔者在此略去介绍.</p><h2 id="chapter-0-主要符号表">Chapter 0: 主要符号表</h2><p><span class="math display">\[\begin{aligned}&amp;\mathit{x}&amp; &amp;标量\\&amp;\boldsymbol{x}&amp; &amp;向量 \\&amp;\mathrm{x}&amp; &amp;变量集 \\&amp;\mathbf{A}&amp; &amp;矩阵 \\&amp;\mathbf{I}&amp; &amp;单位阵 \\&amp;\mathcal{X}&amp; &amp;样本空间或状态空间\\&amp;\mathcal{D}&amp; &amp;概率分布\\&amp;\mathit{D}&amp; &amp;数据样本(数据集)\\&amp;\mathcal{H}&amp; &amp;假设空间\\&amp;\mathit{H}&amp; &amp;假设集\\&amp;\mathfrak{L}&amp; &amp;学习算法\\&amp;\left ( \cdot ,\cdot ,\cdot  \right )&amp; &amp;行向量\\&amp;\left ( \cdot ;\cdot ;\cdot \right )&amp; &amp;列向量\\&amp;\left ( \cdot  \right )^{T}&amp; &amp;向量或矩阵转置\\&amp;\left \{  \cdot \cdot \cdot \right \}&amp; &amp;集合\\&amp;\left | \left \{ \cdot \cdot \cdot \right \} \right |&amp;&amp;集合中元素个数\\&amp;\left \| \cdot  \right \|_{p}&amp; &amp;L_p范数, p缺省时为L_2范数\\&amp;\mathit{P}\left ( \cdot  \right ),\mathit{P}\left ( \cdot|\cdot  \right )&amp; &amp;概率质量函数,条件概率质量函数\\&amp;\mathit{p}\left ( \cdot  \right ),\mathit{p}\left ( \cdot  | \cdot\right )&amp; &amp;概率密度函数, 条件概率密度函数\\&amp;\mathbb{E}_{\cdot \sim \mathcal{D}}\left [ f\! \left ( \cdot \right) \right ]&amp; &amp;函数 f\! \left ( \cdot \right ) 对 \cdot 在分布\mathcal{D} 下的数学期望:意义明确是将省略 \mathcal{D} 和(或)\cdot \\&amp;sup\left ( \cdot \right )&amp; &amp;上确界\\&amp;\mathbb{I} \left ( \cdot  \right )&amp; &amp;指示函数，在\cdot  为真和假分别取值为1 , 0 \\&amp;sign\left ( \cdot  \right )&amp; &amp;符号函数，在 \cdot &lt; 0, =0 , &gt;  0 时分别取值为 -1,0,1\end{aligned}\]</span></p><h2 id="chapter-1-绪论">Chapter 1: 绪论</h2><h3 id="基本术语">$ 1.1 基本术语</h3><blockquote><p>假定我们收集了一批关于西瓜的数据, 例如(色泽 = 浅白; 根蒂 = 蜷缩; 敲声= 浊响), (色泽 = 乌黑; 根蒂 = 稍蜷; 敲声 = 沉闷), (色泽 = 浅白; 根蒂 =硬挺; 敲声 = 清脆), ......, 每对括号内是一条记录,下文关于术语的表述会基于上述假定进行解释.</p></blockquote><ul><li><p><strong>数据集/样本(Data Set):</strong>这组记录的集合称为一个数据集.</p><blockquote><p><strong>Tips:</strong> 数据集亦称样本,因为数据集可看作对样本空间的一个采样.</p><p><strong>Addtional:</strong> "样本"的具体指代示例还是数据集,要看具体的上下文.</p></blockquote></li><li><p><strong>示例(Instance)/样本(Sample):</strong>每条记录称为示例/样本, 是关于一个事件或对象的描述(以上例,该对象为西瓜).</p></li><li><p><strong>属性(Attribute)/特征(Feature):</strong> "色泽", "根蒂","敲声"称为属性.</p></li><li><p><strong>属性值(Attribute Value):</strong>属性的取值称为属性值(以上例, "青绿"和"乌黑"是色泽的属性值).</p></li><li><p><strong>属性空间(Attribute Space)/样本空间(SampleSpace)/输入空间:</strong> 属性张成的空间.</p><blockquote><p><strong>Tips:</strong> 此处涉及的是线性代数知识,即将样本(Instance)依据属性转化为向量, 其中色泽, 根蒂和敲声为坐标轴,张成了一个用于描述西瓜特征的三维空间,该空间每个点即是线性代数意义上的一个向量, 也就是<strong>特征向量(FeatureVector)</strong>. 我们可以认为,示例(Instance)的另一种等价表述是特征向量.</p></blockquote></li><li><p><strong>数据集的表示:</strong> 令 <spanclass="math inline">\(\mathit{D} = \{x_1, x_2, ..., x_m\}\)</span>表示包含<span class="math inline">\(m\)</span>个示例的数据集, 每个示例由<span class="math inline">\(d\)</span> 个属性描述, 则每个示例(Instance)<span class="math inline">\(x_i= (x_{i1}; x_{i2}; ...; x_{id})\)</span>是 <span class="math inline">\(d\)</span> 维样本空间 <spanclass="math inline">\(\mathcal{X}\)</span> 中的一个向量, <spanclass="math inline">\(x_i \in \mathcal{X}\)</span>. <spanclass="math inline">\(d\)</span> 称为样本 <spanclass="math inline">\(x_i\)</span>的<strong>维数(Dimensionality)</strong>.</p></li><li><p><strong>学习(Learning)/训练(Training):</strong>从数据中学得模型的过程称为学习/训练,该过程通过执行某个学习算法完成.</p></li><li><p><strong>训练数据(Training Data):</strong>训练过程中所使用的数据.</p></li><li><p><strong>训练样本(Training Sample)/训练示例(TrainingInstance):</strong> 训练数据中的每个样本/示例.</p></li><li><p><strong>训练集(Training Set):</strong>训练样本组成的集合称为训练集.</p><blockquote><p><strong>Tips:</strong> 训练集相当于训练数据的子集,训练数据除去<strong>训练集</strong>外还存在<strong>验证集</strong>.(参考自:<ahref="https://zhuanlan.zhihu.com/p/115344944"><strong>知乎|训练集(trainingdataset), 测试集(test dataset)与验证集(validationdataset)</strong></a>)</p></blockquote></li><li><p><strong>假设(Hypothesis)&amp;真相/真实(Ground-Truth):</strong>学得模型对应了关于数据的某种潜在规律,因此亦称假设.这种潜在规律称为"真相"/"真实".学习的过程就是为了找出或逼近真相.</p><blockquote><p><strong>Tips:</strong> <ahref="https://en.wikipedia.org/wiki/Ground_truth"><strong>WIKIPEDIA|Ground-Truth</strong></a>又将其表述为<strong>基准真相</strong>.</p><p>"Ground truth is information that is known to be real or true,provided by direct observation and measurement (i.e. empirical evidence)as opposed to information provided by inference."</p></blockquote></li></ul><p><strong>Tips:</strong>本书有时又将<strong>模型</strong>称为<strong>学习器(Learner)</strong>,模型可看作是学习算法在给定数据和参数空间上的实例化.</p><ul><li><p><strong>标记(Label):</strong> 关于示例(Instance)结果的信息,称为标记(如"好瓜"). 一般的, 用 <span class="math inline">\((x_i,y_i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个样例, 其中<span class="math inline">\(y_i \in \mathcal{Y}\)</span> 是示例 <spanclass="math inline">\(x_i\)</span> 的标记, <spanclass="math inline">\(\mathcal{Y}\)</span> 是所有标记的集合,又称<strong>标记空间(Label Space)/输出空间</strong>.</p></li><li><p><strong>分类(Classification):</strong>若<strong>预测(Prediction)</strong>的是离散值(如"好瓜", "坏瓜"),则称此类学习任务是分类.</p></li><li><p><strong>回归(Regression):</strong> 若预测的是连续值(如成熟度0.95,0.7), 则称此类学习任务是回归.</p></li><li><p><strong>二分类(Binary Classification):</strong>只涉及两个类别的分类任务, 通常称其中一类为<strong>正类(PositiveClass)</strong>, 另一类为<strong>反类(Negative Class)</strong>.</p></li><li><p><strong>多分类(Multi-class Classification):</strong> 与之相对的,涉及多种类别的分类任务称为多分类任务.</p></li><li><p><strong>预测任务:</strong> 预测任务希望通过对训练集<spanclass="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m,y_m)\}\)</span> 进行学习, 建立一个从输入空间 <spanclass="math inline">\(\mathcal{X}\)</span> 到输出空间 <spanclass="math inline">\(\mathcal{Y}\)</span> 的映射 <spanclass="math inline">\(f : \mathcal{X} \rightarrow \mathcal{Y}\)</span>.对二分类, 通常取 <span class="math inline">\(\mathcal{Y} = \{-1,1\}\)</span> 或 <span class="math inline">\(\{0, 1\}\)</span>;对于多分类, <span class="math inline">\(|\mathcal{Y}| &gt; 2\)</span>;对于回归, <span class="math inline">\(\mathcal{Y} =\mathbb{R}\)</span>.</p></li><li><p><strong>测试(Testing):</strong>使用学习得到的模型进行预测的过程称为测试,预测的样本称为<strong>测试样本(Testing Sample)/测试示例(TestingInstance)</strong>.</p></li><li><p><strong>聚类(Clustering):</strong> 将训练集中的样本分为若干组,每组称为一个<strong>簇(Cluster)</strong>.</p><blockquote><p><strong>Tips:</strong> 形成的簇可能对应一些潜在的概念划分(如本地瓜,外地瓜), 但这样的概念我们事先不知道,否则通过标记(Label)就可以形成簇划分.</p></blockquote></li><li><p><strong>监督学习(Supervised Learning)/有导师学习:</strong>训练数据拥有标记信息, 分类和回归为代表.</p></li><li><p><strong>无监督学习(Unsupervised Learning)/无导师学习</strong>训练数据无标记信息, 聚类为代表.</p></li></ul><blockquote><p><strong>Tips:</strong> 此处仅作最基本的概念了解,关于上述两概念的具体释义留及之后的学习.</p></blockquote><ul><li><p><strong>泛化(Generalization):</strong>学得模型适用于新样本的能力,称为泛化能力.</p><blockquote><p><strong>Tips1:</strong> 样本空间通常很大, 训练过程无法涵盖所有的示例,我们希望模型可以对新样本有较好的目标表现, 这就是泛化的意义.</p><p><strong>Tips2:</strong> 泛化的数学支撑:</p><p>关于这种泛化,我们通常假设样本空间中的所有样本都服从一个未知的<strong>分布(Distribution)</strong><span class="math inline">\(\mathcal{D}\)</span>,获取的样本是从该分布上采样获得的, 满足<strong>独立同分布(Independent andIdentically Distributed, <em>i.d.d</em>)</strong>.</p><p>关于机器学习中为什么使用i.d.d, 可以从<ahref="https://www.zhihu.com/question/41222495"><strong>知乎|为什么机器学习中,要假设我们的数据是独立同分布的?</strong></a>获取相关信息.</p></blockquote></li></ul><h3 id="假设空间">$ 1.3 假设空间</h3><p><strong>归纳(Induction)</strong>与<strong>演绎(Deduction)</strong>是科学推理的两大基本手段.</p><blockquote><p>前者是从特殊到一般的<strong>泛化(Generalization)</strong>过程;后者是从一般到特殊的<strong>特化(Specialization)</strong>过程.</p></blockquote><ul><li><p><strong>归纳学习(Inductive Learning):</strong>广义的归纳学习大体相当于从样例中学习,狭义的归纳学习要求从学习过程中习得<strong>概念(concept)</strong>,亦称<strong>概念学习/概念形成</strong>.</p></li><li><p><strong>版本空间(Version Space):</strong>存在一个与训练集一致的"假设集合", 称为版本空间, 例如:</p></li></ul><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/table1-1.png" class="" title="table1-1"><p>其假设空间为</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-1.png" class="" title="pic1-1"><p>其版本空间为</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-2.png" class="" title="pic1-2"><blockquote><p><strong>Tips:</strong> 在该数据集中, 好瓜具有的共同特征是蜷缩和浊响.因此色泽标识为通配符 <span class="math inline">\(*\)</span>, 同时,第一行的两种假设同样是与训练集一致的(可以匹配好瓜).</p></blockquote><h3 id="归纳偏好">$ 1.4 归纳偏好</h3><ul><li><p><strong>归纳偏好(Inductive bias):</strong>算法在学习过程中对某种类型假设的偏好称为归纳偏好.</p><blockquote><p><strong>Tips:</strong><strong>任何</strong>一个有效的机器学习算法必有其归纳偏好,否则它无法产生确定的学习结果.</p><p>以图1-2的版本空间为例, 对新瓜(色泽=青绿;根蒂=蜷缩;敲声=沉闷),若模型告诉我们这种瓜时好时坏则没有意义,模型必须对给定的样本给予确定的结果.</p><p><strong>Additional:</strong>归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或"价值观".常遵循<strong>奥卡姆剃刀(Occam'sRazor)</strong>原则(<strong>若有多个假设与观察一致,则选简单的那个</strong>).</p></blockquote></li></ul><p>接下来我们来比较不同归纳偏好的优劣</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-3.png" class="" title="pic1-3"><p>从直观上看我们一般会认为, 拟合出平滑的曲线A要优于曲线B, 但很遗憾,当面临一些极端数据时, 曲线B可能会优于曲线A, 情形如下图所示.</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-4.png" class="" title="pic1-4"><p>接下来我们用数学语言尝试量化模型的优劣.</p><p>假设样本空间 <span class="math inline">\(\mathcal{X}\)</span>和假设空间 <span class="math inline">\(\mathcal{H}\)</span> 都是离散的,令 <span class="math inline">\(P(h|X, \mathfrak{L})\)</span>代表学习算法 <span class="math inline">\(\mathfrak{L}_a\)</span>基于训练数据 <span class="math inline">\(X\)</span> 产生假设 <spanclass="math inline">\(h\)</span> 的概率, 令 <spanclass="math inline">\(f\)</span> 为目标函数.则 <spanclass="math inline">\(\mathfrak{L}_a\)</span>在训练集外的所有样本上的误差为</p><p><span class="math display">\[\begin{equation} \label{eq1.1}E_{ote}(\mathfrak{L}_a|X, f) = \sum_h \sum_{x \in \mathcal{X} -X} P(x)\mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\tag{1.1}\end{equation}\]</span></p><blockquote><p><strong>Tips:</strong>以下是笔者个人对该公式的理解,可能存在疏漏或错误.</p><p>首先看乘起来的的三个式子, <spanclass="math inline">\(\mathbb{I}\)</span> 为指示函数, 代表的含义是假设<span class="math inline">\(h\)</span> 与目标函数 <spanclass="math inline">\(f\)</span> 没有误差时取0, 存在误差时取1. 若取1,则两个概率乘积表示在给定的<span class="math inline">\(x\)</span>和<spanclass="math inline">\(h\)</span>下, 存在误差的概率.</p><p>接下来的两个求和就不难理解了, 分别是对<spanclass="math inline">\(x\)</span>的所有取值求和以及对<spanclass="math inline">\(h\)</span>的所有取值求和, 权重为特定<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(h\)</span>的概率.</p></blockquote><p>为简化问题, 考虑二分类, 真实目标函数<spanclass="math inline">\(f\)</span>可以是任何函数<spanclass="math inline">\(\mathcal{X} \rightarrow \{0,1\}\)</span>,函数空间<span class="math inline">\(\{0,1\}^{|\mathcal{X}|}\)</span>.对所有可能的<spanclass="math inline">\(f\)</span>按均匀分布对误差求和,有</p><p><span class="math display">\[\begin{align} \nonumber\sum_f E_{ote}(\mathfrak{L}_a|x, f) &amp;= \sum_f \sum_h \sum_{x \in\mathcal{X} -X} P(x) \mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\\\nonumber&amp;= \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)\sum_f \mathbb{I}(h(x) \neq f(x))\\ \nonumber^*&amp;=  \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)\frac{1}{2}2^{|\mathcal{X}|}\\ \nonumber&amp;= \frac{1}{2}2^{|\mathcal{X}|} \sum_{x \in \mathcal{X} -X} P(x)\cdot 1 \tag{1.2}\end{align}\]</span></p><blockquote><p><strong>Tips:</strong> 标识<spanclass="math inline">\(*\)</span>的一步因为若<spanclass="math inline">\(f\)</span>均匀分布, 则有一半的<spanclass="math inline">\(f\)</span>对<spanclass="math inline">\(x\)</span>的预测与<spanclass="math inline">\(h(x)\)</span>不一致.</p></blockquote><p>式(1.2)指出, 误差与学习算法<spanclass="math inline">\(\mathfrak{L}\)</span>无关! 对于任意学习算法<spanclass="math inline">\(\mathfrak{L}_a\)</span>和<spanclass="math inline">\(mathfrak{L}_b\)</span>,有</p><p><span class="math display">\[\begin{equation}\sum_f E_{ote}(\mathfrak{L}_a|X, f) = \sum_f E_{ote}(\mathfrak{L}_b|X,f) \tag{1.3}\end{equation}\]</span></p><p>这简直糟糕透了, 似乎所有的学习算法期望性能居然都相同.这就是<strong>没有免费午餐定理(No Free Lunch Theorem, NFL)</strong>.</p><blockquote><p><strong>Tips:</strong> 原书的证明是多重假设下的简化论述,对严格数学证明感兴趣的读者可以自行查阅相关资料.</p></blockquote><p>但是, NFL定理有一个重要前提, 它假定了所有问题出现的机会相等,所有问题同等重要(例如上述证明中假设了<spanclass="math inline">\(f\)</span>均匀分布).但我们并不要求模型对所有情况都能给出一个好的解决方案,往往我们希望模型对特定问题表现是好的.</p><blockquote><p><strong>Tips:</strong> 原书中举了一个简单的例子,骑自行车从南京鼓楼到南京新街口显然是好方案(距离约两站地铁),但骑自行车从南京鼓楼到北京新街口, 显然不是好的方案,但我们不care.</p></blockquote><p>简单来说,NFL定理指出了<strong>没有一种机器学习算法是适用于所有情况的</strong>,只有针对具体问题, 才能谈论模型的优劣.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;机器学习所研究的主要内容,
是关于在计算机上从数据中产生&quot;模型&quot;(model)的算法, 即&quot;学习算法&quot;(learning
algorithm).&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记-机器学习" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="机器学习" scheme="http://la-pluma.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-大话设计模式 Ch0</title>
    <link href="http://la-pluma.github.io/2024/09/10/BookNote-DesignPatterns-by-JieCheng-1/"/>
    <id>http://la-pluma.github.io/2024/09/10/BookNote-DesignPatterns-by-JieCheng-1/</id>
    <published>2024-09-10T11:45:47.000Z</published>
    <updated>2024-10-30T11:51:03.462Z</updated>
    
    <content type="html"><![CDATA[<p><strong>精彩的代码是如何想出来的,要比看到精彩的代码更加令人期待.</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter-0-preview-面向对象基础">Chapter 0: Preview面向对象基础</a></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>《大话设计模式》程杰 2007.</p><p>本文<strong><em>不提供</em></strong>书籍的电子版文件,请有需要的读者移步至<strong>Z-library</strong>或其他渠道获得.</p><p>本书以情景对话形式, 辅以故事或例子介绍设计模式, 以C#语言书写代码,适合有面向过程编程基础但面向对象编程能力弱的初学者.</p><h2 id="chapter-0-preview-面向对象基础">Chapter 0: Preview面向对象基础</h2><blockquote><p>附录A 培训实习生——面向对象基础</p><p><strong>Tips:</strong> 本部分不设计具体的语法细节, 特性和原理,仅作示例, 如有需去可移步至专业书籍文献寻求细节, 如<ahref="https://learn.microsoft.com/en-us/dotnet/csharp/"><strong>微软官方</strong></a>或书籍<ahref="https://book.douban.com/subject/34894447/"><strong>C#图解教程</strong></a>.</p></blockquote><ul><li><p><strong>对象(Object):</strong> 对象是一个自包含的实体,用一组可识别的特性和行为来标识.</p><blockquote><p><strong>Tips:</strong> 定义比较拗口, 通俗来说, 对象是对事物的抽象,一切事物都可以称为对象.</p></blockquote></li><li><p><strong>面向对象编程(Object-Oriented Programming):</strong>面向对象的编程.</p><blockquote><p><strong>Tips:</strong> 简称OOP, 区别于面向过程编程,面向过程需要分析得出步骤, 按序实现程序功能. OOP首先对事物抽象为"对象",用对象的属性和行为解决问题.</p></blockquote></li><li><p><strong>类(Class):</strong>具有相同属性和功能对象的抽象集合.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">shout</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mew&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实例(Instance) &amp; 实例化:</strong> 实例是真实的对象,new得到实例的过程称为实例化.</p><blockquote><p><strong>Tips:</strong> 类就像是工厂的蓝图, 实例就是生产出来的产品,一个类只有实例化后才可以调用(可能不严谨, 存疑), 和蓝图与产品一样,一个类可以实例化出多个不同的实例(<strong>学生类</strong>可以实例化为<strong>学生李华</strong>,<strong>学生张三</strong>等).</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><ul><li><p><strong>修饰符:</strong></p><ul><li><p><strong>public:</strong> 修饰的类成员允许被任何类访问</p></li><li><p><strong>protected:</strong>修饰的类成员仅允许该类和其子类访问</p></li><li><p><strong>private:</strong> 修饰的类成员仅允许该类访问</p><blockquote><p><strong>Tips:</strong> 程序设计是一门权衡和妥协的艺术,对OOP为何如此设计的读者可自行查阅OOP发展的历史.</p></blockquote></li></ul></li><li><p><strong>属性:</strong> 属性是一个方法或一对方法,在调用它的代码看来, 它是一个字段,即属性适合于以字段的方法使用方法调用的场合.</p></li><li><p><strong>字段:</strong> 储存类设计所需的数据,形式上是与类相关的变量.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> num; <span class="comment">//声明一个私有内部字段, 修饰符private</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Num &#123; <span class="comment">//Num公有外部属性, 修饰符public</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="comment">//外部读取方法</span></span><br><span class="line">            <span class="keyword">return</span> Num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="comment">//外部修改方法, 删去此方法时表示Num是只读的.</span></span><br><span class="line">            Num = <span class="keyword">value</span>; <span class="comment">// set含有隐式参数, 由关键字value表示, 用于赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 属性和字段的描述比较抽象,推荐直接结合代码理解. 笔者认为是一种语法糖上的tricky,在其他语言OOP也有相似的写法. 这种写法的好处是隔离内部与外部,仅允许类提供的公共方法访问类内成员变量.</p></blockquote><ul><li><p><strong>构造方法/构造函数:</strong> 对类进行初始化的方法.与类同名, 无返回值, 不需要void, 在new中调用.</p><blockquote><p><strong>Tips:</strong> 以上语法细节适用于C#, 非C#可能会有差别,类中不显示写明构造函数时由编译器默认构造(更多语法细节和原理请移步至讨论C#的相关文献).</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123; <span class="comment">//这是构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>重载(overload):</strong>提供了创建多个同名方法(Function)的功能, 重载方法的参数类型不同.重载可以在不改变原方法基础上添加新功能.</p><blockquote><p><strong>Tips:</strong>这里<strong>参数类型的不同</strong>指的是参数个数不同或参数类型的不同(详见代码示例)</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="comment">//不仅构造函数, 普通函数也可以重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>()</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1, <span class="built_in">float</span> arg_2</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1, <span class="built_in">int</span> arg_2</span>)</span>&#123;&#125;;<span class="comment">//类型顺序不同也会被认为是重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>封装:</strong> 每个对象包含该对象操作所需的所有信息,不必依赖其他对象来完成自己的操作, 该特性称为封装.</p><blockquote><p><strong>Addtional:</strong> 良好的封装可以减少耦合,类内部实现可以自由修改, 具有清晰的对外接口</p></blockquote></li><li><p><strong>继承:</strong>对象的继承代表了一种"<strong>is-a</strong>"关系, 若描述为"B是A",则认为B可以继承A. 又可以理解为B是A的一种特殊化, B拥有A的特性之外,还拥有自己独特的特性. 即继承代表了一种包含关系, A包含B.</p><blockquote><strong>Addtional:</strong><ul><li>继承的双方称为<strong>子类/派生类&amp;父类/基类</strong>.</li><li>子类继承父类的成员有方法, 域, 属性, 事件, 索引指示器</li><li>构造方法<strong>无法</strong>继承, 只能调用,可以使用<strong>base</strong>关键字(C#语法特性)</li></ul></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>()</span> &#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;unamed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> shoutNum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ShoutNum &#123; <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> shoutNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            shoutNum = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Cat</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;mew &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Dog</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;woof &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong>继承的<strong>优点</strong>是使子类公共部分放在了父类, 代码得到了共享,减少了代码重复, 修改和扩展都变得相对容易.但<strong>缺点</strong>也是显而易见的, 继承会破坏封装,父类实现的细节暴露给子类, 父类和子类间是强耦合的.</p></blockquote><ul><li><p><strong>多态:</strong> 多态表示不同的对象可以执行相同的动作,但通过自己的代码执行.</p><blockquote><strong>Additional:</strong><ul><li>子类以父类身份出现</li><li>子类工作时以自己的方式实现</li><li>子类以父类身份出现时, 无法使用子类特有的属性和方法</li></ul><p><strong>Tips:</strong> 在父类中, 该动作需要声明为虚拟的,用关键字<strong>virtual</strong>标识.</p></blockquote></li><li><p><strong>重写/覆写(override):</strong>子类使用关键字<strong>override</strong>将父类实现替换为自己的实现.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//声明为虚方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*执行环境*/</span></span><br><span class="line"></span><br><span class="line">arrayAnimal = <span class="keyword">new</span> Animal[<span class="number">5</span>];</span><br><span class="line">arrayAnimal[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line">arrayAnimal[<span class="number">1</span>] = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">foreach</span>(Animal item <span class="keyword">in</span> arrayAnimal)&#123;</span><br><span class="line">    MessageBox.Show(item.Shout()); <span class="comment">//Cat为&quot;mew&quot;, Dog为&quot;woof&quot;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips1:</strong> C#的多态性分为静态多态性和动态多态性.静态多态性即为前文提到的overload重载, 在编译时确定;动态多态性为override覆写, 在运行时确定,通过抽象类(见下文)和虚方法实现.</p><p><strong>Tips2:</strong> 笔者在翻阅相关资料时,在C++语言中发现了更为复杂的机制, overwrite重写和override覆写存在区别,详见<ahref="https://www.cnblogs.com/kuliuheng/p/4107012.html"><strong>博客园|C++中的Overload、Override和Overwrite</strong></a></p><p><strong>Addtional:</strong> 原书对上述实现Animal Shout的代码进行重构,具体方法为将Shout()声明为父类公共方法(去掉virtual),声明新的虚方法getSound(), 在Shout()中调用, 在子类中覆写(override),从而避免了代码重复, 此处笔者不再浪费篇幅详细赘述.</p></blockquote><ul><li><p><strong>抽象类&amp;抽象方法:</strong>C#允许将类和方法用关键字<strong>abstract</strong>声明, 即抽象类,抽象方法.</p><blockquote><strong>Addtional:</strong><ul><li>抽象类不能被实例化</li><li>抽象方法必须被子类覆写(override)</li><li>含有抽象方法的类必须声明为抽象类, 不论是否具有一般方法</li><li>使用时考虑让抽象类拥有尽可能多的共同代码, 拥有尽可能少的数据</li></ul><p><strong>Tips:</strong> 抽象类通常代表一种抽象概念,提供了一个继承的出发点, 当设计一个新的抽象类时, 一定是用来继承的.因此在继承结构中, 叶节点应当是具体类, 非叶节点应当是抽象类.</p></blockquote></li><li><p><strong>接口(Interface):</strong>接口是把隐式公共方法和属性组合起来, 以封装特定功能的一个集合.类实现了接口就可以支持接口所指定的所有属性和成员.接口不允许提供任何成员的执行方法(因此接口不能实例化, 没有构造方法,字段和修饰符, 不能声明静态或虚拟等).</p><blockquote><strong>Addtionnal:</strong><ul><li>实现接口的类必须实现接口中所有方法和属性.</li><li>一个类可以支持多个接口, 不同类也可以支持相同接口.</li></ul><p><strong>Tips:</strong> <ahref="https://www.runoob.com/csharp/csharp-interface.html">菜鸟教程|C#Interface</a>将接口表述为:</p><p>接口定义了所有类继承接口时应遵循的语法合同.接口定义了语法合同"是什么"部分, 派生类定义了语法合同"怎么做"部分.接口定义了属性, 方法和事件, 这些都是接口的成员. 接口只包含了成员的声明.成员的定义是派生类的责任. 接口提供了派生类应遵循的标准结构.</p><p><strong>书写规范:</strong> 接口的命名需要在前面加一个大写"I".</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 笔者在此化简了书目中提供的例子, 能理解即可.</span></span><br><span class="line"><span class="comment">// 叮当猫继承自上文出现的Cat类, 内部需要实现变东西的接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MachineCat</span> : <span class="title">Cat</span>, <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>&#123; <span class="comment">//实现接口, 不需要使用override修饰</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.Shout() + <span class="string">&quot;我有万能口袋, 可以变出: &quot;</span> + thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Additional:</strong> 笔者在此补充一点C#的语法特性,接口也可以继承接口, 假设IB继承IA, 在IB中不需要声明IA中的声明,但实现IB的类需要实现IA和IB中的所有声明.</p><p><strong>Compare: Class v.s. Interface</strong></p><ul><li><strong>语法上:</strong> 抽象类可以给出一些成员的实现,接口不能包含成员的实现, 抽象类的抽象成员可被子类部分实现,但接口的成员需要类全部实现, 一个类只能继承<strong>一个</strong>抽象类,但可以实现<strong>多个</strong>接口.</li><li><strong>含义上:</strong> 类是对象的抽象, 抽象类是对类的抽象,接口是对<strong>行为</strong>的抽象.</li><li><strong>使用上:</strong> 如果行为跨越不同类的对象, 可使用接口;对于一些相似的类对象, 用继承抽象类. 需要注意的是,实现接口和继承抽象类并不冲突.</li><li><strong>设计角度上:</strong> 抽象类是从子类中发现了公共的东西,泛化出父类, 然后子类继承父类, 而接口根本不知道子类的存在,方法如何实现不明确, 预先定义.</li></ul></blockquote><ul><li><p><strong>泛型(Generic):</strong> 泛型是具有占位符(类型参数)的类,结构, 接口和方法, 这些占位符是类, 结构,接口和方法所储存域或使用的一个或多个类型的占位符.泛型集合类可以将类型参数用作它所存储的对象的类型的占位符:类型参数作为其字段的类型和其方法的参数类型出现.</p><blockquote><p><strong>Additional:</strong> 通常情况下, 都建议使用泛型集合,因为这样可以获得类型安全的直接优点而不需要从基集合类型派生并实现类型特定成员.此外, 如果集合元素为值类型,泛型集合类型的性能通常优于对应的非泛型集合类型,因为使用泛型时不必对元素进行装箱.</p><p><strong>Tips:</strong> <ahref="https://www.runoob.com/csharp/csharp-generic.html">菜鸟教程|C#Generic</a>将泛型表述为:</p><p>泛型(Generic)允许您延迟编写类或方法中的编程元素的数据类型的规范,直到实际在程序中使用它的时候. 换句话说,泛型允许您编写一个可以与任何数据类型一起工作的类或方法.</p><p>泛型的定义较为晦涩, 建议结合代码理解.笔者在此强烈建议阅读更多的资料来学习泛型.</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic; <span class="comment">//增加泛型集合命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Forml</span> : <span class="title">Form</span>&#123;</span><br><span class="line">    IList&lt;Animal&gt; arrayAnimal; <span class="comment">// 声明泛型集合变量, 表示只接受Animal类型</span></span><br><span class="line">    <span class="comment">//List&lt;Animal&gt; arrayAnimal; 两种写法是等价的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Event</span>()</span>&#123;</span><br><span class="line">        arrayAnimal = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Cat());</span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Dog());</span><br><span class="line">        arrayAnimal.Add(<span class="number">123</span>); <span class="comment">// Error! Invalid Type </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>委托:</strong> 委托是对函数的封装,可以当作给方法的特征指定一个名称.委托对象用关键字<strong>delegate</strong>声明.</p></li><li><p><strong>事件:</strong> 事件时委托的一种特殊形式,当发生有意义的事情时, 事件对象处理通知过程.事件对象用关键字<strong>event</strong>声明.</p></li></ul><blockquote><p><strong>Additional:</strong> 委托是一种引用方法的类型,一旦为委托分配了方法, 委托将与该方法具有完全相同的行为.事件则是在发生其他类或对象关注的事情时, 类或对象可通过事件通知它们.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情境: 猫Tom叫的时候两只老鼠Jerry和Jack要跑.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>()</span>; <span class="comment">// 声明委托</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout; <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span> (CatShout != <span class="literal">null</span>)&#123; <span class="comment">// 如果声明了事件CatShout</span></span><br><span class="line">            CatShout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫来了, &#123;0&#125;快跑&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    Mouse mouse1 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    Mouse mouse2 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse1.Run);</span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse2.Run); </span><br><span class="line">    <span class="comment">// &quot;+=&quot; 表示 &quot;add_CatShout&quot; 的意思; 与之相反 &quot;-=&quot; 表示 &quot;remove_CatShout()&quot;</span></span><br><span class="line"></span><br><span class="line">    cat.Shout();</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫来了, Jerry快跑!</span><br><span class="line">老猫来了, Jack快跑!</span><br></pre></td></tr></table></figure><ul><li><strong>EventArgs:</strong> EventArgs是包含事件数据的类的基类.</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CatShoutEventArgs</span> : <span class="title">EventArgs</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span>(CatShout != <span class="literal">null</span>)&#123;</span><br><span class="line">            CatShoutEventArgs e = <span class="keyword">new</span> CatShoutEventArgs();</span><br><span class="line">            e.Name = <span class="keyword">this</span>.name;</span><br><span class="line">            CatShout(<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫&#123;0&#125;来了, &#123;1&#125;快跑!&quot;</span>, args.Name, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main执行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫Tom来了, Jerry快跑!</span><br><span class="line">老猫Tom来了, Jack快跑!</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;精彩的代码是如何想出来的,
要比看到精彩的代码更加令人期待.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记-设计模式" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://la-pluma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>千里之行，始于足下</title>
    <link href="http://la-pluma.github.io/2024/09/08/hello-world/"/>
    <id>http://la-pluma.github.io/2024/09/08/hello-world/</id>
    <published>2024-09-08T12:56:57.000Z</published>
    <updated>2024-09-12T15:49:07.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong>A journey of a thousand miles begins with a singlestep.</strong></p><span id="more"></span><img src="/2024/09/08/hello-world/picture.png" class="" title="picture">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;A journey of a thousand miles begins with a single
step.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
