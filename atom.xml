<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LaPluma</title>
  
  <subtitle>Keep it simple and stupid.</subtitle>
  <link href="http://la-pluma.github.io/atom.xml" rel="self"/>
  
  <link href="http://la-pluma.github.io/"/>
  <updated>2024-10-28T16:44:03.975Z</updated>
  <id>http://la-pluma.github.io/</id>
  
  <author>
    <name>LaPluma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NJU静态分析|A2-Constant Propagation</title>
    <link href="http://la-pluma.github.io/2024/10/28/SPA-A2/"/>
    <id>http://la-pluma.github.io/2024/10/28/SPA-A2/</id>
    <published>2024-10-28T12:59:35.000Z</published>
    <updated>2024-10-28T16:44:03.975Z</updated>
    
    <content type="html"><![CDATA[<p>NJU Static Program Analysis | Assignment-2 Constant Propagation &amp;WorlistSolver</p><span id="more"></span><h2 id="实验信息与食用指南">实验信息与食用指南</h2><p>请翻阅<ahref="https://la-pluma.github.io/2024/10/20/SPA-A1/#more"><strong>[NJU静态分析|A1-LiveVariable Analysis]</strong></a>.</p><p>在此进行一点补充, 笔者的这份实验记录更像是FreeStyle版的<strong>FAQ</strong>. 因此请 <strong><em>确保</em></strong>在理解了<strong>理论知识</strong>, <strong>实验指南</strong> 和<strong>框架代码</strong> 后再参考本记录, 与A1相同, 本记录<strong><em>不提供</em></strong> 源代码(<del>或者说暂时没有</del>).</p><p><del>如果您对本实验记录中的内容感到困惑,可能是因为笔者能力不足或您未能理解实验指南和框架代码,同时本试验记录难以涵盖所有的坑, 还望海涵.</del></p><h2 id="实验目标">实验目标</h2><p>基于<strong>Tai-e</strong>框架实现<strong>常量传播算法</strong>和<strong>worklist求解器</strong>.</p><p>大致的框架代码如下:</p><img src="/2024/10/28/SPA-A2/pic1.png" class="" title="pic1"><p>注意常量传播算法是<strong>Forward &amp; Must analysis</strong>.</p><h2 id="部分重要框架代码带读">部分重要框架代码带读</h2><p><del>我知道你们有些人肯定是不看框架代码的,除非不得不用或者报错的时候.</del></p><h3 id="ir-irbuilder">IR &amp; IRBuilder</h3><p>Tai-e框架中的<code>IR</code>与课上教授的IR稍有不同, 以A2test中的<strong>Assign.java</strong>为例,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   From A2 test/Assign.java   */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assign</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">        x = <span class="number">4</span>;</span><br><span class="line">        y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过tai-e框架的分析后会得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> &lt;init&gt;()&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L1</span>] invokespecial %<span class="built_in">this</span>.&lt;java.lang.Object: <span class="keyword">void</span> &lt;init&gt;()&gt;(); &#123;&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L1</span>] <span class="keyword">return</span>; &#123;&#125;</span><br><span class="line"></span><br><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span>&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;   &#123;x=<span class="number">1</span>&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] x = <span class="number">2</span>;   &#123;x=<span class="number">2</span>&#125;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] x = <span class="number">3</span>;   &#123;x=<span class="number">3</span>&#125;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">4</span>;   &#123;x=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L8</span>] y = x;   &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] <span class="keyword">return</span>;  &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合<strong>IR</strong> &amp; <strong>IRBuilder</strong>(可翻阅<ahref="https://tai-e.pascal-lab.net/docs/index.html"><strong>[官方手册]</strong></a>),</p><img src="/2024/10/28/SPA-A2/pic2.png" class="" title="pic2"><p><del>IR我懒得贴了</del></p><p><code>IR</code>的基本单元是<strong>method</strong>(请意识到java是oop语言),<code>IRBuilder</code>提供了分析单个方法的API<code>buildIR(JMethod method)</code>和分析整个<code>class hierarchy</code>(不明白,等到A4就明白了, 笑)中的所有方法的API<code>buildAll()</code></p><p>结合<code>Stmt</code> <code>Exp</code> 和 <code>CFG</code>,我们可以得到这样的一个示意图(由于笔者未阅读全部的源码实现,可能会有所出入, 但大致如此).</p><img src="/2024/10/28/SPA-A2/pic3.png" class="" title="pic3"><blockquote><p><strong>Tips:</strong>严格来说<code>CFG</code>并不存储<code>Node</code>(本实验中指<code>Stmt</code>,见A1试验记录说明), 只存储<code>Stmt</code>的关联信息,但为了方便图示遂如此展示. 至于为何左值和右值都是<code>Exp</code>,请翻阅A1官方实验指南中对<code>Exp</code>的图示表示部分.</p></blockquote><h3 id="definitionstmt">DefinitionStmt</h3><p>尽管理论上不需要这个类也可以完成实验(<code>Stmt</code>中的顶层方法足以实现),但既然框架提供了这么好用的API, 方便我们写出更优雅的代码,为什么不用呢?</p><img src="/2024/10/28/SPA-A2/pic4.png" class="" title="pic4.png"><p><code>DefinitionStmt</code>为我们提供了两个非常好用的API,<code>getLValue()</code>和<code>getRValue</code>可以直接获取到左右式的<code>Exp</code>(希望你还记得<code>LValue</code>&amp;<code>RValue</code>extends <code>Exp</code>),而不需要像<code>Stmt</code>中的<code>getDef()</code> &amp;<code>getUses()</code>做较为繁琐的判断和筛选(如果对<code>getUses()</code>感到困惑,也还请翻阅A1实验记录, 里面有解释和参考来源).</p><p>需要注意的是,<code>getLValue()</code>可能会返回<code>null</code>.</p><h2 id="constantpropagation">ConstantPropagation</h2><p>与活跃变量分析类似, 我们需要完成5个API的功能.</p><h3 id="newboundaryfact-newinitialfact">newBoundaryFact() &amp;newInitialFact()</h3><p>需要注意的是, 本次存储分析结果的数据结构是<code>CPFact</code>,与A1相同, 在完成本次实验代码之前需要了解相关API的用法.</p><p>既然是<strong>Must Analysis</strong>, 我们需要将初值赋为空,但需要注意的是, 我们的<strong>Analysis</strong>仅分析语句,在进入第一条语句之前, 是否有什么东西需要初始化?</p><p>这个问题就对应了指南中为什么<code>BoundaryInit</code> 要通过<code>getIR().getParas()</code>获取参数并赋值<code>NAC</code>的提示.</p><p>在对<code>IR</code>的解释中我们提到过,<code>IR</code>的基本分析单元是<strong>method</strong>, 即函数,函数就可能有传入的参数, 这些参数易见<strong>不是Constant</strong>,因此要赋值为<code>NAC</code></p><blockquote><p><strong>Tips:</strong> 如果是Constant干嘛还要传参, 即便真的这么做了,我们的分析也可以满足<strong>safe-approximation</strong>.</p></blockquote><p>这部分是在方法体(函数语句)执行前就完成的初始化,因此我们需要赋值给<code>Entry</code>的<code>outFact</code>.</p><h3 id="meetvalue-meetinto">meetValue() &amp; meetInto()</h3><p><code>meetValue()</code>的完成没有任何难点,只需要照抄ppt中的规则即可.</p><img src="/2024/10/28/SPA-A2/pic5.png" class="" title="pic5"><p>同样的,完成这部分代码需要阅读<code>Class Value</code>的源码API和注释.</p><p>关于<code>meetInto()</code>,如果没有阅读<code>CPFact</code>中的<code>update()</code>方法注释,就不知道可以写出如此优雅的代码来合并<code>Var</code>的<code>Value</code>值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.update(<span class="keyword">var</span>, meetValue(fact.get(<span class="keyword">var</span>), target.get(<span class="keyword">var</span>)));</span><br></pre></td></tr></table></figure><img src="/2024/10/28/SPA-A2/pic6.png" class="" title="pic6"><h3 id="transfernode-evaluate">transferNode() &amp; evaluate()</h3><p>毫无疑问, 这是本次实验中最难最核心的一部分, 细节非常多, 当被卡hiddentest的时候, 大概率寄在这里.</p><p>笔者建议在<code>transferNode()</code>中处理<code>Stmt</code>的左值def部分,在<code>evaluate()</code>中处理右值exp部分. 这是比较符合功能分离的写法,当然, 也可以选择在<code>transferNode()</code>中处理<code>Var</code>和<code>IntLiteral</code>,<code>evaluate()</code>只负责处理<code>BinaryExp</code>的计算值.笔者在此按第一种写法进行说明.</p><h4 id="transfernode">transferNode()</h4><p>这个函数中你需要依次做(次流程可能存在可以优化的部分,不必完全照做):</p><ul><li><p>保存<code>outFact</code>原值,将<code>inFact</code>赋值给<code>outFact</code>.</p></li><li><p>判断<code>Node</code>(<code>Stmt</code>)是否为<code>DefinitionStmt</code></p></li><li><p>判断是否拥有<strong>合法</strong>左值,包括<code>def</code>的类型<code>Var</code>和<code>Var</code>中的<code>ValueType</code>是否为<code>Int</code>,如果不是, 本次实验中可以认为是<code>nop</code>空操作.不需要为这个<code>Stmt</code>做任何分析, 直接将<code>inFact</code>copy给 <code>outFact</code>即可.</p><blockquote><p><strong>Tips:</strong> IDEA教给我一个很有意思的语法糖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> DefinitionStmt def_stmt)&#123;</span><br><span class="line">    <span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> def_stmt.getLValue();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用法可以避开繁琐的类型转化, 在判断类型时便做了类型转化.</p></blockquote></li><li><p>计算<code>Stmt</code>的右值(通过<code>evaluate()</code>获得),并更新<code>outFact</code>中的相应<code>Var def</code>(笔者在此并未使用<code>update</code>方法的返回值,或许可从此处入手优化效率, 但笔者不能保证其正确性)</p></li><li><p>比较<code>outFact</code>是否更新返回布尔值.</p></li></ul><h4 id="evaluate">evaluate()</h4><p>为了完成这个方法, 代码的大致框架应该是这个样子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Value <span class="title function_">evaluate</span><span class="params">(Exp exp, CPFact in)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> Var)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*Value*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> IntLiteral)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*Value*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> BinaryExp binary_exp)&#123;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">right</span> <span class="operator">=</span> ...;</span><br><span class="line">        <span class="comment">// Operand may not Int or may not Constant</span></span><br><span class="line">        <span class="comment">// you&#x27;d better do it first</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*left HoldInt &amp;&amp; right HoldInt*/</span>)&#123;</span><br><span class="line">            <span class="comment">//you can get Condition Info form ppt</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*left is Constant &amp;&amp; right is constant*/</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (binary_exp <span class="keyword">instanceof</span> ArithmeticExp arithmetic_exp)&#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="comment">//also should attention to DIV 0 return Undef</span></span><br><span class="line">                        <span class="keyword">case</span> ADD: ...</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binary_exp <span class="keyword">instanceof</span> BitwiseExp bitwise_exp)&#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="keyword">case</span> AND: ...</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(...)</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*left is NAC || right is NAC*/</span>)&#123;</span><br><span class="line">                <span class="comment">//you should do DIV &amp; REM for 0 judgement there</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*other condition*/</span>)&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*other condition*/</span>)&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for over-approximation</span></span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//such as x = o.f()</span></span><br><span class="line">    <span class="comment">//for over-approximation</span></span><br><span class="line">    <span class="keyword">return</span> Value.getNAC(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中二元表达式计算规则见ppt所示,</p><img src="/2024/10/28/SPA-A2/pic7.png" class="" title="pic7"><p>笔者在此给出一些细节和边界条件,也可以通过阅读上述代码框架获得细节提示:</p><ul><li><p><code>exp</code>中的操作数可能不是<code>IntType</code>,所以你需要做一个<code>canHoldInt()</code>判断,非法<code>exp</code>为了安全性应赋值为<code>NAC</code></p></li><li><p>实验指南中提到, 对于<code>/</code>和<code>%</code>的除零错误,应当给出<code>Undef</code>,<strong>即使</strong>被除数是<code>NAC</code>.</p></li></ul><h2 id="sovler-worklistsolver">Sovler &amp; WorkListSolver</h2><h3 id="sovler-init">Sovler Init</h3><p>照着算法流程前三行写便是,但这里要提到框架代码的"<strong>robustness</strong>".</p><p>尽管从分析流程上来看, 我们不应该分析<code>Node Entry</code>,但是框架代码允许我们这样做.这时框架代码会认为<code>Node Entry</code>是一条<code>nop Stmt</code>,不会做constant update,因此只要在<code>Init</code>部分对<code>Entry</code>的<code>inFact</code>和<code>outFact</code>都赋上初值,就不需要在worklist中考虑<code>Entry</code>的处理了.</p><h3 id="worklistsolver-dosolveforward">WorkListSolverdoSolveForward</h3><p><strong>worklist</strong>是一种非常简单的算法,笔者在此不对算法实现过多赘述.注意在实现worklist的时候可以使用java自带的容器<code>Queue</code> &amp;<code>ArrayList</code>.</p><p>关于<strong>worklist</strong>的初始化问题,需要注意的是应当为其加入所有的<code>Node</code>,如果只加入<code>Entry</code>的后继, 会产生问题, 笔者在此给出一个例子.(感谢课程群中<ahref="https://github.com/rijuyuezhu"><strong>日居月诸</strong></a>大佬和另一位不知道github链接的大佬构造的反例)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span>&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] nop;     &#123;&#125;</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;   &#123;x=<span class="number">1</span>&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] x = <span class="number">2</span>;   &#123;x=<span class="number">2</span>&#125;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] x = <span class="number">3</span>;   &#123;x=<span class="number">3</span>&#125;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">4</span>;   &#123;x=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L8</span>] y = x;   &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] <span class="keyword">return</span>;  &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中,<code>Entry outFact</code>初始化为<code>&#123;&#125;</code>(没有参数),然而<code>Stmt0</code> 的 <code>outFact</code>同样初始化为<code>&#123;&#125;</code>,如果只添加<code>Entry</code>的后继<code>&#123;Stmt0&#125;</code>,会导致worklist在分析完<code>Stmt0</code>后错误终止.</p><h2 id="总结">总结</h2><p>本次实验应该是所有Assignment中代码量最多的一次, 细节也是让人头皮发麻,还望能静下心来看代码和debug, 祝早日AC!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NJU Static Program Analysis | Assignment-2 Constant Propagation &amp;amp;
WorlistSolver&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态分析|A1-Live Variable Analysis</title>
    <link href="http://la-pluma.github.io/2024/10/20/SPA-A1/"/>
    <id>http://la-pluma.github.io/2024/10/20/SPA-A1/</id>
    <published>2024-10-19T16:04:07.000Z</published>
    <updated>2024-10-28T16:43:37.017Z</updated>
    
    <content type="html"><![CDATA[<p>NJU Static Program Analysis | Assignment-1 Live Variable Analysis&amp; IterativeSolver</p><span id="more"></span><h2 id="实验信息">实验信息</h2><p>NJU软件分析, 实际上是静态分析(Static Program Analysis),是由李樾和谭添老师开设的面向本科生和研究生的一门课程,因为是本研共修选修课, 因此本课程内容较为基础,比较适合对静态分析感兴趣的初学者快速入门. 课程网站<ahref="https://tai-e.pascal-lab.net/lectures.html"><strong>[StaticProgram Analysis]</strong></a>, 配套课程<ahref="https://www.bilibili.com/video/BV1b7411K7P4"><strong>[Bilibili|南京大学《软件分析》]</strong></a>.</p><p>本课程实验(Assignments)基于Tai-e教学版框架,框架代码的获取和实验环境配置见课程网站, 笔者在约一年前曾自学过本课程,现今跟随2024Fall课程进度再次学习,由于上次学习中受到了多位前辈留下的实验记录帮助,遂于此记录笔者对各个实验的理解和记录. 限于笔者个人能力水平,恐难完整覆盖实验中的所有要点, 记录内容仅供参考, 如能帮助到您,乃笔者荣幸.</p><p>鉴于 <strong>学术诚信(Academic Integrity)</strong> 要求, 笔者暂且<strong><em>不</em></strong> 公开源代码.</p><h2 id="食用指南">食用指南</h2><p>本试验记录 <strong><em>不会</em></strong>从零开始讨论完成实验的知识点, 框架理解和注意事项.食用前请确保观看并理解了课程的P1-4内容, 尤其是对活跃变量分析(LiveVariable Analysis)的算法和原理的基本掌握; 完整阅读过<ahref="https://tai-e.pascal-lab.net/pa1.html"><strong>实验指南</strong></a>和框架代码后,再来参考本实验记录, 效果最佳.</p><h2 id="任务目标">任务目标</h2><p>基于已有框架为java实现一个<strong>活跃变量分析</strong>,使用<strong>迭代求解器(Iterative Solver)</strong>.</p><p>具体来说, 实现YourTask中涉及的三份文件中的6个<code>TODO API</code>.</p><p>涉及的主要算法如下图所示:</p><img src="/2024/10/20/SPA-A1/pic1.png" class="" title="pic1"><p>作为第一个实验, 总体难度不高, 关键在于熟悉Tai-e框架,还望读者耐心阅读框架代码. 不妨善用GithubCopilot或者ChatGPT帮助理解框架代码.</p><h2 id="livevariableanalysis">LiveVariableAnalysis</h2><p>活跃变量分析算法中需要用到的具体方法, 实验指南中已有较为详细的说明,笔者在此不再赘述.</p><img src="/2024/10/20/SPA-A1/pic2.png" class="" title="pic2"><p>关于实现该部分所需的<code>API</code>,请阅读<code>Class SetFact</code>源码.</p><p>笔者在此补充一些本实验所需java语法性质或语法糖.</p><h3 id="class-optional">Class Optional</h3><p>Java 8引入的性质, 详细信息可查询文档或教程, 笔者在此给出其一<ahref="https://www.runoob.com/java/java8-optional-class.html"><strong>[菜鸟教程|JavaOptional]</strong></a>.</p><p>与之类似的还有<code>java.util.List</code>,学习java语法来获得<code>Optional</code>和<code>List</code>中的内容.</p><p>使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> stmt.getDef().orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="instanceof操作符">instanceof操作符</h3><p>java中用于判断类型的操作符, 详细信息可参考<ahref="https://www.baeldung.com/java-instanceof"><strong>[Baeldung|Javainstanceof Operator]</strong></a>.</p><p>使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(def <span class="keyword">instanceof</span> Var)</span><br></pre></td></tr></table></figure><p>需要注意的是, 如指南所示</p><img src="/2024/10/20/SPA-A1/pic3.png" class="" title="pic3"><p><code>Exp</code>下的<code>LValue</code><code>RValue</code>包括多种类型,我们只需要关注<code>Var</code>类型的使用.</p><blockquote><p><strong>Tips:</strong> 为什么不需要考虑别的类型?</p><p><code>LValue</code>只需要关注<code>Var</code>, 这是手册告诉我们的.<code>RValue</code>尽管有多种类型,但可以通过<code>getUses()</code>方法将Exp中涉及的变量等信息全部获取,此时右式是<code>UnaryExp</code>or<code>BinaryExp</code>对我们来说都不重要了,只需要将<code>getUses()</code>中的<code>Var</code>筛选出来处理即可.</p></blockquote><blockquote><p><strong>Additional:</strong> <code>getUses()</code>究竟返回什么?</p><p>笔者在此引用<ahref="https://github.com/RicoloveFeng">RicoloveFeng</a>在<ahref="https://github.com/RicoloveFeng/SPA-Freestyle-Guidance">SPA-Freestyle-Guidance</a>中的解释</p><p>你可能想知道 <code>getUses()</code> 除了 <code>x = y</code>这条语句之外还返回些什么东西.我们举点例子吧:</p><ul><li><p><code>x = y op z</code>: <code>[y, z, y op z]</code></p></li><li><p><code>x = m(n)</code>:<code>[mClass, n, invokevirtual mClass.m(n)]</code></p></li></ul></blockquote><h3 id="java引用机制">java引用机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//in = out.copy();</span></span><br><span class="line">        in.set(out);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管两行代码"看起来"是一致的,但注释掉的代码只会改变形参<code>in</code>的取值,不会改变实际的<code>Fact in</code>. 详细原理可以参考<ahref="https://zhuanlan.zhihu.com/p/453857961"><strong>[知乎|java引用详解]</strong></a>.</p><h2 id="solver-iterativesolver">Solver &amp; IterativeSolver</h2><p>本部分对应具体的算法流程.</p><p>实际上指南写的已足够详细,包括如何从<code>cfg</code>中获取信息的方法和两处<code>TODO</code>对应的具体部分,使得即便对框架不甚理解, 仍然能完成该部分.</p><p>唯一需要阅读代码知道的是可以通过<code>analysis.xx</code>的方式调用我们在上一节中实现的<code>API</code>.</p><p><code>Solver</code>的<code>Init</code>需要注意的是由于我们<code>analysis.meetInto()</code>与算法中不完全相同,在初始化阶段我们同样要对<code>out Fact</code>进行赋空初始化.</p><p><code>IterativeSovlver</code>部分是算法的循环部分,由于我们的分析器<code>BB</code>是<code>stmt</code>,因此不需要考虑Block内部的执行顺序,直接使用<code>analysis.transferNode</code>即可.</p><p>另外, 上课时遍历迭代顺序取的是较优结果, 我们不需要过多考虑性能问题,因此以任意节点顺序迭代仍然可以得到结果, 这大大降低了代码实现的复杂性,只需要使用简单的<code>for(Node node : cfg)</code>即可.</p><p>笔者同样补充一些可能对本实验理解有帮助的细节部分.</p><h3 id="dataflowresult">DataflowResult</h3><p>其本质是两个<code>Nodes</code>对应的<code>inFacts</code><code>outFacts</code>的集合, 通过给定的API获取和设置其中的值,其中<code>inFacts</code>和<code>outFacts</code>不过是<code>set</code>的封装,在抽象层面上意义和课程中的那个代表变量的二进制串相同.</p><h3id="cfgnode-cfg-中的-node具体指什么"><code>CFG&lt;Node&gt; cfg</code>中的 <code>Node</code>具体指什么?</h3><p>在本次实验中, <code>Node node</code>指的是<code>stmt</code>,从指南中可以推测出这点. 通过阅读源代码, 也可以得知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiveVariableAnalysis</span> <span class="keyword">extends</span></span><br><span class="line">        <span class="title class_">AbstractDataflowAnalysis</span>&lt;Stmt, SetFact&lt;Var&gt;&gt;</span><br></pre></td></tr></table></figure><p>所以我们可以直接使用以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Node node : cfg)&#123;</span><br><span class="line">    ...</span><br><span class="line">    analysis.transferNode(node, in, out);</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>总的来说这次实验的难点在于框架代码的理解,笔者在记录中提及了部分关键定义和代码理解, 只要耐心阅读框架代码,相信一定会AC.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NJU Static Program Analysis | Assignment-1 Live Variable Analysis
&amp;amp; IterativeSolver&lt;/p&gt;</summary>
    
    
    
    <category term="NJU静态分析实验记录" scheme="http://la-pluma.github.io/categories/NJU%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="NJU" scheme="http://la-pluma.github.io/tags/NJU/"/>
    
    <category term="静态分析" scheme="http://la-pluma.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-机器学习 Ch2</title>
    <link href="http://la-pluma.github.io/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/"/>
    <id>http://la-pluma.github.io/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/</id>
    <published>2024-09-24T15:38:02.000Z</published>
    <updated>2024-10-26T15:24:09.543Z</updated>
    
    <content type="html"><![CDATA[<p><strong>有多个算法和参数生成的模型, 哪个才是好的模型?</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#chapter-2-模型评估与选择">Chapter 2: 模型评估与选择</a><ul><li><a href="#-21-经验误差与过拟合">$ 2.1 经验误差与过拟合</a></li><li><a href="#-22-评估方法">$ 2.2 评估方法</a><ul><li><a href="#-221-留出法hold-out">$ 2.2.1 留出法(Hold-Out)</a></li><li><a href="#-222-交叉验证法cross-validation">$ 2.2.2 交叉验证法(CrossValidation)</a></li><li><a href="#-223-自助法bootstapping">$ 2.2.3自助法(Bootstapping)</a></li><li><a href="#-224-调参与最终模型">$ 2.2.4 调参与最终模型</a></li></ul></li><li><a href="#-23-性能度量">$ 2.3 性能度量</a><ul><li><a href="#-231-错误率与精度">$ 2.3.1 错误率与精度</a></li><li><a href="#-232-查准率precision-查全率recall-f1">$ 2.3.2查准率(Precision), 查全率(Recall), F1</a></li><li><a href="#-233-roc与auc">$ 2.3.3 ROC与AUC</a></li><li><a href="#-234-代价敏感错误率与代价曲线">$ 2.3.4代价敏感错误率与代价曲线</a></li></ul></li><li><a href="#-24-比较检验">$ 2.4 比较检验</a><ul><li><a href="#-241-假设检验">$ 2.4.1 假设检验</a></li><li><a href="#-242-多学习器比较">$ 2.4.2 多学习器比较</a></li></ul></li><li><a href="#25-偏差与方差">2.5 偏差与方差</a></li></ul></li></ul><hr /><h2 id="chapter-2-模型评估与选择">Chapter 2: 模型评估与选择</h2><h3 id="经验误差与过拟合">$ 2.1 经验误差与过拟合</h3><ul><li><p><strong>错误率(Error Rate):</strong>分类错误的样本数占样本总数的比例, 记样本数为<spanclass="math inline">\(m\)</span>, <spanclass="math inline">\(a\)</span>个错误分类的样本, 错误率 <spanclass="math inline">\(E=\frac{a}{m}\)</span> .</p></li><li><p><strong>精度(Accuracy):</strong> <span class="math inline">\((1 -\frac{a}{m}) \times 100\%\)</span> 称为精度, 即 "精度 = 1 -错误率".</p></li><li><p><strong>误差(Error):</strong> 更一般地,我们把<strong>学习器的实际预测输出</strong>与<strong>样本的真实输出</strong>之间的差异称为误差,学习器在训练集上的误差称为 <strong>训练误差(TrainingError)/经验误差(Empirical Error)</strong>,在新样本上的误差称为<strong>泛化误差(Generalization Error)</strong>.</p><blockquote><p><strong>Tips:</strong> 这里的误差均指<strong>误差期望</strong>.</p></blockquote></li></ul><p>尽管我们希望得到一个泛化误差小的学习器, 使得其在新样本上表现很好,但我们并不能预测新样本, 因此我们只能尝试降低经验误差.但经验误差很小的学习器往往在泛化误差的表现上都很糟糕.这样的学习器发生了<strong>过拟合</strong>.</p><ul><li><p><strong>过拟合(Overfitting):</strong>学习器可能将训练样本自身的一些特点当作了所有潜在样本都具有的一般性质,导致泛化能力下降的现象.</p></li><li><p><strong>欠拟合(Underfitting):</strong> 与过拟合相对,指对训练样本的一般性质尚未学好.</p></li></ul><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-1.png" class="" title="pic2-1"><blockquote><p><strong>Tips:</strong> 导致过拟合的原因很多,最常见的原因是学习能力过强; 欠拟合则相反, 因为学习能力低下.欠拟合容易克服, 但过拟合很难解决, 且过拟合无法彻底避免.</p></blockquote><ul><li><strong>模型选择(Model Selection):</strong> 在实际中,面对同一个问题, 往往有多种学习算法可以选择,参数配置也会对模型产生影响.</li></ul><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-2.png" class="" title="spic2-2"><h3 id="评估方法">$ 2.2 评估方法</h3><p>通常我们可以通过实验测试对学习器的泛化误差进行评估,使用<strong>测试集(Testing Set)</strong>测试学习器对新样本的判别能力,以测试集上<strong>测试误差(Testing Error)</strong>作为泛化误差的近似.但需要注意的是, 测试集应尽可能与训练集互斥.</p><blockquote><p>假设我们有且只有一个包含<spanclass="math inline">\(m\)</span>个样例的数据集<spanclass="math inline">\(D = \{(x_1,y_1),(x_2,y_2), ...,(x_m,y_m)\}\)</span>, 既要训练, 又要测试, 这样就需要对<spanclass="math inline">\(D\)</span>进行适当处理, 从中产生<strong>训练集</strong> <span class="math inline">\(S\)</span>和<strong>测试集</strong> <span class="math inline">\(T\)</span>.</p></blockquote><h4 id="留出法hold-out">$ 2.2.1 留出法(Hold-Out)</h4><p>留出法的思路很简单, 直接将数据集<spanclass="math inline">\(D\)</span>划分成两个互斥的集合, 即<spanclass="math inline">\(D = S \cup T, S \cap T = \emptyset\)</span>.</p><p>使用留出法时需要注意训练集和测试集的划分需要保持数据分布一致性,避免因数据划分引入额外偏差对结果产生影响.同时单次留出法得到的估计往往并不够准确可靠, 一般采用若干次随机划分,重复进行实验评估取平均值作为留出法评估结果. 关于划分比例, 通常取2/3 ~4/5的样本用于训练, 其余用于测试.</p><h4 id="交叉验证法cross-validation">$ 2.2.2 交叉验证法(CrossValidation)</h4><p>交叉验证法可以看作是一种具体的留出法, 其方法过程是:</p><p>先将数据集<span class="math inline">\(D\)</span>划分为<spanclass="math inline">\(k\)</span>个大小相似的互斥子集, <spanclass="math inline">\(D = D_1 \cup D_2 \cup ... \cup D_k, D_i \cap D_j =\emptyset (i \neq j)\)</span>, 子集<spanclass="math inline">\(D_i\)</span>通过保留类别比例的<strong>分层采样(StratifiedSampling)</strong>来尽可能保持数据分布一致性.</p><p>接下来每次取<span class="math inline">\(k-1\)</span>个子集作为训练集,余下一个作为测试集, 进行<spanclass="math inline">\(k\)</span>次训练和测试, 最终结果取<spanclass="math inline">\(k\)</span>个结果的均值.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-2.png" class="" title="pic2-2"><p>显然交叉验证法评估结果的<strong>稳定性(Stability)</strong>和<strong>保真性(Fidelity)</strong>与<spanclass="math inline">\(k\)</span>的取值强相关.故而交叉验证法又称<strong>k折交叉验证(k-fold Cross Validation)</strong>.最常见的取值是 <span class="math inline">\(k=10\)</span>.</p><p>由于<span class="math inline">\(D\)</span>的<spanclass="math inline">\(k\)</span>划分不唯一, k折交叉验证通常也要重复多次,记为<span class="math inline">\(p\)</span>, 最终结果取这<spanclass="math inline">\(p\)</span>次k折交叉验证结果的均值.</p><p><strong>留一法(Leave-One-Out, LOO)</strong>, <spanclass="math inline">\(|D| = m\)</span>, 则令<spanclass="math inline">\(k = m\)</span> 就得到了留一法.</p><p>留一法的优势是不受样本划分影响(有且仅有一种划分方式), 训练集仅比<spanclass="math inline">\(D\)</span>少一个样本,绝大多数情况下留一法中被评估的模型与期望用<spanclass="math inline">\(D\)</span>训练的模型相似.因此认为留一法评估结果较为准确. 缺点是当<spanclass="math inline">\(m\)</span>较大时, 计算开销过大以致无法接受.</p><h4 id="自助法bootstapping">$ 2.2.3 自助法(Bootstapping)</h4><p>留出法和交叉验证法都保留了一部分样本用于测试,因此实际评估的模型所使用的训练集比<spanclass="math inline">\(D\)</span>小,必然会引入一些因训练样本规模不同而导致的估计偏差.留一法的计算复杂度又太高了. 自助法提供了一个较好的解决方案.</p><p>自助法直接以 <strong>自助采样法(Bootstrap Sampling)</strong> 为基础.给定包含<span class="math inline">\(m\)</span>个样本的数据集<spanclass="math inline">\(D\)</span>, 对其进行采样产生数据集<spanclass="math inline">\(D&#39;\)</span>. 采样过程每次随即从<spanclass="math inline">\(D\)</span>中挑选一个样本, 将拷贝放入<spanclass="math inline">\(M&#39;\)</span><strong>(意味着下次采样该样本仍有可能被采样到)</strong>. 重复该过程<spanclass="math inline">\(m\)</span>次, 得到了包含<spanclass="math inline">\(m\)</span>个样本的数据集<spanclass="math inline">\(D&#39;\)</span>.</p><blockquote><p><strong>Tips:</strong> 此处"自助"为意译,称<strong>可重复采样/有放回采样</strong>更符合其原理.</p></blockquote><p>不难看出, 可能存在部分样本被多次采样到, 部分样本未被采样到.我们关注某个样本在<spanclass="math inline">\(m\)</span>次中未被采样的概率,有</p><p><span class="math display">\[\begin{equation}\lim_{m \rightarrow \infty}(1 - \frac{1}{m})^m  = \frac{1}{e} \approx0.368 \tag{2.1}\end{equation}\]</span></p><p>通过自主采样, 初始数据集<spanclass="math inline">\(D\)</span>中约有<spanclass="math inline">\(36.8\%\)</span>的样本未出现在采样数据集<spanclass="math inline">\(D&#39;\)</span>中, 将<spanclass="math inline">\(D&#39;\)</span>作为训练集, <spanclass="math inline">\(D \backslash D&#39;\)</span>作为测试集.这样的测试结果称为<strong>包外估计(Out-Of-Bagestimate)</strong>.</p><p>自助法在数据集较小, 难以有效划分训练和测试集的时候具有优势.但自助法产生的数据集改变了初始数据集的分布, 会引入估计误差.初始数据集较大时更常用留出法和交叉验证法.</p><h4 id="调参与最终模型">$ 2.2.4 调参与最终模型</h4><p><strong>参数(Parameter)</strong>和<strong>调参(ParameterTuning)</strong>释义见名称.</p><blockquote><p><strong>Tips:</strong> 机器学习常涉及两类参数:算法参数和模型参数.</p></blockquote><ul><li><p><strong>验证集(Validation Set):</strong>模型评估与选择中用于评估测试的数据集常称为验证集.</p><blockquote><p><strong>Additonal:</strong> 关于训练集, 测试集和验证集的区别,笔者在此参考<ahref="https://zhuanlan.zhihu.com/p/98532085"><strong>[知乎|训练集、验证集、测试集]</strong></a></p></blockquote></li></ul><h3 id="性能度量">$ 2.3 性能度量</h3><ul><li><strong>性能度量(Performance Measure):</strong>衡量模型泛化能力的评价标准. 显然该标准取决于任务需求.</li></ul><p>以预测任务为例, 给定样例集<span class="math inline">\(D =\{(\boldsymbol{x_1}, y_1), (\boldsymbol{x_2}, y_2), ...,(\boldsymbol{x_m}, y_m)\}\)</span>, 其中<spanclass="math inline">\(y_i\)</span>是<spanclass="math inline">\(\boldsymbol{x_i}\)</span>的真实标记,评估学习器<span class="math inline">\(f\)</span>的性能,需要比较预测结果<span class="math inline">\(f(x)\)</span>与真实标记<spanclass="math inline">\(y\)</span>.</p><p>回归任务常用性能度量<strong>均方误差(Mean Squared Error)</strong></p><p><span class="math display">\[\begin{equation}E(f;D) = \frac{1}{m} \sum_{i=1}^{m}(f(\boldsymbol{x_i}) - y_i)^2\tag{2.2}\end{equation}\]</span></p><p>更一般地, 对于数据分布<spanclass="math inline">\(\mathcal{D}\)</span>和概率密度函数<spanclass="math inline">\(p(\cdot)\)</span>, 均方误差描述为</p><p><span class="math display">\[\begin{equation}E(f;\mathcal{D}) = \int_{x \sim \mathcal{D}}^{}(f(\boldsymbol{x}) - y)^2p(\boldsymbol{x}) d\boldsymbol{x} \tag{2.3}\end{equation}\]</span></p><h4 id="错误率与精度">$ 2.3.1 错误率与精度</h4><p>错误率和精度是分类任务中最常用的两种性能度量.</p><p>对于样例集<span class="math inline">\(\mathcal{D}\)</span>,错误率和精度定义为</p><p><span class="math display">\[\begin{equation}E(f;D) = \frac{1}{m} \sum_{i=1}^{m}\mathbb{I}(f(\boldsymbol{x_i}) \neqy_i) \tag{2.4}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}acc(f;D) = \frac{1}{m} \sum_{i=1}^{m}\mathbb{I}(f(\boldsymbol{x_i}) =y_i) = 1 - E(f;D) \tag{2.5}\end{equation}\]</span></p><p>对于数据分布<spanclass="math inline">\(\mathcal{D}\)</span>和概率密度函数<spanclass="math inline">\(p(\cdot)\)</span>, 错误率和精度定义为</p><p><span class="math display">\[\begin{equation}E(f;\mathcal{D}) = \int_{x \sim\mathcal{D}}^{}\mathbb{I}(f(\boldsymbol{x}) \neq y) p(\boldsymbol{x})d\boldsymbol{x} \tag{2.6}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}acc(f;\mathcal{D}) = \int_{x \sim\mathcal{D}}^{}\mathbb{I}(f(\boldsymbol{x}) = y) p(\boldsymbol{x})d\boldsymbol{x} = 1 - E(f;\mathcal{D}) \tag{2.7}\end{equation}\]</span></p><h4 id="查准率precision-查全率recall-f1">$ 2.3.2 查准率(Precision),查全率(Recall), F1</h4><p>有时我们更关心模型的正确率,比如说"挑选出来的瓜有多少是好瓜","有多少好瓜被挑选出来了",查准率和查全率更适合用来度量.</p><p>对于二分类问题, 我们有<strong>混淆矩阵(Confusion Matrix)</strong></p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/tab2-1.png" class="" title="tab2-1"><p>定义查准率<span class="math inline">\(P\)</span>, 查全率<spanclass="math inline">\(R\)</span></p><p><span class="math display">\[\begin{equation}P = \frac{TP}{TP + FP}\tag{2.8}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}P = \frac{TP}{TP + FN}\tag{2.9}\end{equation}\]</span></p><blockquote><p><strong>Tips:</strong> 自然语言解释就是,查准率是在预测正确中实际正确的比率,查全率是在实际正确中预测正确的比率.</p></blockquote><p>查准率和查全率是一对矛盾的度量, 二者负相关.是<strong>sound</strong>和<strong>complete</strong>的关系</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-1.png" class="" title="spic2-1"><blockquote><p><strong>Tips:</strong> 该图片截选自NJU软件分析课件,<del>ly和tt老师应该不会在意吧(雾)</del></p><p>课程地址链接<ahref="https://tai-e.pascal-lab.net/lectures.html"><strong>[StaticProgram Analysis]</strong></a></p></blockquote><p>查准率和查全率的关系可以用<strong>P-R图</strong>表示</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-3.png" class="" title="pic2-3"><ul><li><strong>平衡点(Break-Even Point, BEP):</strong> <spanclass="math inline">\(P=R\)</span>时的取值,可基于BEP评估两个学习器的优劣, 如图2-3, 可认为<spanclass="math inline">\(A&gt;B&gt;C\)</span></li></ul><p>比BEP更常用的是<span class="math inline">\(F1\)</span>度量定义为</p><p><span class="math display">\[\begin{equation}F1 = \frac{2 \times P \times R}{P + R} = \frac{2 \times TP}{样例总数 +TP - TN}\tag{2.10}\end{equation}\]</span></p><p><span class="math inline">\(F_{\beta}\)</span>是<spanclass="math inline">\(F_1\)</span>的一般形式, 定义为</p><p><span class="math display">\[\begin{equation}F_{\beta} = \frac{(1 + \beta^2) \times P \times R}{(\beta^2 \times P) +R}\tag{2.11}\end{equation}\]</span></p><p>其中<span class="math inline">\(\beta &gt;0\)</span>度量了查全率对查准率的相对重要性, <spanclass="math inline">\(\beta = 1\)</span>时退化为<spanclass="math inline">\(F_1\)</span>, <span class="math inline">\(\beta&gt; 1\)</span>时查全率影响更大, <span class="math inline">\(\beta &lt;1\)</span>时查准率影响更大.</p><blockquote><p><strong>Tips:</strong></p><p><span class="math inline">\(F_1\)</span>基于调和平均定义, <spanclass="math inline">\(\frac{1}{F_1} = \frac{1}{2} \cdot (\frac{1}{P} +\frac{1}{R})\)</span>.</p><p><span class="math inline">\(F_\beta\)</span>基于加权调和平均定义,<span class="math inline">\(\frac{1}{F_\beta} = \frac{1}{1 + \beta^2}\cdot (\frac{1}{P} + \frac{\beta^2}{R})\)</span></p></blockquote><p>若在n个二分类混淆矩阵上考察准确率和查全率,我们有<strong>macro</strong>和<strong>micro</strong>两种选择.</p><p>对于<strong>宏(macro)</strong>, 在各个混淆矩阵上分别计算<spanclass="math inline">\(P\)</span>和<spanclass="math inline">\(R\)</span>,再取平均.得到<strong>宏查准率(macro-P)</strong>,<strong>宏查全率(macro-R)</strong>, <strong>宏F1(macro-F1)</strong></p><p><span class="math display">\[\begin{equation}macro\text{-}P = \frac{1}{n} \sum_{i=1}^{n} P_i\tag{2.12}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}macro\text{-}R = \frac{1}{n} \sum_{i=1}^{n} R_i\tag{2.13}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}macro\text{-}F1 = \frac{2 \times macro\text{-}P \timesmacro\text{-}R}{macro\text{-}P + macro\text{-}R}\tag{2.14}\end{equation}\]</span></p><p>对于<strong>微(micro)</strong>, 先平均混淆矩阵得到$, , , $,再计算出<strong>微查准率(micro-P)</strong>,<strong>微查全率(micro-R)</strong>, <strong>微F1(micro-F1)</strong></p><p><span class="math display">\[\begin{equation}micro\text{-}P =\frac{\overline{TP}}{\overline{TP}+\overline{FP}}\tag{2.15}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}micro\text{-}R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}\tag{2.16}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}micro\text{-}F1 = \frac{2 \times micro\text{-}P \timesmicro\text{-}R}{micro\text{-}P + micro\text{-}R}\tag{2.17}\end{equation}\]</span></p><h4 id="roc与auc">$ 2.3.3 ROC与AUC</h4><p>现重新考虑查准率和查全率, 首先我们来看看学习器如何给正/反的分类.</p><p>很多学习器为测试样本产生一个实值或概率预测,将预测值与<strong>分类阈值(Threshold)</strong>比较, 大于阈值则为正类,否则为反类. 根据该实值或概率预测进行排序, 概率高的在前, 概率低的在后,则这个分类阈值就是<strong>截断点(Cut Point)</strong>, 前一部分为正例,后一部分为负例.</p><p>不难得到以下结论: 截断点越靠前, 查准率增高而查全率降低; 截断点越靠后,查准率降低而查全率增高. 同时,排序质量越好的学习器"在一般情况下"泛化性能越好,ROC基于此度量模型的泛化能力.</p><p><strong>受试者工作特征(Receiver Operating Characteristic,ROC)</strong>, 根据学习器的预测结果对样例进行排序,顺序逐个把样本作为正例进行预测(选择不同的截断点),计算<strong>真正例率(True Positive Rate, TPR)</strong>,<strong>假正例率(False Positive Rate, FPR)</strong> 作为纵横轴.</p><p><span class="math display">\[\begin{equation}TPR = \frac{TP}{TP + FN}\tag{2.18}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}FPR = \frac{FP}{TN + FP}\tag{2.19}\end{equation}\]</span></p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-4.png" class="" title="pic2-4"><p>对角线对应随即猜测模型, 点(0, 1)对应所有正例在负例前的理想模型.</p><ul><li><strong>AUC(Area Under ROC Curve):</strong> ROC曲线下面积.为依据两个模型绘制的ROC曲线比较两个模型的优劣而引入.</li></ul><p>对于离散样本, 计算AUC:</p><p><span class="math display">\[\begin{equation}AUC = \frac{1}{2} \sum^{m - 1}_{i=1}(x_{i+1} - x_i)\cdot(y_i + y_{i + 1})\tag{2.19}\end{equation}\]</span></p><p>形式化上AUC度量排序质量, 记有<spanclass="math inline">\(m^+\)</span>个正例, <spanclass="math inline">\(m^-\)</span>个反例, 令<spanclass="math inline">\(D^+\)</span>为正例集合, <spanclass="math inline">\(D^-\)</span>为负例集合,定义排序<strong>损失(loss):</strong></p><p><span class="math display">\[\begin{equation}\mathscr{l}_{rank} = \frac{1}{m^+ m^-}\sum_{x^+ \in D^+} \sum_{m^- \inD^-}\left(\mathbb{I}(f(x^+)&lt;f(x^-)) + \frac{1}{2} \mathbb{I}(f(x^+)=f(x^-))\right)\tag{2.21}\end{equation}\]</span></p><p>如何理解这个式子? 考虑每一对正反例, 若正例小于反例记一个"罚分",相等则记半个. 不难看出, 对于每个正例/负例, 可能造成的"罚分"与其"位置",越"错误"的位置会引起越多的"罚分", 这与AUC计算过程及其相似. 实际上, <spanclass="math inline">\(\mathscr{l}_{rank}\)</span>对应ROC曲线上方的面积,有</p><p><span class="math display">\[\begin{equation}AUC = 1 - \mathscr{l}_{rank}\tag{2.22}\end{equation}\]</span></p><h4 id="代价敏感错误率与代价曲线">$ 2.3.4 代价敏感错误率与代价曲线</h4><p>为权衡不同类型错误所造成的不同损失,我们为错误赋予<strong>非均等代价(UnEqual Cost)</strong>.</p><p>以二分类为例, <strong>代价矩阵(Cost Matrix)</strong>如下:</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/tab2-2.png" class="" title="tab2-2"><p>若将0类记为正例, 1类记为负例, 定义<span class="math inline">\(D^+,D^-\)</span>, <strong>代价敏感(Cost-Sensitive)</strong> 错误率为</p><p><span class="math display">\[\begin{equation}E(f;D;cost) = \frac{1}{m} \left(\sum_{\boldsymbol{x}_i \in D^+}\mathbb{I}(f(\boldsymbol{x}_i) \neq y_i) \times cost_{01} +\sum_{\boldsymbol{x}_i \in D^-} \mathbb{I}(f(\boldsymbol{x}_i) \neq y_i)\times cost_{10}\right)\tag{2.23}\end{equation}\]</span></p><p>非均等情况下, <strong>代价曲线(CostCurve)</strong>可以解决ROC曲线不能反映出学习器的期望<strong>总体代价(TotalCost)</strong>问题.</p><p>其横轴是取值为<spanclass="math inline">\([0,1]的\)</span>正例概率代价, 其中<spanclass="math inline">\(p\)</span>为样例是正例的概率</p><p><span class="math display">\[\begin{equation}P(+)cost=\frac{p \times cost_{01}}{p \times cost_{01} + (1 - p) \timescost_{10}}\tag{2.24}\end{equation}\]</span></p><p>纵轴是取值为<spanclass="math inline">\([0,1]\)</span>的归一化代价,FPR为假正例率,FNR为假反例率</p><p><span class="math display">\[\begin{equation}cost_{norm} = \frac{FNR \times p \times cost_{01} + FPR \times (1 - p)\times cost_{10}}{p \times cost_{01} + (1 - p) \times cost_{10}}\tag{2.25}\end{equation}\]</span></p><p>绘制代价曲线时, ROC曲线上每个点对应代价平面上的一条线段,设ROC点坐标为<span class="math inline">\((FPR, TPR)\)</span>,然后在代价平面上绘制一条从<span class="math inline">\((0,FPR)\)</span>到<span class="math inline">\((1, FNR)\)</span>的线段,线段下面积代表了该条件下的期望总体代价.如此为每个点绘制线段, 取线段下界,围成面积即为在所有条件下学习器的总体期望代价.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-5.png" class="" title="pic2-5"><blockquote><p><strong>Addtional:</strong> 如何理解代价曲线?</p><p>笔者在此给出一篇参考<ahref="https://www.zhihu.com/question/63492375"><strong>[知乎|代价曲线的理解]</strong></a>.这篇参考中对大部分问题给到了解释.</p><p>在此额外补充一点困惑笔者许久的问题, 每一条线段代表什么?</p><p>每一条线段代表当前<strong>阈值</strong>条件下,对不同样本集的期望代价. 具体来说,是以FPR和FNR为预测值对不同样本集的预测.</p></blockquote><h3 id="比较检验">$ 2.4 比较检验</h3><p><strong>统计假设检验(Hypothesis Test)</strong>为比较学习器性能提供了重要依据. 本节默认以错误率为性能度量, 用<spanclass="math inline">\(\epsilon\)</span>表示.</p><h4 id="假设检验">$ 2.4.1 假设检验</h4><p>现实中我们无法知道学习器的泛化错误率 <spanclass="math inline">\(\epsilon\)</span>, 只能获知其测试错误率 <spanclass="math inline">\(\hat{\epsilon}\)</span>.常用测试错误率估推出泛化错误率.</p><p>对于 <span class="math inline">\(m\)</span> 个测试样本,如果测试错误率为 <span class="math inline">\(\hat{\epsilon}\)</span>,则被误分类的样本数量 <span class="math inline">\(m&#39;=\hat{\epsilon}\times m\)</span>, 假定测试样本从样本总体分布中独立采样获得,由<strong>二项(Binomial)分布</strong>, 泛化错误率为 <spanclass="math inline">\(\hat{\epsilon}\)</span> 的学习器恰有 <spanclass="math inline">\(m&#39;\)</span> 个样本被误分类的概率是 <spanclass="math inline">\(\binom{m}{m&#39;}\epsilon^{m&#39;}(1-\epsilon)^{m-m&#39;}\)</span>. 同时, 这也表示泛化错误率为 <spanclass="math inline">\(\epsilon\)</span> 的学习器在<spanclass="math inline">\(m\)</span>个样本上测试得到测试错误率为 <spanclass="math inline">\(\hat{\epsilon}\)</span> 的概率:</p><p><span class="math display">\[\begin{equation}P(\hat{\epsilon};\epsilon)=\binom{m}{\hat{\epsilon} \times m}\epsilon^{\hat{\epsilon} \times m} (1 - \epsilon)^{m - \hat{\epsilon}\times m}\tag{2.26}\end{equation}\]</span></p><p>由二项分布性质, 或者计算 <spanclass="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 对 <spanclass="math inline">\(\epsilon\)</span> 的偏导, 可以知道 <spanclass="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 在 <spanclass="math inline">\(\epsilon = \hat{\epsilon}\)</span> 时最大, <spanclass="math inline">\(|\epsilon - \hat{\epsilon}|\)</span> 增大时 <spanclass="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 减小.</p><p>若取 <span class="math inline">\(m=10, \epsilon = 0.3\)</span>,示意图如2.6所示.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-6.png" class="" title="pic2-6"><blockquote><p><strong>Tips:</strong><del>死去的《概率论与数理统计》突然复活起来攻击我</del>, 推荐复习笔记<ahref="https://zhuanlan.zhihu.com/p/243215469"><strong>[知乎|概率论与数理统计复习整理]</strong></a>.</p></blockquote><p>由<strong>二项检验(Binomial Test)</strong>, 考虑假设<spanclass="math inline">\(\epsilon \leq \epsilon_0\)</span>, 在 <spanclass="math inline">\(1 - \alpha\)</span>的概率内能观测到的最大错误率为</p><p><span class="math display">\[\begin{equation}\bar{\epsilon} = \min \epsilon \ \ \text{s.t.} \ \ \sum_{i = \epsilon\times m + 1}^{m} \binom{m}{i}\epsilon_0^i (1 - \epsilon_0)^{m - i} &lt;\alpha\tag{2.27}\end{equation}\]</span></p><p>其中 <span class="math inline">\(1-\alpha\)</span>为<strong>置信度(Confidence)</strong>, 直观上对应图2.6的非阴影部分;"s.t."是"subject to", 使左边式子在右边式子条件满足时成立.</p><p>若测试错误率 <span class="math inline">\(\hat{\epsilon}\)</span>大于临界值 <span class="math inline">\(\bar{\epsilon}\)</span>,由二项检验, 我们可以认为在 <span class="math inline">\(\alpha\)</span>的显著度下, 假设 <span class="math inline">\(\epsilon \leq\hat{\epsilon}\)</span> 不能被拒绝, 即能以 <spanclass="math inline">\(1-\alpha\)</span> 的置信度认为,学习器的泛化错误率不高于 <spanclass="math inline">\(\epsilon_0\)</span>; 否则可以拒绝假设, 在 <spanclass="math inline">\(\alpha\)</span>的显著度下可认为学习器的泛化错误率大于 <spanclass="math inline">\(\epsilon_0\)</span>.</p><p>在通过多次测试中中我们会获得多个测试错误率,此时可使用<strong>t检验(t-test)</strong>.</p><p>设<span class="math inline">\(k\)</span>个错误率 <spanclass="math inline">\(\hat{\epsilon_1}, \hat{\epsilon_2}, ...,\hat{\epsilon_k}\)</span>, 则平均错误率 <spanclass="math inline">\(\mu\)</span>, 方差 <spanclass="math inline">\(\sigma^2\)</span> 为</p><p><span class="math display">\[\begin{equation}\mu = \frac{1}{k} \sum_{i=1}^k \hat{\epsilon_i}\tag{2.28}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\sigma^2=\frac{1}{k-1} \sum^{k}_{i=1}(\hat{\epsilon_i} - \mu)^2\tag{2.29}\end{equation}\]</span></p><p><span class="math inline">\(k\)</span> 个测试错误率可看作是泛化错误率<span class="math inline">\(\epsilon_0\)</span> 的独立采样, 则变量</p><p><span class="math display">\[\begin{equation}\tau_t=\frac{\sqrt{k} (\mu - \epsilon_0)}{\sigma}\tag{2.30}\end{equation}\]</span></p><p>服从自由度为 <span class="math inline">\(k-1\)</span> 的 <spanclass="math inline">\(t\)</span> 分布.</p><blockquote><p><strong>Addtional:</strong> <strong>基础知识补充</strong></p><p><span class="math inline">\(\chi^2\)</span> 分布: <spanclass="math inline">\(X_1, X_2, ..., X_n\)</span> 为独立同分布随机变量,服从 <span class="math inline">\(N(0, 1)\)</span>, 则 <spanclass="math inline">\(\chi^2_n = \sum_{i=1}^n X^2_i\)</span>为服从自由度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(\chi^2\)</span> 分布</p><p><span class="math inline">\(t\)</span> 分布: <spanclass="math inline">\(X \sim N(0,1), Y \sim \chi^2(n)\)</span>, <spanclass="math inline">\(X,Y\)</span> 独立, 称 <spanclass="math inline">\(T = \frac{X}{\sqrt{\frac{Y}{n}}}\)</span>为服从自由度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(t\)</span> 分布.</p></blockquote><blockquote><p><strong>Tips:</strong> <strong>推导补充</strong></p><p>原书中没有关于这个<spanclass="math inline">\(\tau_t\)</span>服从<spanclass="math inline">\(t\)</span>分布的推导, 笔者在此给出补充.</p><p>假设<spanclass="math inline">\(X_1,X_2,...X_n\)</span>是来自正态总体<spanclass="math inline">\(N(\mu,\sigma^2)\)</span>的样本.我们有以下重要统计量:</p><p><span class="math display">\[\begin{align}\nonumber\text{样本均值}&amp; \ \bar{X}=\frac{1}{n}\sum_{i=1}^n &gt;X_i\\\nonumber\text{样本方差}&amp; \S^2=\frac{1}{n-1}\sum_{i-1}^{n}(X_i-\bar{X})^2\end{align}\]</span></p><p>我们有几个重要结论:</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-3.png" class="" title="spic2-3"><p>故而有推论:</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-4.png" class="" title="spic2-4"></blockquote><p>对假设<spanclass="math inline">\(\mu=\epsilon_0\)</span>和显著度<spanclass="math inline">\(\alpha\)</span>, 可以算出临界值——在<spanclass="math inline">\(1-\alpha\)</span>内能观测到的最大错误率.考虑<strong>双边假设(Two-Tailed)</strong>, 若<spanclass="math inline">\(\tau_t\)</span>位于临界区<spanclass="math inline">\([t_{-\alpha/2},t_{\alpha/2}]\)</span>内(如图2.7所示),则不能拒绝假设<span class="math inline">\(\mu=\epsilon_0\)</span>.我们可以认为泛化错误率为<spanclass="math inline">\(\epsilon_0\)</span>.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-7.png" class="" title="pic2-7"><h4 id="多学习器比较">$ 2.4.2 多学习器比较</h4><p>笔者对这部分不做过多记录, 翻阅原书该部分即可.</p><p>对于两个学习器,我们有</p><ul><li>交叉验证t检验(基于成对t 检验)</li><li>McNember检验(基于列联表，卡方检验)</li></ul><p>对于多个学习器,我们有</p><ul><li>Friedman检验(基于序值，F检验; 判断”是否都相同”)</li><li>Nemenyi后续检验(基于序值，进一步判断两两差别)</li></ul><h3 id="偏差与方差">2.5 偏差与方差</h3><ul><li><strong>偏差-方差分解(Bias-variance Decomposition)</strong></li></ul><p>对测试样本<span class="math inline">\(\boldsymbol{x}\)</span>,令<span class="math inline">\(y_D\)</span>为<spanclass="math inline">\(\boldsymbol{x}\)</span>在数据集的集中标记, <spanclass="math inline">\(y\)</span>为<spanclass="math inline">\(\boldsymbol{x}\)</span>的真实标记, <spanclass="math inline">\(f(\boldsymbol{x};D)\)</span>为训练集<spanclass="math inline">\(D\)</span>上的学得模型<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}\)</span>上的预测输出.</p><p>以回归算法为例, 我们有如下定义(符号定义见<ahref="http://localhost:4000/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/#chapter-0-%E4%B8%BB%E8%A6%81%E7%AC%A6%E5%8F%B7%E8%A1%A8"><strong>[Lapluma|读书笔记-机器学习Ch0-Ch1]</strong></a>):</p><p>学习算法的期望预测.</p><p><span class="math display">\[\begin{equation}\bar{f}(\boldsymbol{x})=\mathbb{E}_D[f(\boldsymbol{x};D)]\tag{2.37}\end{equation}\]</span></p><p>使用样本数相同的不同训练集产生的方差,度量了同样大小的训练集变动导致的学习性能变化,刻画了数据扰动造成的影响.</p><p><span class="math display">\[\begin{equation}\mathcal{var}(\boldsymbol{x})=\mathbb{E}_D[(f(\boldsymbol{x};D)-\bar{f}(x))^2]\tag{2.38}\end{equation}\]</span></p><p>噪声, 在当前学习任务上任何学习算法所能达到的期望泛化误差下界,刻画了学习问题本身的难度.</p><p><span class="math display">\[\begin{equation}\varepsilon^2=\mathbb{E}_D[(y_D-y)^2]\tag{2.39}\end{equation}\]</span></p><p>期望输出与真实标记的差别称为偏差,度量了学习算法的期望预测与真是结果的偏离程度,刻画了学习算法本身的拟合能力.</p><p><span class="math display">\[\begin{equation}\mathcal{bias}^2(\boldsymbol{x})=(\bar{f}(\boldsymbol{x})-y)^2\tag{2.40}\end{equation}\]</span></p><p>便于讨论,我们假定噪声期望为0, 即<spanclass="math inline">\(\mathbb{E}_D[y_D-y]=0\)</span>,对期望泛化误差进行分解(推导略, 见原书), 有</p><p><span class="math display">\[\begin{equation}E(f;D)=bias^2(\boldsymbol{x})+var(\boldsymbol{x})+\varepsilon ^2\tag{2.42}\end{equation}\]</span></p><p>即泛化误差可以分解为偏差, 方差和噪声之和.</p><p>一般来说, 偏差和方差存在冲突, 称为<strong>偏差-方差窘境(Bias-VarianceDilemma)</strong>,见图2-9.</p><img src="/2024/09/24/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-9.png" class="" title="pic2-9"><p>训练不足时, 学习器拟合能力不足,训练数据的扰动不足以使学习器产生显著变化,此时偏差主导了泛化错误率;训练程度加深, 学习器拟合能力增强,训练数据发生的扰动被学习器学习到, 方差逐渐主导了泛化错误率;训练充足后,学习器拟合能力非常强. 训练数据发生轻微扰动都会导致学习器发生显著变化,此时训练数据自身,非全局的性质被学习器学习, 发生过拟合.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;有多个算法和参数生成的模型, 哪个才是好的模型?&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="机器学习" scheme="http://la-pluma.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode个人题解[C++] P4 寻找两个正序数组的中位数</title>
    <link href="http://la-pluma.github.io/2024/09/21/LeetCode-P4/"/>
    <id>http://la-pluma.github.io/2024/09/21/LeetCode-P4/</id>
    <published>2024-09-21T12:29:30.000Z</published>
    <updated>2024-09-21T18:20:42.472Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong> <ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><strong>LeetCode|4.寻找两个正序数组的中位数</strong></a></p><span id="more"></span><hr /><h2 id="题面解释">题面解释</h2><p>找出两个有序数组合并后的中位数. 但要求时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><h2 id="解法一-二分">解法一 二分</h2><p>笔者看到复杂度<span class="math inline">\(\mathit{O}(log(m +n))\)</span>第一想法便是二分, 但怎么二分? 两个数组只是内部有序,两个数组并不有序, 常规对数组二分的思路肯定是不行的.</p><p>那该如何进行二分呢, 对答案进行二分. 令k为所寻找的k阶数, 初始为中位数,则此时我们取两个数组的前<spanclass="math inline">\(k/2\)</span>部分出来, 比较<spanclass="math inline">\(nums1[k/2]\)</span>和<spanclass="math inline">\(nums2[k/2]\)</span>, 则可以直接排除<spanclass="math inline">\(k/2\)</span>个数. 我们以下图例子来解释.</p><img src="/2024/09/21/LeetCode-P4/p1.png" class="" title="p1"><p><span class="math inline">\(m = n = 4\)</span>, 我们有 <spanclass="math inline">\(k = 4, k/2 = 2\)</span>,于是我们取两个数组的前两位, 比较3和5, 不难看出, 1和3不可能是中位数.为什么? 因为1和3的阶必定小于<span class="math inline">\(k = 4\)</span>,即便第一个数组的3比第二个数组的5前面所有数都大, 3的阶也只能是3,1就更不必说了. 而5前面的数可能大于3后面的数(例子中未能体现,读者可以自行构造一个满足这种情况的简单例子). 因此通过这种操作,我们可以排掉 <span class="math inline">\(k/2\)</span>个不可能是中位数的元素, 接着我们令<span class="math inline">\(k = k -k/2\)</span>, 将被排除的数去掉, 重新进行上述过程.</p><img src="/2024/09/21/LeetCode-P4/p2.png" class="" title="p2"><p>选取两个数组的前1位.比较2 和 4, 可以排除掉2. 此时过程进行到了边界处,接下来<span class="math inline">\(k = 1\)</span>无法继续了.而此时剩下的4和5正是我们需要的中位数.</p><blockquote><p><strong>Tips:</strong> 为什么第二个数组不是选择2, 5, 7?</p><p>因为我们在上面的步骤中无法确定2和5是中位数与否, 此时的有效信息不足.而把2 5 7都放进来与4进行比较会出现bug, 以上例, 4会被错误的排除掉</p></blockquote><p>k为奇数时情况稍有不同, 但大多是一些细节问题, 笔者在此不再赘述.推荐读者自己构建一个例子去推算上面的过程, 相信不难理解其中要义.</p><p>每次排除<span class="math inline">\(k/2\)</span>, 而 <spanclass="math inline">\(k = (m + n + 1) / 2\)</span>, 故时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><p>参考代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; m; i++)&#123;cout &lt;&lt; nums1[i] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; n; j++)&#123;cout &lt;&lt; nums2[j] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = (m + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 排除掉小于中位数的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组被清空</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// 注意循环条件 k &gt; 1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 边界情况，剩余数组大小不足k</span></span><br><span class="line">            <span class="keyword">if</span> (left1 + mid &gt; m) &#123; <span class="comment">// 等价于 left1 + mid - 1 &gt;= m</span></span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 + mid &gt; n) &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                k -= mid2 - left2 + <span class="number">1</span>; <span class="comment">// 一轮可以排除掉一半</span></span><br><span class="line">                left2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= mid1 - left1 + <span class="number">1</span>;</span><br><span class="line">                left1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 k == 1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                    left2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="built_in">return</span> (nums2[left2] + nums2[left2 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[left1] + nums1[left1 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num1;</span><br><span class="line">            <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                num1 = nums2[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = nums1[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                num2 = nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                num2 = nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (num1 + num2) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 本题思路并不难想出或者说并不难理解,但非常考验代码功底, 对细节和边界情况的考察更像是此题的侧重点.还望看到此处的读者能静下心来调试代码, 祝早日AC.</p></blockquote><h2 id="解法二-分割">解法二 分割</h2><blockquote><p>笔者阅读题解时注意到的巧妙的解法, 原链接在此<ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/"><strong>P4|windliang</strong></a></p></blockquote><p>更详细的数学证明, 思路和代码请阅读原文,笔者在此只给出自己对其的理解.</p><p>本质来说, 两种方法殊途同归, 但分割的方法较为巧妙一些. 中位数,或者说k阶数, 就是将数组分为两个部分, 其一是比k阶数小的部分,其二是比k阶数大的部分.</p><p>对于有序的一个数组, 其性质本身就已经满足,我们不妨将两部分简称为左半部分(小)和右半部分(大). 对于两个有序数组,情况是一样的, 如果存在一种划分, 满足左边最大MaxLeft小于右边最小MinRight,我们则认为这是关于k阶数的一种有效划分.</p><p>因此, 这道题就被转化为寻找数组中满足中位数的有效划分,关于特定k阶数划分, 还需要满足左半部分和右半部分的数量关系,若规定将k阶数划在左半部分, 则左半部分有k个元素, 右半部分有 n - k个元素.</p><p>后面的事情就简单了, 固定数组1的划分位置,根据数量关系找到数组2待判定划分位置,根据MaxLeft和MinRight的大小关系决定数组1划分位置的左移或右移,该过程可以通过二分完成.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt; &lt;a
href=&quot;https://leetcode.cn/problems/median-of-two-sorted-arrays/&quot;&gt;&lt;strong&gt;LeetCode|4.寻找两个正序数组的中位数&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode刷题记录" scheme="http://la-pluma.github.io/categories/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="http://la-pluma.github.io/tags/LeetCode/"/>
    
    <category term="二分" scheme="http://la-pluma.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-机器学习 Ch0-Ch1</title>
    <link href="http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/"/>
    <id>http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/</id>
    <published>2024-09-18T15:04:27.000Z</published>
    <updated>2024-10-13T14:34:14.784Z</updated>
    
    <content type="html"><![CDATA[<p><strong>机器学习所研究的主要内容,是关于在计算机上从数据中产生"模型"(model)的算法, 即"学习算法"(learningalgorithm).</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter-0-主要符号表">Chapter 0: 主要符号表</a></li><li><a href="#chapter-1-绪论">Chapter 1: 绪论</a><ul><li><a href="#-11-基本术语">$ 1.1 基本术语</a></li><li><a href="#-13-假设空间">$ 1.3 假设空间</a></li><li><a href="#-14-归纳偏好">$ 1.4 归纳偏好</a></li></ul></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>《机器学习》周志华 2016.</p><p>大名鼎鼎的西瓜书, 笔者在此略去介绍.</p><h2 id="chapter-0-主要符号表">Chapter 0: 主要符号表</h2><p><span class="math display">\[\begin{aligned}&amp;\mathit{x}&amp; &amp;标量\\&amp;\boldsymbol{x}&amp; &amp;向量 \\&amp;\mathrm{x}&amp; &amp;变量集 \\&amp;\mathbf{A}&amp; &amp;矩阵 \\&amp;\mathbf{I}&amp; &amp;单位阵 \\&amp;\mathcal{X}&amp; &amp;样本空间或状态空间\\&amp;\mathcal{D}&amp; &amp;概率分布\\&amp;\mathit{D}&amp; &amp;数据样本(数据集)\\&amp;\mathcal{H}&amp; &amp;假设空间\\&amp;\mathit{H}&amp; &amp;假设集\\&amp;\mathfrak{L}&amp; &amp;学习算法\\&amp;\left ( \cdot ,\cdot ,\cdot  \right )&amp; &amp;行向量\\&amp;\left ( \cdot ;\cdot ;\cdot \right )&amp; &amp;列向量\\&amp;\left ( \cdot  \right )^{T}&amp; &amp;向量或矩阵转置\\&amp;\left \{  \cdot \cdot \cdot \right \}&amp; &amp;集合\\&amp;\left | \left \{ \cdot \cdot \cdot \right \} \right |&amp;&amp;集合中元素个数\\&amp;\left \| \cdot  \right \|_{p}&amp; &amp;L_p范数, p缺省时为L_2范数\\&amp;\mathit{P}\left ( \cdot  \right ),\mathit{P}\left ( \cdot|\cdot  \right )&amp; &amp;概率质量函数,条件概率质量函数\\&amp;\mathit{p}\left ( \cdot  \right ),\mathit{p}\left ( \cdot  | \cdot\right )&amp; &amp;概率密度函数, 条件概率密度函数\\&amp;\mathbb{E}_{\cdot \sim \mathcal{D}}\left [ f\! \left ( \cdot \right) \right ]&amp; &amp;函数 f\! \left ( \cdot \right ) 对 \cdot 在分布\mathcal{D} 下的数学期望:意义明确是将省略 \mathcal{D} 和(或)\cdot \\&amp;sup\left ( \cdot \right )&amp; &amp;上确界\\&amp;\mathbb{I} \left ( \cdot  \right )&amp; &amp;指示函数，在\cdot  为真和假分别取值为1 , 0 \\&amp;sign\left ( \cdot  \right )&amp; &amp;符号函数，在 \cdot &lt; 0, =0 , &gt;  0 时分别取值为 -1,0,1\end{aligned}\]</span></p><h2 id="chapter-1-绪论">Chapter 1: 绪论</h2><h3 id="基本术语">$ 1.1 基本术语</h3><blockquote><p>假定我们收集了一批关于西瓜的数据, 例如(色泽 = 浅白; 根蒂 = 蜷缩; 敲声= 浊响), (色泽 = 乌黑; 根蒂 = 稍蜷; 敲声 = 沉闷), (色泽 = 浅白; 根蒂 =硬挺; 敲声 = 清脆), ......, 每对括号内是一条记录,下文关于术语的表述会基于上述假定进行解释.</p></blockquote><ul><li><p><strong>数据集/样本(Data Set):</strong>这组记录的集合称为一个数据集.</p><blockquote><p><strong>Tips:</strong> 数据集亦称样本,因为数据集可看作对样本空间的一个采样.</p><p><strong>Addtional:</strong> "样本"的具体指代示例还是数据集,要看具体的上下文.</p></blockquote></li><li><p><strong>示例(Instance)/样本(Sample):</strong>每条记录称为示例/样本, 是关于一个事件或对象的描述(以上例,该对象为西瓜).</p></li><li><p><strong>属性(Attribute)/特征(Feature):</strong> "色泽", "根蒂","敲声"称为属性.</p></li><li><p><strong>属性值(Attribute Value):</strong>属性的取值称为属性值(以上例, "青绿"和"乌黑"是色泽的属性值).</p></li><li><p><strong>属性空间(Attribute Space)/样本空间(SampleSpace)/输入空间:</strong> 属性张成的空间.</p><blockquote><p><strong>Tips:</strong> 此处涉及的是线性代数知识,即将样本(Instance)依据属性转化为向量, 其中色泽, 根蒂和敲声为坐标轴,张成了一个用于描述西瓜特征的三维空间,该空间每个点即是线性代数意义上的一个向量, 也就是<strong>特征向量(FeatureVector)</strong>. 我们可以认为,示例(Instance)的另一种等价表述是特征向量.</p></blockquote></li><li><p><strong>数据集的表示:</strong> 令 <spanclass="math inline">\(\mathit{D} = \{x_1, x_2, ..., x_m\}\)</span>表示包含<span class="math inline">\(m\)</span>个示例的数据集, 每个示例由<span class="math inline">\(d\)</span> 个属性描述, 则每个示例(Instance)<span class="math inline">\(x_i= (x_{i1}; x_{i2}; ...; x_{id})\)</span>是 <span class="math inline">\(d\)</span> 维样本空间 <spanclass="math inline">\(\mathcal{X}\)</span> 中的一个向量, <spanclass="math inline">\(x_i \in \mathcal{X}\)</span>. <spanclass="math inline">\(d\)</span> 称为样本 <spanclass="math inline">\(x_i\)</span>的<strong>维数(Dimensionality)</strong>.</p></li><li><p><strong>学习(Learning)/训练(Training):</strong>从数据中学得模型的过程称为学习/训练,该过程通过执行某个学习算法完成.</p></li><li><p><strong>训练数据(Training Data):</strong>训练过程中所使用的数据.</p></li><li><p><strong>训练样本(Training Sample)/训练示例(TrainingInstance):</strong> 训练数据中的每个样本/示例.</p></li><li><p><strong>训练集(Training Set):</strong>训练样本组成的集合称为训练集.</p><blockquote><p><strong>Tips:</strong> 训练集相当于训练数据的子集,训练数据除去<strong>训练集</strong>外还存在<strong>验证集</strong>.(参考自:<ahref="https://zhuanlan.zhihu.com/p/115344944"><strong>知乎|训练集(trainingdataset), 测试集(test dataset)与验证集(validationdataset)</strong></a>)</p></blockquote></li><li><p><strong>假设(Hypothesis)&amp;真相/真实(Ground-Truth):</strong>学得模型对应了关于数据的某种潜在规律,因此亦称假设.这种潜在规律称为"真相"/"真实".学习的过程就是为了找出或逼近真相.</p><blockquote><p><strong>Tips:</strong> <ahref="https://en.wikipedia.org/wiki/Ground_truth"><strong>WIKIPEDIA|Ground-Truth</strong></a>又将其表述为<strong>基准真相</strong>.</p><p>"Ground truth is information that is known to be real or true,provided by direct observation and measurement (i.e. empirical evidence)as opposed to information provided by inference."</p></blockquote></li></ul><p><strong>Tips:</strong>本书有时又将<strong>模型</strong>称为<strong>学习器(Learner)</strong>,模型可看作是学习算法在给定数据和参数空间上的实例化.</p><ul><li><p><strong>标记(Label):</strong> 关于示例(Instance)结果的信息,称为标记(如"好瓜"). 一般的, 用 <span class="math inline">\((x_i,y_i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个样例, 其中<span class="math inline">\(y_i \in \mathcal{Y}\)</span> 是示例 <spanclass="math inline">\(x_i\)</span> 的标记, <spanclass="math inline">\(\mathcal{Y}\)</span> 是所有标记的集合,又称<strong>标记空间(Label Space)/输出空间</strong>.</p></li><li><p><strong>分类(Classification):</strong>若<strong>预测(Prediction)</strong>的是离散值(如"好瓜", "坏瓜"),则称此类学习任务是分类.</p></li><li><p><strong>回归(Regression):</strong> 若预测的是连续值(如成熟度0.95,0.7), 则称此类学习任务是回归.</p></li><li><p><strong>二分类(Binary Classification):</strong>只涉及两个类别的分类任务, 通常称其中一类为<strong>正类(PositiveClass)</strong>, 另一类为<strong>反类(Negative Class)</strong>.</p></li><li><p><strong>多分类(Multi-class Classification):</strong> 与之相对的,涉及多种类别的分类任务称为多分类任务.</p></li><li><p><strong>预测任务:</strong> 预测任务希望通过对训练集<spanclass="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m,y_m)\}\)</span> 进行学习, 建立一个从输入空间 <spanclass="math inline">\(\mathcal{X}\)</span> 到输出空间 <spanclass="math inline">\(\mathcal{Y}\)</span> 的映射 <spanclass="math inline">\(f : \mathcal{X} \rightarrow \mathcal{Y}\)</span>.对二分类, 通常取 <span class="math inline">\(\mathcal{Y} = \{-1,1\}\)</span> 或 <span class="math inline">\(\{0, 1\}\)</span>;对于多分类, <span class="math inline">\(|\mathcal{Y}| &gt; 2\)</span>;对于回归, <span class="math inline">\(\mathcal{Y} =\mathbb{R}\)</span>.</p></li><li><p><strong>测试(Testing):</strong>使用学习得到的模型进行预测的过程称为测试,预测的样本称为<strong>测试样本(Testing Sample)/测试示例(TestingInstance)</strong>.</p></li><li><p><strong>聚类(Clustering):</strong> 将训练集中的样本分为若干组,每组称为一个<strong>簇(Cluster)</strong>.</p><blockquote><p><strong>Tips:</strong> 形成的簇可能对应一些潜在的概念划分(如本地瓜,外地瓜), 但这样的概念我们事先不知道,否则通过标记(Label)就可以形成簇划分.</p></blockquote></li><li><p><strong>监督学习(Supervised Learning)/有导师学习:</strong>训练数据拥有标记信息, 分类和回归为代表.</p></li><li><p><strong>无监督学习(Unsupervised Learning)/无导师学习</strong>训练数据无标记信息, 聚类为代表.</p></li></ul><blockquote><p><strong>Tips:</strong> 此处仅作最基本的概念了解,关于上述两概念的具体释义留及之后的学习.</p></blockquote><ul><li><p><strong>泛化(Generalization):</strong>学得模型适用于新样本的能力,称为泛化能力.</p><blockquote><p><strong>Tips1:</strong> 样本空间通常很大, 训练过程无法涵盖所有的示例,我们希望模型可以对新样本有较好的目标表现, 这就是泛化的意义.</p><p><strong>Tips2:</strong> 泛化的数学支撑:</p><p>关于这种泛化,我们通常假设样本空间中的所有样本都服从一个未知的<strong>分布(Distribution)</strong><span class="math inline">\(\mathcal{D}\)</span>,获取的样本是从该分布上采样获得的, 满足<strong>独立同分布(Independent andIdentically Distributed, <em>i.d.d</em>)</strong>.</p><p>关于机器学习中为什么使用i.d.d, 可以从<ahref="https://www.zhihu.com/question/41222495"><strong>知乎|为什么机器学习中,要假设我们的数据是独立同分布的?</strong></a>获取相关信息.</p></blockquote></li></ul><h3 id="假设空间">$ 1.3 假设空间</h3><p><strong>归纳(Induction)</strong>与<strong>演绎(Deduction)</strong>是科学推理的两大基本手段.</p><blockquote><p>前者是从特殊到一般的<strong>泛化(Generalization)</strong>过程;后者是从一般到特殊的<strong>特化(Specialization)</strong>过程.</p></blockquote><ul><li><p><strong>归纳学习(Inductive Learning):</strong>广义的归纳学习大体相当于从样例中学习,狭义的归纳学习要求从学习过程中习得<strong>概念(concept)</strong>,亦称<strong>概念学习/概念形成</strong>.</p></li><li><p><strong>版本空间(Version Space):</strong>存在一个与训练集一致的"假设集合", 称为版本空间, 例如:</p></li></ul><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/table1-1.png" class="" title="table1-1"><p>其假设空间为</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-1.png" class="" title="pic1-1"><p>其版本空间为</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-2.png" class="" title="pic1-2"><blockquote><p><strong>Tips:</strong> 在该数据集中, 好瓜具有的共同特征是蜷缩和浊响.因此色泽标识为通配符 <span class="math inline">\(*\)</span>, 同时,第一行的两种假设同样是与训练集一致的(可以匹配好瓜).</p></blockquote><h3 id="归纳偏好">$ 1.4 归纳偏好</h3><ul><li><p><strong>归纳偏好(Inductive bias):</strong>算法在学习过程中对某种类型假设的偏好称为归纳偏好.</p><blockquote><p><strong>Tips:</strong><strong>任何</strong>一个有效的机器学习算法必有其归纳偏好,否则它无法产生确定的学习结果.</p><p>以图1-2的版本空间为例, 对新瓜(色泽=青绿;根蒂=蜷缩;敲声=沉闷),若模型告诉我们这种瓜时好时坏则没有意义,模型必须对给定的样本给予确定的结果.</p><p><strong>Additional:</strong>归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或"价值观".常遵循<strong>奥卡姆剃刀(Occam'sRazor)</strong>原则(<strong>若有多个假设与观察一致,则选简单的那个</strong>).</p></blockquote></li></ul><p>接下来我们来比较不同归纳偏好的优劣</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-3.png" class="" title="pic1-3"><p>从直观上看我们一般会认为, 拟合出平滑的曲线A要优于曲线B, 但很遗憾,当面临一些极端数据时, 曲线B可能会优于曲线A, 情形如下图所示.</p><img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-4.png" class="" title="pic1-4"><p>接下来我们用数学语言尝试量化模型的优劣.</p><p>假设样本空间 <span class="math inline">\(\mathcal{X}\)</span>和假设空间 <span class="math inline">\(\mathcal{H}\)</span> 都是离散的,令 <span class="math inline">\(P(h|X, \mathfrak{L})\)</span>代表学习算法 <span class="math inline">\(\mathfrak{L}_a\)</span>基于训练数据 <span class="math inline">\(X\)</span> 产生假设 <spanclass="math inline">\(h\)</span> 的概率, 令 <spanclass="math inline">\(f\)</span> 为目标函数.则 <spanclass="math inline">\(\mathfrak{L}_a\)</span>在训练集外的所有样本上的误差为</p><p><span class="math display">\[\begin{equation} \label{eq1.1}E_{ote}(\mathfrak{L}_a|X, f) = \sum_h \sum_{x \in \mathcal{X} -X} P(x)\mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\tag{1.1}\end{equation}\]</span></p><blockquote><p><strong>Tips:</strong>以下是笔者个人对该公式的理解,可能存在疏漏或错误.</p><p>首先看乘起来的的三个式子, <spanclass="math inline">\(\mathbb{I}\)</span> 为指示函数, 代表的含义是假设<span class="math inline">\(h\)</span> 与目标函数 <spanclass="math inline">\(f\)</span> 没有误差时取0, 存在误差时取1. 若取1,则两个概率乘积表示在给定的<span class="math inline">\(x\)</span>和<spanclass="math inline">\(h\)</span>下, 存在误差的概率.</p><p>接下来的两个求和就不难理解了, 分别是对<spanclass="math inline">\(x\)</span>的所有取值求和以及对<spanclass="math inline">\(h\)</span>的所有取值求和, 权重为特定<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(h\)</span>的概率.</p></blockquote><p>为简化问题, 考虑二分类, 真实目标函数<spanclass="math inline">\(f\)</span>可以是任何函数<spanclass="math inline">\(\mathcal{X} \rightarrow \{0,1\}\)</span>,函数空间<span class="math inline">\(\{0,1\}^{|\mathcal{X}|}\)</span>.对所有可能的<spanclass="math inline">\(f\)</span>按均匀分布对误差求和,有</p><p><span class="math display">\[\begin{align} \nonumber\sum_f E_{ote}(\mathfrak{L}_a|x, f) &amp;= \sum_f \sum_h \sum_{x \in\mathcal{X} -X} P(x) \mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\\\nonumber&amp;= \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)\sum_f \mathbb{I}(h(x) \neq f(x))\\ \nonumber^*&amp;=  \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)\frac{1}{2}2^{|\mathcal{X}|}\\ \nonumber&amp;= \frac{1}{2}2^{|\mathcal{X}|} \sum_{x \in \mathcal{X} -X} P(x)\cdot 1 \tag{1.2}\end{align}\]</span></p><blockquote><p><strong>Tips:</strong> 标识<spanclass="math inline">\(*\)</span>的一步因为若<spanclass="math inline">\(f\)</span>均匀分布, 则有一半的<spanclass="math inline">\(f\)</span>对<spanclass="math inline">\(x\)</span>的预测与<spanclass="math inline">\(h(x)\)</span>不一致.</p></blockquote><p>式(1.2)指出, 误差与学习算法<spanclass="math inline">\(\mathfrak{L}\)</span>无关! 对于任意学习算法<spanclass="math inline">\(\mathfrak{L}_a\)</span>和<spanclass="math inline">\(mathfrak{L}_b\)</span>,有</p><p><span class="math display">\[\begin{equation}\sum_f E_{ote}(\mathfrak{L}_a|X, f) = \sum_f E_{ote}(\mathfrak{L}_b|X,f) \tag{1.3}\end{equation}\]</span></p><p>这简直糟糕透了, 似乎所有的学习算法期望性能居然都相同.这就是<strong>没有免费午餐定理(No Free Lunch Theorem, NFL)</strong>.</p><blockquote><p><strong>Tips:</strong> 原书的证明是多重假设下的简化论述,对严格数学证明感兴趣的读者可以自行查阅相关资料.</p></blockquote><p>但是, NFL定理有一个重要前提, 它假定了所有问题出现的机会相等,所有问题同等重要(例如上述证明中假设了<spanclass="math inline">\(f\)</span>均匀分布).但我们并不要求模型对所有情况都能给出一个好的解决方案,往往我们希望模型对特定问题表现是好的.</p><blockquote><p><strong>Tips:</strong> 原书中举了一个简单的例子,骑自行车从南京鼓楼到南京新街口显然是好方案(距离约两站地铁),但骑自行车从南京鼓楼到北京新街口, 显然不是好的方案,但我们不care.</p></blockquote><p>简单来说,NFL定理指出了<strong>没有一种机器学习算法是适用于所有情况的</strong>,只有针对具体问题, 才能谈论模型的优劣.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;机器学习所研究的主要内容,
是关于在计算机上从数据中产生&quot;模型&quot;(model)的算法, 即&quot;学习算法&quot;(learning
algorithm).&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="机器学习" scheme="http://la-pluma.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-大话设计模式 Ch0</title>
    <link href="http://la-pluma.github.io/2024/09/10/BookNote-DesignPatterns-by-JieCheng-1/"/>
    <id>http://la-pluma.github.io/2024/09/10/BookNote-DesignPatterns-by-JieCheng-1/</id>
    <published>2024-09-10T11:45:47.000Z</published>
    <updated>2024-09-24T15:06:15.318Z</updated>
    
    <content type="html"><![CDATA[<p><strong>精彩的代码是如何想出来的,要比看到精彩的代码更加令人期待.</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter-0-preview-面向对象基础">Chapter 0: Preview面向对象基础</a></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>《大话设计模式》程杰 2007.</p><p>本文<strong><em>不提供</em></strong>书籍的电子版文件,请有需要的读者移步至<strong>Z-library</strong>或其他渠道获得.</p><p>本书以情景对话形式, 辅以故事或例子介绍设计模式, 以C#语言书写代码,适合有面向过程编程基础但面向对象编程能力弱的初学者.</p><h2 id="chapter-0-preview-面向对象基础">Chapter 0: Preview面向对象基础</h2><blockquote><p>附录A 培训实习生——面向对象基础</p><p><strong>Tips:</strong> 本部分不设计具体的语法细节, 特性和原理,仅作示例, 如有需去可移步至专业书籍文献寻求细节, 如<ahref="https://learn.microsoft.com/en-us/dotnet/csharp/"><strong>微软官方</strong></a>或书籍<ahref="https://book.douban.com/subject/34894447/"><strong>C#图解教程</strong></a>.</p></blockquote><ul><li><p><strong>对象(Object):</strong> 对象是一个自包含的实体,用一组可识别的特性和行为来标识.</p><blockquote><p><strong>Tips:</strong> 定义比较拗口, 通俗来说, 对象是对事物的抽象,一切事物都可以称为对象.</p></blockquote></li><li><p><strong>面向对象编程(Object-Oriented Programming):</strong>面向对象的编程.</p><blockquote><p><strong>Tips:</strong> 简称OOP, 区别于面向过程编程,面向过程需要分析得出步骤, 按序实现程序功能. OOP首先对事物抽象为"对象",用对象的属性和行为解决问题.</p></blockquote></li><li><p><strong>类(Class):</strong>具有相同属性和功能对象的抽象集合.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">shout</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mew&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>实例(Instance) &amp; 实例化:</strong> 实例是真实的对象,new得到实例的过程称为实例化.</p><blockquote><p><strong>Tips:</strong> 类就像是工厂的蓝图, 实例就是生产出来的产品,一个类只有实例化后才可以调用(可能不严谨, 存疑), 和蓝图与产品一样,一个类可以实例化出多个不同的实例(<strong>学生类</strong>可以实例化为<strong>学生李华</strong>,<strong>学生张三</strong>等).</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><ul><li><p><strong>修饰符:</strong></p><ul><li><p><strong>public:</strong> 修饰的类成员允许被任何类访问</p></li><li><p><strong>protected:</strong>修饰的类成员仅允许该类和其子类访问</p></li><li><p><strong>private:</strong> 修饰的类成员仅允许该类访问</p><blockquote><p><strong>Tips:</strong> 程序设计是一门权衡和妥协的艺术,对OOP为何如此设计的读者可自行查阅OOP发展的历史.</p></blockquote></li></ul></li><li><p><strong>属性:</strong> 属性是一个方法或一对方法,在调用它的代码看来, 它是一个字段,即属性适合于以字段的方法使用方法调用的场合.</p></li><li><p><strong>字段:</strong> 储存类设计所需的数据,形式上是与类相关的变量.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> num; <span class="comment">//声明一个私有内部字段, 修饰符private</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Num &#123; <span class="comment">//Num公有外部属性, 修饰符public</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="comment">//外部读取方法</span></span><br><span class="line">            <span class="keyword">return</span> Num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="comment">//外部修改方法, 删去此方法时表示Num是只读的.</span></span><br><span class="line">            Num = <span class="keyword">value</span>; <span class="comment">// set含有隐式参数, 由关键字value表示, 用于赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 属性和字段的描述比较抽象,推荐直接结合代码理解. 笔者认为是一种语法糖上的tricky,在其他语言OOP也有相似的写法. 这种写法的好处是隔离内部与外部,仅允许类提供的公共方法访问类内成员变量.</p></blockquote><ul><li><p><strong>构造方法/构造函数:</strong> 对类进行初始化的方法.与类同名, 无返回值, 不需要void, 在new中调用.</p><blockquote><p><strong>Tips:</strong> 以上语法细节适用于C#, 非C#可能会有差别,类中不显示写明构造函数时由编译器默认构造(更多语法细节和原理请移步至讨论C#的相关文献).</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123; <span class="comment">//这是构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>重载(overload):</strong>提供了创建多个同名方法(Function)的功能, 重载方法的参数类型不同.重载可以在不改变原方法基础上添加新功能.</p><blockquote><p><strong>Tips:</strong>这里<strong>参数类型的不同</strong>指的是参数个数不同或参数类型的不同(详见代码示例)</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="comment">//不仅构造函数, 普通函数也可以重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>()</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1, <span class="built_in">float</span> arg_2</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1, <span class="built_in">int</span> arg_2</span>)</span>&#123;&#125;;<span class="comment">//类型顺序不同也会被认为是重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>封装:</strong> 每个对象包含该对象操作所需的所有信息,不必依赖其他对象来完成自己的操作, 该特性称为封装.</p><blockquote><p><strong>Addtional:</strong> 良好的封装可以减少耦合,类内部实现可以自由修改, 具有清晰的对外接口</p></blockquote></li><li><p><strong>继承:</strong>对象的继承代表了一种"<strong>is-a</strong>"关系, 若描述为"B是A",则认为B可以继承A. 又可以理解为B是A的一种特殊化, B拥有A的特性之外,还拥有自己独特的特性. 即继承代表了一种包含关系, A包含B.</p><blockquote><strong>Addtional:</strong><ul><li>继承的双方称为<strong>子类/派生类&amp;父类/基类</strong>.</li><li>子类继承父类的成员有方法, 域, 属性, 事件, 索引指示器</li><li>构造方法<strong>无法</strong>继承, 只能调用,可以使用<strong>base</strong>关键字(C#语法特性)</li></ul></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>()</span> &#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;unamed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> shoutNum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ShoutNum &#123; <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> shoutNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            shoutNum = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Cat</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;mew &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Dog</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;woof &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong>继承的<strong>优点</strong>是使子类公共部分放在了父类, 代码得到了共享,减少了代码重复, 修改和扩展都变得相对容易.但<strong>缺点</strong>也是显而易见的, 继承会破坏封装,父类实现的细节暴露给子类, 父类和子类间是强耦合的.</p></blockquote><ul><li><p><strong>多态:</strong> 多态表示不同的对象可以执行相同的动作,但通过自己的代码执行.</p><blockquote><strong>Additional:</strong><ul><li>子类以父类身份出现</li><li>子类工作时以自己的方式实现</li><li>子类以父类身份出现时, 无法使用子类特有的属性和方法</li></ul><p><strong>Tips:</strong> 在父类中, 该动作需要声明为虚拟的,用关键字<strong>virtual</strong>标识.</p></blockquote></li><li><p><strong>重写/覆写(override):</strong>子类使用关键字<strong>override</strong>将父类实现替换为自己的实现.</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//声明为虚方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*执行环境*/</span></span><br><span class="line"></span><br><span class="line">arrayAnimal = <span class="keyword">new</span> Animal[<span class="number">5</span>];</span><br><span class="line">arrayAnimal[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line">arrayAnimal[<span class="number">1</span>] = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">foreach</span>(Animal item <span class="keyword">in</span> arrayAnimal)&#123;</span><br><span class="line">    MessageBox.Show(item.Shout()); <span class="comment">//Cat为&quot;mew&quot;, Dog为&quot;woof&quot;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips1:</strong> C#的多态性分为静态多态性和动态多态性.静态多态性即为前文提到的overload重载, 在编译时确定;动态多态性为override覆写, 在运行时确定,通过抽象类(见下文)和虚方法实现.</p><p><strong>Tips2:</strong> 笔者在翻阅相关资料时,在C++语言中发现了更为复杂的机制, overwrite重写和override覆写存在区别,详见<ahref="https://www.cnblogs.com/kuliuheng/p/4107012.html"><strong>博客园|C++中的Overload、Override和Overwrite</strong></a></p><p><strong>Addtional:</strong> 原书对上述实现Animal Shout的代码进行重构,具体方法为将Shout()声明为父类公共方法(去掉virtual),声明新的虚方法getSound(), 在Shout()中调用, 在子类中覆写(override),从而避免了代码重复, 此处笔者不再浪费篇幅详细赘述.</p></blockquote><ul><li><p><strong>抽象类&amp;抽象方法:</strong>C#允许将类和方法用关键字<strong>abstract</strong>声明, 即抽象类,抽象方法.</p><blockquote><strong>Addtional:</strong><ul><li>抽象类不能被实例化</li><li>抽象方法必须被子类覆写(override)</li><li>含有抽象方法的类必须声明为抽象类, 不论是否具有一般方法</li><li>使用时考虑让抽象类拥有尽可能多的共同代码, 拥有尽可能少的数据</li></ul><p><strong>Tips:</strong> 抽象类通常代表一种抽象概念,提供了一个继承的出发点, 当设计一个新的抽象类时, 一定是用来继承的.因此在继承结构中, 叶节点应当是具体类, 非叶节点应当是抽象类.</p></blockquote></li><li><p><strong>接口(Interface):</strong>接口是把隐式公共方法和属性组合起来, 以封装特定功能的一个集合.类实现了接口就可以支持接口所指定的所有属性和成员.接口不允许提供任何成员的执行方法(因此接口不能实例化, 没有构造方法,字段和修饰符, 不能声明静态或虚拟等).</p><blockquote><strong>Addtionnal:</strong><ul><li>实现接口的类必须实现接口中所有方法和属性.</li><li>一个类可以支持多个接口, 不同类也可以支持相同接口.</li></ul><p><strong>Tips:</strong> <ahref="https://www.runoob.com/csharp/csharp-interface.html">菜鸟教程|C#Interface</a>将接口表述为:</p><p>接口定义了所有类继承接口时应遵循的语法合同.接口定义了语法合同"是什么"部分, 派生类定义了语法合同"怎么做"部分.接口定义了属性, 方法和事件, 这些都是接口的成员. 接口只包含了成员的声明.成员的定义是派生类的责任. 接口提供了派生类应遵循的标准结构.</p><p><strong>书写规范:</strong> 接口的命名需要在前面加一个大写"I".</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 笔者在此化简了书目中提供的例子, 能理解即可.</span></span><br><span class="line"><span class="comment">// 叮当猫继承自上文出现的Cat类, 内部需要实现变东西的接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MachineCat</span> : <span class="title">Cat</span>, <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>&#123; <span class="comment">//实现接口, 不需要使用override修饰</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.Shout() + <span class="string">&quot;我有万能口袋, 可以变出: &quot;</span> + thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Additional:</strong> 笔者在此补充一点C#的语法特性,接口也可以继承接口, 假设IB继承IA, 在IB中不需要声明IA中的声明,但实现IB的类需要实现IA和IB中的所有声明.</p><p><strong>Compare: Class v.s. Interface</strong></p><ul><li><strong>语法上:</strong> 抽象类可以给出一些成员的实现,接口不能包含成员的实现, 抽象类的抽象成员可被子类部分实现,但接口的成员需要类全部实现, 一个类只能继承<strong>一个</strong>抽象类,但可以实现<strong>多个</strong>接口.</li><li><strong>含义上:</strong> 类是对象的抽象, 抽象类是对类的抽象,接口是对<strong>行为</strong>的抽象.</li><li><strong>使用上:</strong> 如果行为跨越不同类的对象, 可使用接口;对于一些相似的类对象, 用继承抽象类. 需要注意的是,实现接口和继承抽象类并不冲突.</li><li><strong>设计角度上:</strong> 抽象类是从子类中发现了公共的东西,泛化出父类, 然后子类继承父类, 而接口根本不知道子类的存在,方法如何实现不明确, 预先定义.</li></ul></blockquote><ul><li><p><strong>泛型(Generic):</strong> 泛型是具有占位符(类型参数)的类,结构, 接口和方法, 这些占位符是类, 结构,接口和方法所储存域或使用的一个或多个类型的占位符.泛型集合类可以将类型参数用作它所存储的对象的类型的占位符:类型参数作为其字段的类型和其方法的参数类型出现.</p><blockquote><p><strong>Additional:</strong> 通常情况下, 都建议使用泛型集合,因为这样可以获得类型安全的直接优点而不需要从基集合类型派生并实现类型特定成员.此外, 如果集合元素为值类型,泛型集合类型的性能通常优于对应的非泛型集合类型,因为使用泛型时不必对元素进行装箱.</p><p><strong>Tips:</strong> <ahref="https://www.runoob.com/csharp/csharp-generic.html">菜鸟教程|C#Generic</a>将泛型表述为:</p><p>泛型(Generic)允许您延迟编写类或方法中的编程元素的数据类型的规范,直到实际在程序中使用它的时候. 换句话说,泛型允许您编写一个可以与任何数据类型一起工作的类或方法.</p><p>泛型的定义较为晦涩, 建议结合代码理解.笔者在此强烈建议阅读更多的资料来学习泛型.</p></blockquote></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic; <span class="comment">//增加泛型集合命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Forml</span> : <span class="title">Form</span>&#123;</span><br><span class="line">    IList&lt;Animal&gt; arrayAnimal; <span class="comment">// 声明泛型集合变量, 表示只接受Animal类型</span></span><br><span class="line">    <span class="comment">//List&lt;Animal&gt; arrayAnimal; 两种写法是等价的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Event</span>()</span>&#123;</span><br><span class="line">        arrayAnimal = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Cat());</span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Dog());</span><br><span class="line">        arrayAnimal.Add(<span class="number">123</span>); <span class="comment">// Error! Invalid Type </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>委托:</strong> 委托是对函数的封装,可以当作给方法的特征指定一个名称.委托对象用关键字<strong>delegate</strong>声明.</p></li><li><p><strong>事件:</strong> 事件时委托的一种特殊形式,当发生有意义的事情时, 事件对象处理通知过程.事件对象用关键字<strong>event</strong>声明.</p></li></ul><blockquote><p><strong>Additional:</strong> 委托是一种引用方法的类型,一旦为委托分配了方法, 委托将与该方法具有完全相同的行为.事件则是在发生其他类或对象关注的事情时, 类或对象可通过事件通知它们.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情境: 猫Tom叫的时候两只老鼠Jerry和Jack要跑.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>()</span>; <span class="comment">// 声明委托</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout; <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span> (CatShout != <span class="literal">null</span>)&#123; <span class="comment">// 如果声明了事件CatShout</span></span><br><span class="line">            CatShout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫来了, &#123;0&#125;快跑&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    Mouse mouse1 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    Mouse mouse2 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse1.Run);</span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse2.Run); </span><br><span class="line">    <span class="comment">// &quot;+=&quot; 表示 &quot;add_CatShout&quot; 的意思; 与之相反 &quot;-=&quot; 表示 &quot;remove_CatShout()&quot;</span></span><br><span class="line"></span><br><span class="line">    cat.Shout();</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫来了, Jerry快跑!</span><br><span class="line">老猫来了, Jack快跑!</span><br></pre></td></tr></table></figure><ul><li><strong>EventArgs:</strong> EventArgs是包含事件数据的类的基类.</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CatShoutEventArgs</span> : <span class="title">EventArgs</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span>(CatShout != <span class="literal">null</span>)&#123;</span><br><span class="line">            CatShoutEventArgs e = <span class="keyword">new</span> CatShoutEventArgs();</span><br><span class="line">            e.Name = <span class="keyword">this</span>.name;</span><br><span class="line">            CatShout(<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫&#123;0&#125;来了, &#123;1&#125;快跑!&quot;</span>, args.Name, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main执行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫Tom来了, Jerry快跑!</span><br><span class="line">老猫Tom来了, Jack快跑!</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;精彩的代码是如何想出来的,
要比看到精彩的代码更加令人期待.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://la-pluma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>千里之行，始于足下</title>
    <link href="http://la-pluma.github.io/2024/09/08/hello-world/"/>
    <id>http://la-pluma.github.io/2024/09/08/hello-world/</id>
    <published>2024-09-08T12:56:57.000Z</published>
    <updated>2024-09-12T15:49:07.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong>A journey of a thousand miles begins with a singlestep.</strong></p><span id="more"></span><img src="/2024/09/08/hello-world/picture.png" class="" title="picture">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;A journey of a thousand miles begins with a single
step.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
