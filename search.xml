<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>读书笔记-大话设计模式 Ch0</title>
    <url>/BookNote-DesignPatterns-by-JieCheng-1/</url>
    <content><![CDATA[<p><strong>精彩的代码是如何想出来的,
要比看到精彩的代码更加令人期待.</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#书籍基本信息">书籍基本信息</a></li>
<li><a href="#chapter-0-preview-面向对象基础">Chapter 0: Preview
面向对象基础</a></li>
</ul>
<hr />
<h2 id="书籍基本信息">书籍基本信息</h2>
<p>《大话设计模式》程杰 2007.</p>
<p>本文<strong><em>不提供</em></strong>书籍的电子版文件,
请有需要的读者移步至<strong>Z-library</strong>或其他渠道获得.</p>
<p>本书以情景对话形式, 辅以故事或例子介绍设计模式, 以C#语言书写代码,
适合有面向过程编程基础但面向对象编程能力弱的初学者.</p>
<h2 id="chapter-0-preview-面向对象基础">Chapter 0: Preview
面向对象基础</h2>
<blockquote>
<p>附录A 培训实习生——面向对象基础</p>
<p><strong>Tips:</strong> 本部分不设计具体的语法细节, 特性和原理,
仅作示例, 如有需去可移步至专业书籍文献寻求细节, 如<a
href="https://learn.microsoft.com/en-us/dotnet/csharp/"><strong>微软官方</strong></a>或书籍<a
href="https://book.douban.com/subject/34894447/"><strong>C#图解教程</strong></a>.</p>
</blockquote>
<ul>
<li><p><strong>对象(Object):</strong> 对象是一个自包含的实体,
用一组可识别的特性和行为来标识.</p>
<blockquote>
<p><strong>Tips:</strong> 定义比较拗口, 通俗来说, 对象是对事物的抽象,
一切事物都可以称为对象.</p>
</blockquote></li>
<li><p><strong>面向对象编程(Object-Oriented Programming):</strong>
面向对象的编程.</p>
<blockquote>
<p><strong>Tips:</strong> 简称OOP, 区别于面向过程编程,
面向过程需要分析得出步骤, 按序实现程序功能. OOP首先对事物抽象为"对象",
用对象的属性和行为解决问题.</p>
</blockquote></li>
<li><p><strong>类(Class):</strong>
具有相同属性和功能对象的抽象集合.</p></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">shout</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mew&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>实例(Instance) &amp; 实例化:</strong> 实例是真实的对象,
new得到实例的过程称为实例化.</p>
<blockquote>
<p><strong>Tips:</strong> 类就像是工厂的蓝图, 实例就是生产出来的产品,
一个类只有实例化后才可以调用(可能不严谨, 存疑), 和蓝图与产品一样,
一个类可以实例化出多个不同的实例(<strong>学生类</strong>可以实例化为<strong>学生李华</strong>,
<strong>学生张三</strong>等).</p>
</blockquote></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>修饰符:</strong></p>
<ul>
<li><p><strong>public:</strong> 修饰的类成员允许被任何类访问</p></li>
<li><p><strong>protected:</strong>
修饰的类成员仅允许该类和其子类访问</p></li>
<li><p><strong>private:</strong> 修饰的类成员仅允许该类访问</p>
<blockquote>
<p><strong>Tips:</strong> 程序设计是一门权衡和妥协的艺术,
对OOP为何如此设计的读者可自行查阅OOP发展的历史.</p>
</blockquote></li>
</ul></li>
<li><p><strong>属性:</strong> 属性是一个方法或一对方法,
在调用它的代码看来, 它是一个字段,
即属性适合于以字段的方法使用方法调用的场合.</p></li>
<li><p><strong>字段:</strong> 储存类设计所需的数据,
形式上是与类相关的变量.</p></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> num; <span class="comment">//声明一个私有内部字段, 修饰符private</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Num &#123; <span class="comment">//Num公有外部属性, 修饰符public</span></span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="comment">//外部读取方法</span></span><br><span class="line">            <span class="keyword">return</span> Num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="comment">//外部修改方法, 删去此方法时表示Num是只读的.</span></span><br><span class="line">            Num = <span class="keyword">value</span>; <span class="comment">// set含有隐式参数, 由关键字value表示, 用于赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips:</strong> 属性和字段的描述比较抽象,
推荐直接结合代码理解. 笔者认为是一种语法糖上的tricky,
在其他语言OOP也有相似的写法. 这种写法的好处是隔离内部与外部,
仅允许类提供的公共方法访问类内成员变量.</p>
</blockquote>
<ul>
<li><p><strong>构造方法/构造函数:</strong> 对类进行初始化的方法.
与类同名, 无返回值, 不需要void, 在new中调用.</p>
<blockquote>
<p><strong>Tips:</strong> 以上语法细节适用于C#, 非C#可能会有差别,
类中不显示写明构造函数时由编译器默认构造(更多语法细节和原理请移步至讨论C#的相关文献).</p>
</blockquote></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123; <span class="comment">//这是构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>重载(overload):</strong>
提供了创建多个同名方法(Function)的功能, 重载方法的参数类型不同.
重载可以在不改变原方法基础上添加新功能.</p>
<blockquote>
<p><strong>Tips:</strong>
这里<strong>参数类型的不同</strong>指的是参数个数不同或参数类型的不同(详见代码示例)</p>
</blockquote></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Example</span>&#123;</span><br><span class="line">    <span class="comment">//不仅构造函数, 普通函数也可以重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>()</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">int</span> arg_1, <span class="built_in">float</span> arg_2</span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">function</span>(<span class="params"><span class="built_in">float</span> arg_1, <span class="built_in">int</span> arg_2</span>)</span>&#123;&#125;;<span class="comment">//类型顺序不同也会被认为是重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>封装:</strong> 每个对象包含该对象操作所需的所有信息,
不必依赖其他对象来完成自己的操作, 该特性称为封装.</p>
<blockquote>
<p><strong>Addtional:</strong> 良好的封装可以减少耦合,
类内部实现可以自由修改, 具有清晰的对外接口</p>
</blockquote></li>
<li><p><strong>继承:</strong>
对象的继承代表了一种"<strong>is-a</strong>"关系, 若描述为"B是A",
则认为B可以继承A. 又可以理解为B是A的一种特殊化, B拥有A的特性之外,
还拥有自己独特的特性. 即继承代表了一种包含关系, A包含B.</p>
<blockquote>
<strong>Addtional:</strong>
<ul>
<li>继承的双方称为<strong>子类/派生类&amp;父类/基类</strong>.</li>
<li>子类继承父类的成员有方法, 域, 属性, 事件, 索引指示器</li>
<li>构造方法<strong>无法</strong>继承, 只能调用,
可以使用<strong>base</strong>关键字(C#语法特性)</li>
</ul>
</blockquote></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>()</span> &#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;unamed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> shoutNum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ShoutNum &#123; <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> shoutNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            shoutNum = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Cat</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;mew &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; <span class="comment">//继承父类Animal的子类Dog</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>() : <span class="title">base</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shoutNum; i++)&#123;</span><br><span class="line">            result += <span class="string">&quot;woof &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips:</strong>
继承的<strong>优点</strong>是使子类公共部分放在了父类, 代码得到了共享,
减少了代码重复, 修改和扩展都变得相对容易.
但<strong>缺点</strong>也是显而易见的, 继承会破坏封装,
父类实现的细节暴露给子类, 父类和子类间是强耦合的.</p>
</blockquote>
<ul>
<li><p><strong>多态:</strong> 多态表示不同的对象可以执行相同的动作,
但通过自己的代码执行.</p>
<blockquote>
<strong>Additional:</strong>
<ul>
<li>子类以父类身份出现</li>
<li>子类工作时以自己的方式实现</li>
<li>子类以父类身份出现时, 无法使用子类特有的属性和方法</li>
</ul>
<p><strong>Tips:</strong> 在父类中, 该动作需要声明为虚拟的,
用关键字<strong>virtual</strong>标识.</p>
</blockquote></li>
<li><p><strong>重写/覆写(override):</strong>
子类使用关键字<strong>override</strong>将父类实现替换为自己的实现.</p></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//声明为虚方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span>&#123; <span class="comment">//覆写</span></span><br><span class="line">        ....... <span class="comment">//略, 代码见上文</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*执行环境*/</span></span><br><span class="line"></span><br><span class="line">arrayAnimal = <span class="keyword">new</span> Animal[<span class="number">5</span>];</span><br><span class="line">arrayAnimal[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line">arrayAnimal[<span class="number">1</span>] = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">foreach</span>(Animal item <span class="keyword">in</span> arrayAnimal)&#123;</span><br><span class="line">    MessageBox.Show(item.Shout()); <span class="comment">//Cat为&quot;mew&quot;, Dog为&quot;woof&quot;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips1:</strong> C#的多态性分为静态多态性和动态多态性.
静态多态性即为前文提到的overload重载, 在编译时确定;
动态多态性为override覆写, 在运行时确定,
通过抽象类(见下文)和虚方法实现.</p>
<p><strong>Tips2:</strong> 笔者在翻阅相关资料时,
在C++语言中发现了更为复杂的机制, overwrite重写和override覆写存在区别,
详见<a
href="https://www.cnblogs.com/kuliuheng/p/4107012.html"><strong>博客园|C++中的Overload、Override和Overwrite</strong></a></p>
<p><strong>Addtional:</strong> 原书对上述实现Animal Shout的代码进行重构,
具体方法为将Shout()声明为父类公共方法(去掉virtual),
声明新的虚方法getSound(), 在Shout()中调用, 在子类中覆写(override),
从而避免了代码重复, 此处笔者不再浪费篇幅详细赘述.</p>
</blockquote>
<ul>
<li><p><strong>抽象类&amp;抽象方法:</strong>
C#允许将类和方法用关键字<strong>abstract</strong>声明, 即抽象类,
抽象方法.</p>
<blockquote>
<strong>Addtional:</strong>
<ul>
<li>抽象类不能被实例化</li>
<li>抽象方法必须被子类覆写(override)</li>
<li>含有抽象方法的类必须声明为抽象类, 不论是否具有一般方法</li>
<li>使用时考虑让抽象类拥有尽可能多的共同代码, 拥有尽可能少的数据</li>
</ul>
<p><strong>Tips:</strong> 抽象类通常代表一种抽象概念,
提供了一个继承的出发点, 当设计一个新的抽象类时, 一定是用来继承的.
因此在继承结构中, 叶节点应当是具体类, 非叶节点应当是抽象类.</p>
</blockquote></li>
<li><p><strong>接口(Interface):</strong>
接口是把隐式公共方法和属性组合起来, 以封装特定功能的一个集合.
类实现了接口就可以支持接口所指定的所有属性和成员.
接口不允许提供任何成员的执行方法(因此接口不能实例化, 没有构造方法,
字段和修饰符, 不能声明静态或虚拟等).</p>
<blockquote>
<strong>Addtionnal:</strong>
<ul>
<li>实现接口的类必须实现接口中所有方法和属性.</li>
<li>一个类可以支持多个接口, 不同类也可以支持相同接口.</li>
</ul>
<p><strong>Tips:</strong> <a
href="https://www.runoob.com/csharp/csharp-interface.html">菜鸟教程|C#
Interface</a>将接口表述为:</p>
<p>接口定义了所有类继承接口时应遵循的语法合同.
接口定义了语法合同"是什么"部分, 派生类定义了语法合同"怎么做"部分.
接口定义了属性, 方法和事件, 这些都是接口的成员. 接口只包含了成员的声明.
成员的定义是派生类的责任. 接口提供了派生类应遵循的标准结构.</p>
<p><strong>书写规范:</strong> 接口的命名需要在前面加一个大写"I".</p>
</blockquote></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 笔者在此化简了书目中提供的例子, 能理解即可.</span></span><br><span class="line"><span class="comment">// 叮当猫继承自上文出现的Cat类, 内部需要实现变东西的接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MachineCat</span> : <span class="title">Cat</span>, <span class="title">IChange</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MachineCat</span>() : <span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ChangeThing</span>(<span class="params"><span class="built_in">string</span> thing</span>)</span>&#123; <span class="comment">//实现接口, 不需要使用override修饰</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.Shout() + <span class="string">&quot;我有万能口袋, 可以变出: &quot;</span> + thing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Additional:</strong> 笔者在此补充一点C#的语法特性,
接口也可以继承接口, 假设IB继承IA, 在IB中不需要声明IA中的声明,
但实现IB的类需要实现IA和IB中的所有声明.</p>
<p><strong>Compare: Class v.s. Interface</strong></p>
<ul>
<li><strong>语法上:</strong> 抽象类可以给出一些成员的实现,
接口不能包含成员的实现, 抽象类的抽象成员可被子类部分实现,
但接口的成员需要类全部实现, 一个类只能继承<strong>一个</strong>抽象类,
但可以实现<strong>多个</strong>接口.</li>
<li><strong>含义上:</strong> 类是对象的抽象, 抽象类是对类的抽象,
接口是对<strong>行为</strong>的抽象.</li>
<li><strong>使用上:</strong> 如果行为跨越不同类的对象, 可使用接口;
对于一些相似的类对象, 用继承抽象类. 需要注意的是,
实现接口和继承抽象类并不冲突.</li>
<li><strong>设计角度上:</strong> 抽象类是从子类中发现了公共的东西,
泛化出父类, 然后子类继承父类, 而接口根本不知道子类的存在,
方法如何实现不明确, 预先定义.</li>
</ul>
</blockquote>
<ul>
<li><p><strong>泛型(Generic):</strong> 泛型是具有占位符(类型参数)的类,
结构, 接口和方法, 这些占位符是类, 结构,
接口和方法所储存域或使用的一个或多个类型的占位符.
泛型集合类可以将类型参数用作它所存储的对象的类型的占位符:
类型参数作为其字段的类型和其方法的参数类型出现.</p>
<blockquote>
<p><strong>Additional:</strong> 通常情况下, 都建议使用泛型集合,
因为这样可以获得类型安全的直接优点而不需要从基集合类型派生并实现类型特定成员.
此外, 如果集合元素为值类型,
泛型集合类型的性能通常优于对应的非泛型集合类型,
因为使用泛型时不必对元素进行装箱.</p>
<p><strong>Tips:</strong> <a
href="https://www.runoob.com/csharp/csharp-generic.html">菜鸟教程|C#
Generic</a>将泛型表述为:</p>
<p>泛型(Generic)允许您延迟编写类或方法中的编程元素的数据类型的规范,
直到实际在程序中使用它的时候. 换句话说,
泛型允许您编写一个可以与任何数据类型一起工作的类或方法.</p>
<p>泛型的定义较为晦涩, 建议结合代码理解.
笔者在此强烈建议阅读更多的资料来学习泛型.</p>
</blockquote></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic; <span class="comment">//增加泛型集合命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Forml</span> : <span class="title">Form</span>&#123;</span><br><span class="line">    IList&lt;Animal&gt; arrayAnimal; <span class="comment">// 声明泛型集合变量, 表示只接受Animal类型</span></span><br><span class="line">    <span class="comment">//List&lt;Animal&gt; arrayAnimal; 两种写法是等价的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Event</span>()</span>&#123;</span><br><span class="line">        arrayAnimal = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Cat());</span><br><span class="line">        arrayAnimal.Add(<span class="keyword">new</span> Dog());</span><br><span class="line">        arrayAnimal.Add(<span class="number">123</span>); <span class="comment">// Error! Invalid Type </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>委托:</strong> 委托是对函数的封装,
可以当作给方法的特征指定一个名称.
委托对象用关键字<strong>delegate</strong>声明.</p></li>
<li><p><strong>事件:</strong> 事件时委托的一种特殊形式,
当发生有意义的事情时, 事件对象处理通知过程.
事件对象用关键字<strong>event</strong>声明.</p></li>
</ul>
<blockquote>
<p><strong>Additional:</strong> 委托是一种引用方法的类型,
一旦为委托分配了方法, 委托将与该方法具有完全相同的行为.
事件则是在发生其他类或对象关注的事情时, 类或对象可通过事件通知它们.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情境: 猫Tom叫的时候两只老鼠Jerry和Jack要跑.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>()</span>; <span class="comment">// 声明委托</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout; <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span> (CatShout != <span class="literal">null</span>)&#123; <span class="comment">// 如果声明了事件CatShout</span></span><br><span class="line">            CatShout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫来了, &#123;0&#125;快跑&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    Mouse mouse1 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    Mouse mouse2 = <span class="keyword">new</span> Mouse(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse1.Run);</span><br><span class="line">    cat.CatShout += <span class="keyword">new</span> Cat.CatShoutEventHandler(mouse2.Run); </span><br><span class="line">    <span class="comment">// &quot;+=&quot; 表示 &quot;add_CatShout&quot; 的意思; 与之相反 &quot;-=&quot; 表示 &quot;remove_CatShout()&quot;</span></span><br><span class="line"></span><br><span class="line">    cat.Shout();</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫来了, Jerry快跑!</span><br><span class="line">老猫来了, Jack快跑!</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>EventArgs:</strong> EventArgs是包含事件数据的类的基类.</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CatShoutEventArgs</span> : <span class="title">EventArgs</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CatShoutEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CatShoutEventHandler CatShout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;喵, 我是&#123;0&#125;.&quot;</span>, name);</span><br><span class="line">        <span class="keyword">if</span>(CatShout != <span class="literal">null</span>)&#123;</span><br><span class="line">            CatShoutEventArgs e = <span class="keyword">new</span> CatShoutEventArgs();</span><br><span class="line">            e.Name = <span class="keyword">this</span>.name;</span><br><span class="line">            CatShout(<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Mouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mouse</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="built_in">object</span> sender, CatShoutEventArgs args</span>)</span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;老猫&#123;0&#125;来了, &#123;1&#125;快跑!&quot;</span>, args.Name, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main执行结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">喵, 我是Tom.</span><br><span class="line">老猫Tom来了, Jerry快跑!</span><br><span class="line">老猫Tom来了, Jack快跑!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记-设计模式</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda+Cuda+Pytorch+Pycharm环境配置</title>
    <url>/AI-conda-env/</url>
    <content><![CDATA[<p><strong>笔者个人conda环境搭建记录.</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#安装pycharm--anaconda">安装Pycharm &amp; Anaconda</a>
<ul>
<li><a href="#pycharm">Pycharm</a></li>
<li><a href="#anaconda3">Anaconda3</a>
<ul>
<li><a href="#选项配置">选项配置</a></li>
<li><a href="#环境变量">环境变量</a></li>
<li><a href="#安装位置">安装位置</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#anaconda-安装检测">Anaconda 安装检测</a></li>
</ul></li>
</ul></li>
<li><a href="#安装cuda">安装Cuda</a></li>
<li><a href="#安装pytorch">安装Pytorch</a>
<ul>
<li><a href="#anaconda创建conda环境">Anaconda创建conda环境</a></li>
<li><a href="#确定pytorch版本">确定Pytorch版本</a></li>
<li><a href="#pytorch安装检测">Pytorch安装检测</a></li>
</ul></li>
<li><a href="#pycharm激活conda环境">Pycharm激活conda环境</a>
<ul>
<li><a href="#导入环境检测">导入环境检测</a></li>
</ul></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<h2 id="前言">前言</h2>
<p>本日志记录一次笔者配置conda环境的过程. 参考资料来源网络, 见<a
href="#参考资料"><strong>参考资料</strong></a></p>
<p>本次搭建环境基于<a
href="https://www.anaconda.com/"><strong>Anaconda</strong></a>+<a
href="https://developer.nvidia.com/"><strong>Cuda</strong></a>搭建<a
href="https://pytorch.org/"><strong>Pytorch</strong></a>环境并导入<a
href="https://www.jetbrains.com.cn/pycharm/"><strong>Pycharm</strong></a>中使用.</p>
<p>笔者的环境为:</p>
<p><strong>Win11家庭版23H2</strong> + <strong>CPU:AMD Ryzen 7
5800H</strong> + <strong>GPU: 3060laptop</strong></p>
<p><strong>Anaconda-2024.10.1</strong> + <strong>Cuda-12.6</strong> +
<strong>Pytorch-win_x86_64-cuda12.4</strong> + <strong>Pycharm
Community-2022.2.2</strong></p>
<h2 id="安装pycharm-anaconda">安装Pycharm &amp; Anaconda</h2>
<h3 id="pycharm">Pycharm</h3>
<p>笔者的Pycharm已经安装好了, Community版本是可以免费使用的,
安装教程可以<strong>STFW</strong>.</p>
<p>需要注意的是, Pycharm本身不包含python, python需要自行下载.</p>
<h3 id="anaconda3">Anaconda3</h3>
<h4 id="选项配置">选项配置</h4>
<img src="/AI-conda-env/pic1-1.png" class="" title="pic1-1">
<p><code>Just Me</code>与<code>All Users</code>选择<code>All Users</code>.</p>
<img src="/AI-conda-env/pic1-2.png" class="" title="pic1-2">
<p>全部勾选.</p>
<p>安装结束后不需要launch, 还要配置环境变量.</p>
<h4 id="环境变量">环境变量</h4>
<p>在高级系统设置中添加系统环境变量, 路径以安装路径为准.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\anaconda3</span><br><span class="line">D:\anaconda3\Scripts</span><br><span class="line">D:\anaconda3\Library\bin</span><br><span class="line">D:\anaconda3\Library\mingw-w64\bin</span><br></pre></td></tr></table></figure>
<h4 id="安装位置">安装位置</h4>
<p>如果已有分盘, 推荐安装到别的分区.</p>
<p>Anaconda的环境和包管理也可以迁移, 笔者本次省略了这个步骤.</p>
<h4 id="debug">Debug</h4>
<p>笔者在安装完成后遇到了打开<code>Anaconda Navigator</code>时卡死在<code>Loading Applications</code>页面上,
通过为程序添加默认管理员权限解决.</p>
<h4 id="anaconda-安装检测">Anaconda 安装检测</h4>
<p>打开<code>Anaconda Prompt</code>, 页面如下:</p>
<img src="/AI-conda-env/pic1-3.png" class="" title="pic1-3">
<p>执行指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda --version</span></span><br></pre></td></tr></table></figure>
<p>终端输出conda版本号即成功安装了conda</p>
<img src="/AI-conda-env/pic1-4.png" class="" title="pic1-4">
<p>可以通过如下指令查看conda的配置信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda info</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips:</strong> 笔者本次略去了Conda的配置, 如包和环境位置,
镜像源的配置. 有需要可以自行配置.</p>
</blockquote>
<h2 id="安装cuda">安装Cuda</h2>
<p>调出cmd后在终端中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvidia-smi</span></span><br></pre></td></tr></table></figure>
<p>得到</p>
<img src="/AI-conda-env/pic1-5.png" class="" title="pic1-5">
<p>其中<code>CUDA Version</code>代表最高支持的<code>CUDA</code>版本,
到官网对应版本下载即可.</p>
<p>安装完成后在cmd中执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvcc -V</span></span><br></pre></td></tr></table></figure>
<p>正常输出Cuda版本即安装完成.</p>
<img src="/AI-conda-env/pic1-6.png" class="" title="pic1-6">
<h2 id="安装pytorch">安装Pytorch</h2>
<p>Pytorch依赖于conda环境, 因此在安装Pytorch前需要配置conda虚拟环境.</p>
<h3 id="anaconda创建conda环境">Anaconda创建conda环境</h3>
<p>打开<code>Anaconda Prompt</code>,
此时的环境为默认的<code>base</code>(见<a
href="#anaconda-安装检测"><strong>上文</strong></a>)</p>
<p>执行指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda create –n pytorch python=3.10</span></span><br></pre></td></tr></table></figure>
<p>其中<code>pytorch</code>为环境名称,
<code>python=3.10</code>为指定python解释器版本.</p>
<p>需要注意的是,
目前(2024.11)的Pytorch需要<strong>至少</strong>python版本为3.9</p>
<p>如果需要特定版本,
在安装Pytorch时需要查看<code>Preview Version</code>.</p>
<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda activate pytorch</span></span><br></pre></td></tr></table></figure>
<p>终端环境变更为<code>pytorch</code></p>
<p>想要回到<code>base</code>环境, 只需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda deactivate</span></span><br></pre></td></tr></table></figure>
<p>Pytorch的安装位置便是在名为<code>pytorch</code>的环境中.</p>
<h3 id="确定pytorch版本">确定Pytorch版本</h3>
<p>进入Pytorch官网的Install页面</p>
<img src="/AI-conda-env/pic1-7.png" class="" title="pic1-7">
<p>根据自己的Cuda版本选择安装.</p>
<p>如果选择conda安装,
只需要在<code>Anaconda Prompt</code>中激活创建的<code>pytorch</code>环境,
执行官网上给出的安装命令.</p>
<p>耐心等待安装完成即可.</p>
<h3 id="pytorch安装检测">Pytorch安装检测</h3>
<p>安装结束后, 在激活<code>pytorch</code>环境的终端中执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python</span></span><br></pre></td></tr></table></figure>
<img src="/AI-conda-env/pic1-8.png" class="" title="pic1-8">
<p>输入以下python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure>
<img src="/AI-conda-env/pic1-9.png" class="" title="pic1-9">
<p>得到类似输出而没有报错即成功在conda环境中安装pytorch.</p>
<h2 id="pycharm激活conda环境">Pycharm激活conda环境</h2>
<p>以创建的<code>pytorch</code>环境为例.</p>
<p>使用Pycharm打开项目, 进入<code>File-&gt;Setting</code>页面</p>
<img src="/AI-conda-env/pic1-10.png" class="" title="pic1-10">
<p>选择<code>项目-&gt;Python解释器</code></p>
<p>点击<code>添加解释器-&gt;添加本地解释器-&gt;conda环境</code></p>
<img src="/AI-conda-env/pic1-11.png" class="" title="pic1-11">
<p>Conda可执行文件输入<code>D:\anaconda3\Scripts\conda.exe</code>(依据Anaconda安装位置)</p>
<p>选择解释器(依据自己的conda环境创建位置)</p>
<img src="/AI-conda-env/pic1-12.png" class="" title="pic1-12">
<p>点击确认等待配置完成.</p>
<h3 id="导入环境检测">导入环境检测</h3>
<p>与<a
href="#pytorch安装检测"><strong>Pytorch安装检测</strong></a>类似,
只需要在python文件中键入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure>
<p>执行代码得到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2.5.1</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>然后就可以开始愉快(迫真)的炼丹之旅啦!</p>
<h2 id="参考资料">参考资料</h2>
<blockquote>
<p><strong>Tips:</strong> 博客并不能解决所有问题,
对于博客中的内容要和面对ChatGPT生成的内容一样小心求证.
必要时更推荐官方文档(此处略去).</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_44000789/article/details/142214660"
class="uri">https://blog.csdn.net/qq_44000789/article/details/142214660</a></p>
<p><a
href="https://blog.csdn.net/weixin_41401924/article/details/120332417"
class="uri">https://blog.csdn.net/weixin_41401924/article/details/120332417</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/389992455"
class="uri">https://zhuanlan.zhihu.com/p/389992455</a></p>
<p><a
href="https://blog.csdn.net/weixin_62075168/article/details/131226082"
class="uri">https://blog.csdn.net/weixin_62075168/article/details/131226082</a></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-大话设计模式 Ch1-Ch5</title>
    <url>/BookNote-DesignPatterns-by-JieCheng-2/</url>
    <content><![CDATA[<p><strong>好的代码可维护, 可复用, 可扩展, 灵活性强.</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#additional--uml类图">Additional : UML类图</a>
<ul>
<li><a href="#什么是uml">什么是UML</a></li>
<li><a href="#uml类图的示例">UML类图的示例</a></li>
</ul></li>
<li><a href="#chapter-1-简单工厂模式simple-factory">Chapter 1:
简单工厂模式(Simple Factory)</a></li>
<li><a href="#chapter-2-策略模式strategy">Chapter 2:
策略模式(Strategy)</a>
<ul>
<li><a href="#收银的策略模式实现">收银的策略模式实现</a></li>
<li><a href="#策略模式解析">策略模式解析</a></li>
</ul></li>
<li><a href="#chapter-3-单一职责原则srp">Chapter 3:
单一职责原则(SRP)</a></li>
<li><a href="#chapter-4-开放-封闭原则ocp">Chapter 4:
开放-封闭原则(OCP)</a></li>
<li><a href="#chapter-5-依赖倒转原则">Chapter 5: 依赖倒转原则</a>
<ul>
<li><a href="#里氏代换原则lsp">里氏代换原则(LSP)</a></li>
</ul></li>
</ul>
<h2 id="additional-uml类图">Additional : UML类图</h2>
<p><strong>在线UML工具:</strong> <a
href="https://www.plantuml.com/plantuml/uml"
class="uri">https://www.plantuml.com/plantuml/uml</a></p>
<h3 id="什么是uml">什么是UML</h3>
<p><strong>统一建模语言UML(Unified Modeling Language)</strong>
是一种脚本语言, 是一种开放的方法, 用于说明, 可视化,
构建和编写一个正在开发的, 面向对象的, 软件密集系统的产品的开放方法.</p>
<p>简单来说, 对于应用的人, 可以通过简单的语言来生成描述的图像(包括类图,
时序图等).</p>
<h3 id="uml类图的示例">UML类图的示例</h3>
<img src="/BookNote-DesignPatterns-by-JieCheng-2/pic2-2.png" class="" title="pic2-2">
<p>关于UML类图的介绍在Internet中有充足的资料和手册,
书中也有简单的规约介绍,
笔者在此不详细介绍UML图的语法和规约.(或者待专门出一期整理UML用法的栏目)</p>
<h2 id="chapter-1-简单工厂模式simple-factory">Chapter 1:
简单工厂模式(Simple Factory)</h2>
<p>先来看看书中给的例子:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OperationFactory</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperate</span>(<span class="params"><span class="built_in">string</span> operate</span>)</span>&#123;</span><br><span class="line">        Operation oper = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operate)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationAdd();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationSub();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ...</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用端</span></span><br><span class="line">Operation oper;</span><br><span class="line">oper = OperationFactory.createOperate(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">oper.NumberA = <span class="number">1</span>;</span><br><span class="line">oper.NumberB = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">double</span> result = oper.GetResult();</span><br></pre></td></tr></table></figure>
<p>UML图如下:</p>
<img src="/BookNote-DesignPatterns-by-JieCheng-2/pic2-1.png" class="" title="pic2-1">
<p>简单来说,
就是通过一个简单工厂类<code>XXXFactory</code>生产"产品"(实例化类),即<strong>有一个专门的类负责创建实例的过程</strong>.
这样修改后端的功能时(比如说添加新的运算类),
前端的逻辑不需要重构(以上述例子中只需要修改<code>createOperate("+")-&gt;createOperate("-")</code>);
同时后端的具体实现细节没有暴露给前端, 降低了耦合度.</p>
<h2 id="chapter-2-策略模式strategy">Chapter 2: 策略模式(Strategy)</h2>
<ul>
<li>面向对象的编程, 并不是类越多越好, 类的划分是为了封装,
但分类的基础是抽象, 具有相同属性和功能的对象的抽象集合才是类.</li>
</ul>
<p><strong>策略模式(Strategy)</strong> 定义了算法家族, 分别封装起来,
让它们之间相互替换, 此模式让算法的变化不会影响到使用算法的客户.</p>
<img src="/BookNote-DesignPatterns-by-JieCheng-2/pic2-3.png" class="" title="pic2-3">
<h3 id="收银的策略模式实现">收银的策略模式实现</h3>
<img src="/BookNote-DesignPatterns-by-JieCheng-2/pic2-4.png" class="" title="pic2-4">
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//back end</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CashContext</span>&#123;</span><br><span class="line">    CashSuper cs = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashContext</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//该部分可以采用访问者模式(Visitor)优化</span></span><br><span class="line">        <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;正常收费&quot;</span>:</span><br><span class="line">                Cashnormal cs0 = <span class="keyword">new</span> CashNormal();</span><br><span class="line">                cs = cs0;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;300减100&quot;</span>:</span><br><span class="line">                CashReturn cr1 = <span class="keyword">new</span> CashReturn(<span class="string">&quot;300&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">                cs = cr1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;打8折&quot;</span>:</span><br><span class="line">                CashRebate cr2 = <span class="keyword">new</span> CashRebate(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line">                cs = cr2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetResult</span>(<span class="params"><span class="built_in">double</span> money</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//front end</span></span><br><span class="line"><span class="built_in">double</span> total = <span class="number">0.0</span><span class="function">d</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnOk_click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//客户端UI操作时传入相应字符串</span></span><br><span class="line">    CashContext csuper = <span class="keyword">new</span> CashContext(cbxType.SelectedItem.ToString());</span><br><span class="line">    <span class="built_in">double</span> totalprices = <span class="number">0</span>d;</span><br><span class="line">    totalPrices = csuper.Getresult(Convert.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text));</span><br><span class="line">    total += totalPrices;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="策略模式解析">策略模式解析</h3>
<ul>
<li><p>策略模式是一种定义一系列算法的方法, 从概念上看,
所有这些算法完成的都是相同的工作, 只是实现不同,
它可以以相同的方式调用所有的算法,
减少了各种算法类与使用算法类之间的耦合.</p></li>
<li><p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为.
继承有助于析出这些算法的公共功能.</p>
<blockquote>
<p>对于上述代码案例, 即是<code>GetResult()</code>.</p>
</blockquote></li>
<li><p>策略模式的优点是简化了单元测试, 因为每个算法都有自己的类,
可以通过自己的接口单独测试.</p></li>
<li><p>策略模式用于封装算法, 在实践中, 可以用它来封装几乎任何类型的规则,
只要在分析过程中听到需要在不同时间应用不同的业务规则,
就可以考虑使用策略模式处理这种变化的可能性.</p></li>
</ul>
<h2 id="chapter-3-单一职责原则srp">Chapter 3: 单一职责原则(SRP)</h2>
<p><strong>就一个类而言, 应该仅有一个引起它变化的原因.</strong></p>
<ul>
<li>如果一个类承担的职责过多, 就等于把这些职责耦合在一起,
一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力.
这种耦合会导致脆弱的设计, 当变化发生时, 设计会遭受到意想不到的破坏.</li>
<li>软件设计真正要做的许多内容, 就是发现职责并把那些职责相互分离.</li>
<li>如果你能想到多于一个的动机去改变一个类,
那么这个类就具有多于一个的职责.</li>
</ul>
<h2 id="chapter-4-开放-封闭原则ocp">Chapter 4: 开放-封闭原则(OCP)</h2>
<ul>
<li><p><strong>开放-封闭原则(The Open-Closed Principle):</strong>
软件实体(类, 模块, 函数等)应该可以扩展, 但不能修改.</p>
<ul>
<li>对于扩展是开放的(Open for extension)</li>
<li>对于修改是封闭的(Closed for modification)</li>
</ul></li>
<li><p><strong>绝对的对修改关闭是不可能的.</strong></p>
<blockquote>
<p>无论模块是多么的"封闭", 都会存在一些无法对之封闭的变化.
既然不可能完全封闭,
设计人员必须对于他设计的模块应该对哪种变化封闭做出选择.
他必须先猜测出最有可能发生的变化种类, 然后构造抽象来隔离那些变化.</p>
</blockquote></li>
<li><p><strong>等到变化发生时立即采取行动</strong></p>
<ul>
<li>最初编写代码时, 假设变化不会发生. 当变化发生时,
创建抽象来隔离以后发生的同类变化.</li>
<li>面对需求, 对程序的改动是通过增加新代码进行的,
而不是更改现有的代码.</li>
</ul></li>
</ul>
<p><strong>开放-封闭原则是面向对象设计的核心所在.
遵循这个原则可以带来面向对象奇数所声称的巨大好处, 也就是可维护, 可扩展,
可复用, 灵活性好. 开发人员应当仅对程序中频繁出现的变化的那部分做出抽象.
然而, 对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意.
拒绝不成熟的抽象和抽象本身一样重要.</strong></p>
<h2 id="chapter-5-依赖倒转原则">Chapter 5: 依赖倒转原则</h2>
<ul>
<li><strong>依赖倒转原则:</strong> 抽象不应该依赖细节,
细节应该依赖于抽象
<ul>
<li>即: <strong>针对接口编程, 不要对实现编程.</strong></li>
<li>高层模块不应该依赖低层模块, 两个都应该依赖抽象.</li>
</ul></li>
</ul>
<p><strong>依赖倒转其实可以说是面向对象设计的标志,
用哪种语言来编写程序不重要,
如果编写时考虑的都是如何针对抽象编程而不是针对细节编程,
即程序中所有的依赖关系都是终止于抽象类或者接口, 那就是面向对象的设计,
反之那就是过程化的设计了.</strong></p>
<h3 id="里氏代换原则lsp">里氏代换原则(LSP)</h3>
<p><strong>子类型必须能够替换掉它们的父类型.</strong></p>
<ul>
<li><p>一个软件实体如果使用的是一个父类的话, 那么一定适用于其子类,
而且它察觉不出父类对象和子类对象的区别. 也就是说, 在软件里面,
把父类都替换成它的子类, 程序的行为没有变化.</p></li>
<li><p>只有当子类可以替换掉父类, 软件单位的功能不受影响时,
父类才能真正被复用, 而子类也能够在父类的基础上增加新的行为.</p></li>
<li><p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展.</p>
<blockquote>
<img src="/BookNote-DesignPatterns-by-JieCheng-2/pic2-5.png" class="" title="pic2-5">
</blockquote></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记-设计模式</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-机器学习 Ch0-Ch1</title>
    <url>/BookNote-MachineLearning-by-ZhihuaZhou-1/</url>
    <content><![CDATA[<p><strong>机器学习所研究的主要内容,
是关于在计算机上从数据中产生"模型"(model)的算法, 即"学习算法"(learning
algorithm).</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#书籍基本信息">书籍基本信息</a></li>
<li><a href="#chapter-0-主要符号表">Chapter 0: 主要符号表</a></li>
<li><a href="#chapter-1-绪论">Chapter 1: 绪论</a>
<ul>
<li><a href="#11-基本术语">1.1 基本术语</a></li>
<li><a href="#13-假设空间">1.3 假设空间</a></li>
<li><a href="#14-归纳偏好">1.4 归纳偏好</a></li>
</ul></li>
</ul>
<hr />
<h2 id="书籍基本信息">书籍基本信息</h2>
<p>《机器学习》周志华 2016.</p>
<p>大名鼎鼎的西瓜书, 笔者在此略去介绍.</p>
<h2 id="chapter-0-主要符号表">Chapter 0: 主要符号表</h2>
<p><span class="math display">\[\begin{aligned}
&amp;\mathit{x}&amp; &amp;标量\\
&amp;\boldsymbol{x}&amp; &amp;向量 \\
&amp;\mathrm{x}&amp; &amp;变量集 \\
&amp;\mathbf{A}&amp; &amp;矩阵 \\
&amp;\mathbf{I}&amp; &amp;单位阵 \\
&amp;\mathcal{X}&amp; &amp;样本空间或状态空间\\
&amp;\mathcal{D}&amp; &amp;概率分布\\
&amp;\mathit{D}&amp; &amp;数据样本(数据集)\\
&amp;\mathcal{H}&amp; &amp;假设空间\\
&amp;\mathit{H}&amp; &amp;假设集\\
&amp;\mathfrak{L}&amp; &amp;学习算法\\
&amp;\left ( \cdot ,\cdot ,\cdot  \right )&amp; &amp;行向量\\
&amp;\left ( \cdot ;\cdot ;\cdot \right )&amp; &amp;列向量\\
&amp;\left ( \cdot  \right )^{T}&amp; &amp;向量或矩阵转置\\
&amp;\left \{  \cdot \cdot \cdot \right \}&amp; &amp;集合\\
&amp;\left | \left \{ \cdot \cdot \cdot \right \} \right |&amp;
&amp;集合中元素个数\\
&amp;\left \| \cdot  \right \|_{p}&amp; &amp;L_p范数, p缺省时为L_2范数\\
&amp;\mathit{P}\left ( \cdot  \right ),\mathit{P}\left ( \cdot
|\cdot  \right )&amp; &amp;概率质量函数,条件概率质量函数\\
&amp;\mathit{p}\left ( \cdot  \right ),\mathit{p}\left ( \cdot  | \cdot
\right )&amp; &amp;概率密度函数, 条件概率密度函数\\
&amp;\mathbb{E}_{\cdot \sim \mathcal{D}}\left [ f\! \left ( \cdot \right
) \right ]&amp; &amp;函数 f\! \left ( \cdot \right ) 对 \cdot 在分布
\mathcal{D} 下的数学期望:意义明确是将省略 \mathcal{D} 和(或)\cdot \\
&amp;sup\left ( \cdot \right )&amp; &amp;上确界\\
&amp;\mathbb{I} \left ( \cdot  \right )&amp; &amp;指示函数，在
\cdot  为真和假分别取值为1 , 0 \\
&amp;sign\left ( \cdot  \right )&amp; &amp;符号函数，在 \cdot &lt; 0, =
0 , &gt;  0 时分别取值为 -1,0,1
\end{aligned}\]</span></p>
<h2 id="chapter-1-绪论">Chapter 1: 绪论</h2>
<h3 id="基本术语">1.1 基本术语</h3>
<blockquote>
<p>假定我们收集了一批关于西瓜的数据, 例如(色泽 = 浅白; 根蒂 = 蜷缩; 敲声
= 浊响), (色泽 = 乌黑; 根蒂 = 稍蜷; 敲声 = 沉闷), (色泽 = 浅白; 根蒂 =
硬挺; 敲声 = 清脆), ......, 每对括号内是一条记录,
下文关于术语的表述会基于上述假定进行解释.</p>
</blockquote>
<ul>
<li><p><strong>数据集/样本(Data Set):</strong>
这组记录的集合称为一个数据集.</p>
<blockquote>
<p><strong>Tips:</strong> 数据集亦称样本,
因为数据集可看作对样本空间的一个采样.</p>
<p><strong>Addtional:</strong> "样本"的具体指代示例还是数据集,
要看具体的上下文.</p>
</blockquote></li>
<li><p><strong>示例(Instance)/样本(Sample):</strong>
每条记录称为示例/样本, 是关于一个事件或对象的描述(以上例,
该对象为西瓜).</p></li>
<li><p><strong>属性(Attribute)/特征(Feature):</strong> "色泽", "根蒂",
"敲声"称为属性.</p></li>
<li><p><strong>属性值(Attribute Value):</strong>
属性的取值称为属性值(以上例, "青绿"和"乌黑"是色泽的属性值).</p></li>
<li><p><strong>属性空间(Attribute Space)/样本空间(Sample
Space)/输入空间:</strong> 属性张成的空间.</p>
<blockquote>
<p><strong>Tips:</strong> 此处涉及的是线性代数知识,
即将样本(Instance)依据属性转化为向量, 其中色泽, 根蒂和敲声为坐标轴,
张成了一个用于描述西瓜特征的三维空间,
该空间每个点即是线性代数意义上的一个向量, 也就是<strong>特征向量(Feature
Vector)</strong>. 我们可以认为,
示例(Instance)的另一种等价表述是特征向量.</p>
</blockquote></li>
<li><p><strong>数据集的表示:</strong> 令 <span
class="math inline">\(\mathit{D} = \{x_1, x_2, ..., x_m\}\)</span>
表示包含<span class="math inline">\(m\)</span>个示例的数据集, 每个示例由
<span class="math inline">\(d\)</span> 个属性描述, 则每个示例(Instance)
<span class="math inline">\(x_i= (x_{i1}; x_{i2}; ...; x_{id})\)</span>
是 <span class="math inline">\(d\)</span> 维样本空间 <span
class="math inline">\(\mathcal{X}\)</span> 中的一个向量, <span
class="math inline">\(x_i \in \mathcal{X}\)</span>. <span
class="math inline">\(d\)</span> 称为样本 <span
class="math inline">\(x_i\)</span>
的<strong>维数(Dimensionality)</strong>.</p></li>
<li><p><strong>学习(Learning)/训练(Training):</strong>
从数据中学得模型的过程称为学习/训练,
该过程通过执行某个学习算法完成.</p></li>
<li><p><strong>训练数据(Training Data):</strong>
训练过程中所使用的数据.</p></li>
<li><p><strong>训练样本(Training Sample)/训练示例(Training
Instance):</strong> 训练数据中的每个样本/示例.</p></li>
<li><p><strong>训练集(Training Set):</strong>
训练样本组成的集合称为训练集.</p>
<blockquote>
<p><strong>Tips:</strong> 训练集相当于训练数据的子集,
训练数据除去<strong>训练集</strong>外还存在<strong>验证集</strong>.(参考自:<a
href="https://zhuanlan.zhihu.com/p/115344944"><strong>知乎|训练集(training
dataset), 测试集(test dataset)与验证集(validation
dataset)</strong></a>)</p>
</blockquote></li>
<li><p><strong>假设(Hypothesis)&amp;真相/真实(Ground-Truth):</strong>
学得模型对应了关于数据的某种潜在规律,
因此亦称假设.这种潜在规律称为"真相"/"真实".
学习的过程就是为了找出或逼近真相.</p>
<blockquote>
<p><strong>Tips:</strong> <a
href="https://en.wikipedia.org/wiki/Ground_truth"><strong>WIKIPEDIA|Ground-Truth</strong></a>又将其表述为<strong>基准真相</strong>.</p>
<p>"Ground truth is information that is known to be real or true,
provided by direct observation and measurement (i.e. empirical evidence)
as opposed to information provided by inference."</p>
</blockquote></li>
</ul>
<p><strong>Tips:</strong>
本书有时又将<strong>模型</strong>称为<strong>学习器(Learner)</strong>,
模型可看作是学习算法在给定数据和参数空间上的实例化.</p>
<ul>
<li><p><strong>标记(Label):</strong> 关于示例(Instance)结果的信息,
称为标记(如"好瓜"). 一般的, 用 <span class="math inline">\((x_i,
y_i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个样例, 其中
<span class="math inline">\(y_i \in \mathcal{Y}\)</span> 是示例 <span
class="math inline">\(x_i\)</span> 的标记, <span
class="math inline">\(\mathcal{Y}\)</span> 是所有标记的集合,
又称<strong>标记空间(Label Space)/输出空间</strong>.</p></li>
<li><p><strong>分类(Classification):</strong>
若<strong>预测(Prediction)</strong>的是离散值(如"好瓜", "坏瓜"),
则称此类学习任务是分类.</p></li>
<li><p><strong>回归(Regression):</strong> 若预测的是连续值(如成熟度0.95,
0.7), 则称此类学习任务是回归.</p></li>
<li><p><strong>二分类(Binary Classification):</strong>
只涉及两个类别的分类任务, 通常称其中一类为<strong>正类(Positive
Class)</strong>, 另一类为<strong>反类(Negative Class)</strong>.</p></li>
<li><p><strong>多分类(Multi-class Classification):</strong> 与之相对的,
涉及多种类别的分类任务称为多分类任务.</p></li>
<li><p><strong>预测任务:</strong> 预测任务希望通过对训练集<span
class="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m,
y_m)\}\)</span> 进行学习, 建立一个从输入空间 <span
class="math inline">\(\mathcal{X}\)</span> 到输出空间 <span
class="math inline">\(\mathcal{Y}\)</span> 的映射 <span
class="math inline">\(f : \mathcal{X} \rightarrow \mathcal{Y}\)</span>.
对二分类, 通常取 <span class="math inline">\(\mathcal{Y} = \{-1,
1\}\)</span> 或 <span class="math inline">\(\{0, 1\}\)</span>;
对于多分类, <span class="math inline">\(|\mathcal{Y}| &gt; 2\)</span>;
对于回归, <span class="math inline">\(\mathcal{Y} =
\mathbb{R}\)</span>.</p></li>
<li><p><strong>测试(Testing):</strong>
使用学习得到的模型进行预测的过程称为测试,
预测的样本称为<strong>测试样本(Testing Sample)/测试示例(Testing
Instance)</strong>.</p></li>
<li><p><strong>聚类(Clustering):</strong> 将训练集中的样本分为若干组,
每组称为一个<strong>簇(Cluster)</strong>.</p>
<blockquote>
<p><strong>Tips:</strong> 形成的簇可能对应一些潜在的概念划分(如本地瓜,
外地瓜), 但这样的概念我们事先不知道,
否则通过标记(Label)就可以形成簇划分.</p>
</blockquote></li>
<li><p><strong>监督学习(Supervised Learning)/有导师学习:</strong>
训练数据拥有标记信息, 分类和回归为代表.</p></li>
<li><p><strong>无监督学习(Unsupervised Learning)/无导师学习</strong>
训练数据无标记信息, 聚类为代表.</p></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> 此处仅作最基本的概念了解,
关于上述两概念的具体释义留及之后的学习.</p>
</blockquote>
<ul>
<li><p><strong>泛化(Generalization):</strong>
学得模型适用于新样本的能力,称为泛化能力.</p>
<blockquote>
<p><strong>Tips1:</strong> 样本空间通常很大, 训练过程无法涵盖所有的示例,
我们希望模型可以对新样本有较好的目标表现, 这就是泛化的意义.</p>
<p><strong>Tips2:</strong> 泛化的数学支撑:</p>
<p>关于这种泛化,
我们通常假设样本空间中的所有样本都服从一个未知的<strong>分布(Distribution)</strong>
<span class="math inline">\(\mathcal{D}\)</span>,
获取的样本是从该分布上采样获得的, 满足<strong>独立同分布(Independent and
Identically Distributed, <em>i.d.d</em>)</strong>.</p>
<p>关于机器学习中为什么使用i.d.d, 可以从<a
href="https://www.zhihu.com/question/41222495"><strong>知乎|为什么机器学习中,
要假设我们的数据是独立同分布的?</strong></a>获取相关信息.</p>
</blockquote></li>
</ul>
<h3 id="假设空间">1.3 假设空间</h3>
<p><strong>归纳(Induction)</strong>与<strong>演绎(Deduction)</strong>是科学推理的两大基本手段.</p>
<blockquote>
<p>前者是从特殊到一般的<strong>泛化(Generalization)</strong>过程;
后者是从一般到特殊的<strong>特化(Specialization)</strong>过程.</p>
</blockquote>
<ul>
<li><p><strong>归纳学习(Inductive Learning):</strong>
广义的归纳学习大体相当于从样例中学习,
狭义的归纳学习要求从学习过程中习得<strong>概念(concept)</strong>,
亦称<strong>概念学习/概念形成</strong>.</p></li>
<li><p><strong>版本空间(Version Space):</strong>
存在一个与训练集一致的"假设集合", 称为版本空间, 例如:</p></li>
</ul>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-1/table1-1.png" class="" title="table1-1">
<p>其假设空间为</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-1.png" class="" title="pic1-1">
<p>其版本空间为</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-2.png" class="" title="pic1-2">
<blockquote>
<p><strong>Tips:</strong> 在该数据集中, 好瓜具有的共同特征是蜷缩和浊响.
因此色泽标识为通配符 <span class="math inline">\(*\)</span>, 同时,
第一行的两种假设同样是与训练集一致的(可以匹配好瓜).</p>
</blockquote>
<h3 id="归纳偏好">1.4 归纳偏好</h3>
<ul>
<li><p><strong>归纳偏好(Inductive bias):</strong>
算法在学习过程中对某种类型假设的偏好称为归纳偏好.</p>
<blockquote>
<p><strong>Tips:</strong>
<strong>任何</strong>一个有效的机器学习算法必有其归纳偏好,
否则它无法产生确定的学习结果.</p>
<p>以图1-2的版本空间为例, 对新瓜(色泽=青绿;根蒂=蜷缩;敲声=沉闷),
若模型告诉我们这种瓜时好时坏则没有意义,
模型必须对给定的样本给予确定的结果.</p>
<p><strong>Additional:</strong>
归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或"价值观".
常遵循<strong>奥卡姆剃刀(Occam's
Razor)</strong>原则(<strong>若有多个假设与观察一致,
则选简单的那个</strong>).</p>
</blockquote></li>
</ul>
<p>接下来我们来比较不同归纳偏好的优劣</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-3.png" class="" title="pic1-3">
<p>从直观上看我们一般会认为, 拟合出平滑的曲线A要优于曲线B, 但很遗憾,
当面临一些极端数据时, 曲线B可能会优于曲线A, 情形如下图所示.</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-4.png" class="" title="pic1-4">
<p>接下来我们用数学语言尝试量化模型的优劣.</p>
<p>假设样本空间 <span class="math inline">\(\mathcal{X}\)</span>
和假设空间 <span class="math inline">\(\mathcal{H}\)</span> 都是离散的,
令 <span class="math inline">\(P(h|X, \mathfrak{L})\)</span>
代表学习算法 <span class="math inline">\(\mathfrak{L}_a\)</span>
基于训练数据 <span class="math inline">\(X\)</span> 产生假设 <span
class="math inline">\(h\)</span> 的概率, 令 <span
class="math inline">\(f\)</span> 为目标函数.则 <span
class="math inline">\(\mathfrak{L}_a\)</span>
在训练集外的所有样本上的误差为</p>
<p><span class="math display">\[\begin{equation} \label{eq1.1}
E_{ote}(\mathfrak{L}_a|X, f) = \sum_h \sum_{x \in \mathcal{X} -X} P(x)
\mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)
\tag{1.1}
\end{equation}\]</span></p>
<blockquote>
<p><strong>Tips:</strong>
以下是笔者个人对该公式的理解,可能存在疏漏或错误.</p>
<p>首先看乘起来的的三个式子, <span
class="math inline">\(\mathbb{I}\)</span> 为指示函数, 代表的含义是假设
<span class="math inline">\(h\)</span> 与目标函数 <span
class="math inline">\(f\)</span> 没有误差时取0, 存在误差时取1. 若取1,
则两个概率乘积表示在给定的<span class="math inline">\(x\)</span>和<span
class="math inline">\(h\)</span>下, 存在误差的概率.</p>
<p>接下来的两个求和就不难理解了, 分别是对<span
class="math inline">\(x\)</span>的所有取值求和以及对<span
class="math inline">\(h\)</span>的所有取值求和, 权重为特定<span
class="math inline">\(x\)</span>和<span
class="math inline">\(h\)</span>的概率.</p>
</blockquote>
<p>为简化问题, 考虑二分类, 真实目标函数<span
class="math inline">\(f\)</span>可以是任何函数<span
class="math inline">\(\mathcal{X} \rightarrow \{0,1\}\)</span>,
函数空间<span class="math inline">\(\{0,1\}^{|\mathcal{X}|}\)</span>.
对所有可能的<span
class="math inline">\(f\)</span>按均匀分布对误差求和,有</p>
<p><span class="math display">\[
\begin{align} \nonumber
\sum_f E_{ote}(\mathfrak{L}_a|x, f) &amp;= \sum_f \sum_h \sum_{x \in
\mathcal{X} -X} P(x) \mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\\
\nonumber
&amp;= \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)
\sum_f \mathbb{I}(h(x) \neq f(x))\\ \nonumber
^*&amp;=  \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)
\frac{1}{2}2^{|\mathcal{X}|}\\ \nonumber
&amp;= \frac{1}{2}2^{|\mathcal{X}|} \sum_{x \in \mathcal{X} -X} P(x)
\cdot 1 \tag{1.2}
\end{align}
\]</span></p>
<blockquote>
<p><strong>Tips:</strong> 标识<span
class="math inline">\(*\)</span>的一步因为若<span
class="math inline">\(f\)</span>均匀分布, 则有一半的<span
class="math inline">\(f\)</span>对<span
class="math inline">\(x\)</span>的预测与<span
class="math inline">\(h(x)\)</span>不一致.</p>
</blockquote>
<p>式(1.2)指出, 误差与学习算法<span
class="math inline">\(\mathfrak{L}\)</span>无关! 对于任意学习算法<span
class="math inline">\(\mathfrak{L}_a\)</span>和<span
class="math inline">\(mathfrak{L}_b\)</span>,有</p>
<p><span class="math display">\[\begin{equation}
\sum_f E_{ote}(\mathfrak{L}_a|X, f) = \sum_f E_{ote}(\mathfrak{L}_b|X,
f) \tag{1.3}
\end{equation}\]</span></p>
<p>这简直糟糕透了, 似乎所有的学习算法期望性能居然都相同.
这就是<strong>没有免费午餐定理(No Free Lunch Theorem, NFL)</strong>.</p>
<blockquote>
<p><strong>Tips:</strong> 原书的证明是多重假设下的简化论述,
对严格数学证明感兴趣的读者可以自行查阅相关资料.</p>
</blockquote>
<p>但是, NFL定理有一个重要前提, 它假定了所有问题出现的机会相等,
所有问题同等重要(例如上述证明中假设了<span
class="math inline">\(f\)</span>均匀分布).
但我们并不要求模型对所有情况都能给出一个好的解决方案,
往往我们希望模型对特定问题表现是好的.</p>
<blockquote>
<p><strong>Tips:</strong> 原书中举了一个简单的例子,
骑自行车从南京鼓楼到南京新街口显然是好方案(距离约两站地铁),
但骑自行车从南京鼓楼到北京新街口, 显然不是好的方案,但我们不care.</p>
</blockquote>
<p>简单来说,
NFL定理指出了<strong>没有一种机器学习算法是适用于所有情况的</strong>,
只有针对具体问题, 才能谈论模型的优劣.</p>
]]></content>
      <categories>
        <category>读书笔记-机器学习</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-机器学习 Ch2</title>
    <url>/BookNote-MachineLearning-by-ZhihuaZhou-2/</url>
    <content><![CDATA[<p><strong>有多个算法和参数生成的模型, 哪个才是好的模型?</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#chapter-2-模型评估与选择">Chapter 2: 模型评估与选择</a>
<ul>
<li><a href="#21-经验误差与过拟合">2.1 经验误差与过拟合</a></li>
<li><a href="#22-评估方法">2.2 评估方法</a>
<ul>
<li><a href="#221-留出法hold-out">2.2.1 留出法(Hold-Out)</a></li>
<li><a href="#222-交叉验证法cross-validation">2.2.2 交叉验证法(Cross
Validation)</a></li>
<li><a href="#223-自助法bootstapping">2.2.3
自助法(Bootstapping)</a></li>
<li><a href="#224-调参与最终模型">2.2.4 调参与最终模型</a></li>
</ul></li>
<li><a href="#23-性能度量">2.3 性能度量</a>
<ul>
<li><a href="#231-错误率与精度">2.3.1 错误率与精度</a></li>
<li><a href="#232-查准率precision-查全率recall-f1">2.3.2
查准率(Precision), 查全率(Recall), F1</a></li>
<li><a href="#233-roc与auc">2.3.3 ROC与AUC</a></li>
<li><a href="#234-代价敏感错误率与代价曲线">2.3.4
代价敏感错误率与代价曲线</a></li>
</ul></li>
<li><a href="#24-比较检验">2.4 比较检验</a>
<ul>
<li><a href="#241-假设检验">2.4.1 假设检验</a></li>
<li><a href="#242-多学习器比较">2.4.2 多学习器比较</a></li>
</ul></li>
<li><a href="#25-偏差与方差">2.5 偏差与方差</a></li>
</ul></li>
</ul>
<hr />
<h2 id="chapter-2-模型评估与选择">Chapter 2: 模型评估与选择</h2>
<h3 id="经验误差与过拟合">2.1 经验误差与过拟合</h3>
<ul>
<li><p><strong>错误率(Error Rate):</strong>
分类错误的样本数占样本总数的比例, 记样本数为<span
class="math inline">\(m\)</span>, <span
class="math inline">\(a\)</span>个错误分类的样本, 错误率 <span
class="math inline">\(E=\frac{a}{m}\)</span> .</p></li>
<li><p><strong>精度(Accuracy):</strong> <span class="math inline">\((1 -
\frac{a}{m}) \times 100\%\)</span> 称为精度, 即 "精度 = 1 -
错误率".</p></li>
<li><p><strong>误差(Error):</strong> 更一般地,
我们把<strong>学习器的实际预测输出</strong>与<strong>样本的真实输出</strong>之间的差异称为误差,
学习器在训练集上的误差称为 <strong>训练误差(Training
Error)/经验误差(Empirical Error)</strong>,
在新样本上的误差称为<strong>泛化误差(Generalization Error)</strong>.</p>
<blockquote>
<p><strong>Tips:</strong> 这里的误差均指<strong>误差期望</strong>.</p>
</blockquote></li>
</ul>
<p>尽管我们希望得到一个泛化误差小的学习器, 使得其在新样本上表现很好,
但我们并不能预测新样本, 因此我们只能尝试降低经验误差.
但经验误差很小的学习器往往在泛化误差的表现上都很糟糕.
这样的学习器发生了<strong>过拟合</strong>.</p>
<ul>
<li><p><strong>过拟合(Overfitting):</strong>
学习器可能将训练样本自身的一些特点当作了所有潜在样本都具有的一般性质,
导致泛化能力下降的现象.</p></li>
<li><p><strong>欠拟合(Underfitting):</strong> 与过拟合相对,
指对训练样本的一般性质尚未学好.</p></li>
</ul>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-1.png" class="" title="pic2-1">
<blockquote>
<p><strong>Tips:</strong> 导致过拟合的原因很多,
最常见的原因是学习能力过强; 欠拟合则相反, 因为学习能力低下.
欠拟合容易克服, 但过拟合很难解决, 且过拟合无法彻底避免.</p>
</blockquote>
<ul>
<li><strong>模型选择(Model Selection):</strong> 在实际中,
面对同一个问题, 往往有多种学习算法可以选择,
参数配置也会对模型产生影响.</li>
</ul>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-2.png" class="" title="spic2-2">
<h3 id="评估方法">2.2 评估方法</h3>
<p>通常我们可以通过实验测试对学习器的泛化误差进行评估,
使用<strong>测试集(Testing Set)</strong>测试学习器对新样本的判别能力,
以测试集上<strong>测试误差(Testing Error)</strong>作为泛化误差的近似.
但需要注意的是, 测试集应尽可能与训练集互斥.</p>
<blockquote>
<p>假设我们有且只有一个包含<span
class="math inline">\(m\)</span>个样例的数据集<span
class="math inline">\(D = \{(x_1,y_1),(x_2,y_2), ...,
(x_m,y_m)\}\)</span>, 既要训练, 又要测试, 这样就需要对<span
class="math inline">\(D\)</span>进行适当处理, 从中产生
<strong>训练集</strong> <span class="math inline">\(S\)</span>和
<strong>测试集</strong> <span class="math inline">\(T\)</span>.</p>
</blockquote>
<h4 id="留出法hold-out">2.2.1 留出法(Hold-Out)</h4>
<p>留出法的思路很简单, 直接将数据集<span
class="math inline">\(D\)</span>划分成两个互斥的集合, 即<span
class="math inline">\(D = S \cup T, S \cap T = \emptyset\)</span>.</p>
<p>使用留出法时需要注意训练集和测试集的划分需要保持数据分布一致性,
避免因数据划分引入额外偏差对结果产生影响.
同时单次留出法得到的估计往往并不够准确可靠, 一般采用若干次随机划分,
重复进行实验评估取平均值作为留出法评估结果. 关于划分比例, 通常取2/3 ~
4/5的样本用于训练, 其余用于测试.</p>
<h4 id="交叉验证法cross-validation">2.2.2 交叉验证法(Cross
Validation)</h4>
<p>交叉验证法可以看作是一种具体的留出法, 其方法过程是:</p>
<p>先将数据集<span class="math inline">\(D\)</span>划分为<span
class="math inline">\(k\)</span>个大小相似的互斥子集, <span
class="math inline">\(D = D_1 \cup D_2 \cup ... \cup D_k, D_i \cap D_j =
\emptyset (i \neq j)\)</span>, 子集<span
class="math inline">\(D_i\)</span>通过保留类别比例的<strong>分层采样(Stratified
Sampling)</strong>来尽可能保持数据分布一致性.</p>
<p>接下来每次取<span class="math inline">\(k-1\)</span>个子集作为训练集,
余下一个作为测试集, 进行<span
class="math inline">\(k\)</span>次训练和测试, 最终结果取<span
class="math inline">\(k\)</span>个结果的均值.</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-2.png" class="" title="pic2-2">
<p>显然交叉验证法评估结果的<strong>稳定性(Stability)</strong>和<strong>保真性(Fidelity)</strong>与<span
class="math inline">\(k\)</span>的取值强相关.
故而交叉验证法又称<strong>k折交叉验证(k-fold Cross Validation)</strong>.
最常见的取值是 <span class="math inline">\(k=10\)</span>.</p>
<p>由于<span class="math inline">\(D\)</span>的<span
class="math inline">\(k\)</span>划分不唯一, k折交叉验证通常也要重复多次,
记为<span class="math inline">\(p\)</span>, 最终结果取这<span
class="math inline">\(p\)</span>次k折交叉验证结果的均值.</p>
<p><strong>留一法(Leave-One-Out, LOO)</strong>, <span
class="math inline">\(|D| = m\)</span>, 则令<span
class="math inline">\(k = m\)</span> 就得到了留一法.</p>
<p>留一法的优势是不受样本划分影响(有且仅有一种划分方式), 训练集仅比<span
class="math inline">\(D\)</span>少一个样本,
绝大多数情况下留一法中被评估的模型与期望用<span
class="math inline">\(D\)</span>训练的模型相似.
因此认为留一法评估结果较为准确. 缺点是当<span
class="math inline">\(m\)</span>较大时, 计算开销过大以致无法接受.</p>
<h4 id="自助法bootstapping">2.2.3 自助法(Bootstapping)</h4>
<p>留出法和交叉验证法都保留了一部分样本用于测试,
因此实际评估的模型所使用的训练集比<span
class="math inline">\(D\)</span>小,
必然会引入一些因训练样本规模不同而导致的估计偏差.
留一法的计算复杂度又太高了. 自助法提供了一个较好的解决方案.</p>
<p>自助法直接以 <strong>自助采样法(Bootstrap Sampling)</strong> 为基础.
给定包含<span class="math inline">\(m\)</span>个样本的数据集<span
class="math inline">\(D\)</span>, 对其进行采样产生数据集<span
class="math inline">\(D&#39;\)</span>. 采样过程每次随即从<span
class="math inline">\(D\)</span>中挑选一个样本, 将拷贝放入<span
class="math inline">\(M&#39;\)</span>
<strong>(意味着下次采样该样本仍有可能被采样到)</strong>. 重复该过程<span
class="math inline">\(m\)</span>次, 得到了包含<span
class="math inline">\(m\)</span>个样本的数据集<span
class="math inline">\(D&#39;\)</span>.</p>
<blockquote>
<p><strong>Tips:</strong> 此处"自助"为意译,
称<strong>可重复采样/有放回采样</strong>更符合其原理.</p>
</blockquote>
<p>不难看出, 可能存在部分样本被多次采样到, 部分样本未被采样到.
我们关注某个样本在<span
class="math inline">\(m\)</span>次中未被采样的概率,有</p>
<p><span class="math display">\[\begin{equation}
\lim_{m \rightarrow \infty}(1 - \frac{1}{m})^m  = \frac{1}{e} \approx
0.368 \tag{2.1}
\end{equation}\]</span></p>
<p>通过自主采样, 初始数据集<span
class="math inline">\(D\)</span>中约有<span
class="math inline">\(36.8\%\)</span>的样本未出现在采样数据集<span
class="math inline">\(D&#39;\)</span>中, 将<span
class="math inline">\(D&#39;\)</span>作为训练集, <span
class="math inline">\(D \backslash D&#39;\)</span>作为测试集.
这样的测试结果称为<strong>包外估计(Out-Of-Bagestimate)</strong>.</p>
<p>自助法在数据集较小, 难以有效划分训练和测试集的时候具有优势.
但自助法产生的数据集改变了初始数据集的分布, 会引入估计误差.
初始数据集较大时更常用留出法和交叉验证法.</p>
<h4 id="调参与最终模型">2.2.4 调参与最终模型</h4>
<p><strong>参数(Parameter)</strong>和<strong>调参(Parameter
Tuning)</strong>释义见名称.</p>
<blockquote>
<p><strong>Tips:</strong> 机器学习常涉及两类参数:
算法参数和模型参数.</p>
</blockquote>
<ul>
<li><p><strong>验证集(Validation Set):</strong>
模型评估与选择中用于评估测试的数据集常称为验证集.</p>
<blockquote>
<p><strong>Additonal:</strong> 关于训练集, 测试集和验证集的区别,
笔者在此参考<a
href="https://zhuanlan.zhihu.com/p/98532085"><strong>[知乎|训练集、验证集、测试集]</strong></a></p>
</blockquote></li>
</ul>
<h3 id="性能度量">2.3 性能度量</h3>
<ul>
<li><strong>性能度量(Performance Measure):</strong>
衡量模型泛化能力的评价标准. 显然该标准取决于任务需求.</li>
</ul>
<p>以预测任务为例, 给定样例集<span class="math inline">\(D =
\{(\boldsymbol{x_1}, y_1), (\boldsymbol{x_2}, y_2), ...,
(\boldsymbol{x_m}, y_m)\}\)</span>, 其中<span
class="math inline">\(y_i\)</span>是<span
class="math inline">\(\boldsymbol{x_i}\)</span>的真实标记,
评估学习器<span class="math inline">\(f\)</span>的性能,
需要比较预测结果<span class="math inline">\(f(x)\)</span>与真实标记<span
class="math inline">\(y\)</span>.</p>
<p>回归任务常用性能度量<strong>均方误差(Mean Squared Error)</strong></p>
<p><span class="math display">\[\begin{equation}
E(f;D) = \frac{1}{m} \sum_{i=1}^{m}(f(\boldsymbol{x_i}) - y_i)^2
\tag{2.2}
\end{equation}\]</span></p>
<p>更一般地, 对于数据分布<span
class="math inline">\(\mathcal{D}\)</span>和概率密度函数<span
class="math inline">\(p(\cdot)\)</span>, 均方误差描述为</p>
<p><span class="math display">\[\begin{equation}
E(f;\mathcal{D}) = \int_{x \sim \mathcal{D}}^{}(f(\boldsymbol{x}) - y)^2
p(\boldsymbol{x}) d\boldsymbol{x} \tag{2.3}
\end{equation}\]</span></p>
<h4 id="错误率与精度">2.3.1 错误率与精度</h4>
<p>错误率和精度是分类任务中最常用的两种性能度量.</p>
<p>对于样例集<span class="math inline">\(\mathcal{D}\)</span>,
错误率和精度定义为</p>
<p><span class="math display">\[\begin{equation}
E(f;D) = \frac{1}{m} \sum_{i=1}^{m}\mathbb{I}(f(\boldsymbol{x_i}) \neq
y_i) \tag{2.4}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
acc(f;D) = \frac{1}{m} \sum_{i=1}^{m}\mathbb{I}(f(\boldsymbol{x_i}) =
y_i) = 1 - E(f;D) \tag{2.5}
\end{equation}\]</span></p>
<p>对于数据分布<span
class="math inline">\(\mathcal{D}\)</span>和概率密度函数<span
class="math inline">\(p(\cdot)\)</span>, 错误率和精度定义为</p>
<p><span class="math display">\[\begin{equation}
E(f;\mathcal{D}) = \int_{x \sim
\mathcal{D}}^{}\mathbb{I}(f(\boldsymbol{x}) \neq y) p(\boldsymbol{x})
d\boldsymbol{x} \tag{2.6}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
acc(f;\mathcal{D}) = \int_{x \sim
\mathcal{D}}^{}\mathbb{I}(f(\boldsymbol{x}) = y) p(\boldsymbol{x})
d\boldsymbol{x} = 1 - E(f;\mathcal{D}) \tag{2.7}
\end{equation}\]</span></p>
<h4 id="查准率precision-查全率recall-f1">2.3.2 查准率(Precision),
查全率(Recall), F1</h4>
<p>有时我们更关心模型的正确率,
比如说"挑选出来的瓜有多少是好瓜","有多少好瓜被挑选出来了",
查准率和查全率更适合用来度量.</p>
<p>对于二分类问题, 我们有<strong>混淆矩阵(Confusion Matrix)</strong></p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/tab2-1.png" class="" title="tab2-1">
<p>定义查准率<span class="math inline">\(P\)</span>, 查全率<span
class="math inline">\(R\)</span></p>
<p><span class="math display">\[\begin{equation}
P = \frac{TP}{TP + FP}\tag{2.8}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
P = \frac{TP}{TP + FN}\tag{2.9}
\end{equation}\]</span></p>
<blockquote>
<p><strong>Tips:</strong> 自然语言解释就是,
查准率是在预测正确中实际正确的比率,
查全率是在实际正确中预测正确的比率.</p>
</blockquote>
<p>查准率和查全率是一对矛盾的度量, 二者负相关.
是<strong>sound</strong>和<strong>complete</strong>的关系</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-1.png" class="" title="spic2-1">
<blockquote>
<p><strong>Tips:</strong> 该图片截选自NJU软件分析课件,
<del>ly和tt老师应该不会在意吧(雾)</del></p>
<p>课程地址链接<a
href="https://tai-e.pascal-lab.net/lectures.html"><strong>[Static
Program Analysis]</strong></a></p>
</blockquote>
<p>查准率和查全率的关系可以用<strong>P-R图</strong>表示</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-3.png" class="" title="pic2-3">
<ul>
<li><strong>平衡点(Break-Even Point, BEP):</strong> <span
class="math inline">\(P=R\)</span>时的取值,
可基于BEP评估两个学习器的优劣, 如图2-3, 可认为<span
class="math inline">\(A&gt;B&gt;C\)</span></li>
</ul>
<p>比BEP更常用的是<span class="math inline">\(F1\)</span>度量定义为</p>
<p><span class="math display">\[\begin{equation}
F1 = \frac{2 \times P \times R}{P + R} = \frac{2 \times TP}{样例总数 +
TP - TN}\tag{2.10}
\end{equation}\]</span></p>
<p><span class="math inline">\(F_{\beta}\)</span>是<span
class="math inline">\(F_1\)</span>的一般形式, 定义为</p>
<p><span class="math display">\[\begin{equation}
F_{\beta} = \frac{(1 + \beta^2) \times P \times R}{(\beta^2 \times P) +
R}\tag{2.11}
\end{equation}\]</span></p>
<p>其中<span class="math inline">\(\beta &gt;
0\)</span>度量了查全率对查准率的相对重要性, <span
class="math inline">\(\beta = 1\)</span>时退化为<span
class="math inline">\(F_1\)</span>, <span class="math inline">\(\beta
&gt; 1\)</span>时查全率影响更大, <span class="math inline">\(\beta &lt;
1\)</span>时查准率影响更大.</p>
<blockquote>
<p><strong>Tips:</strong></p>
<p><span class="math inline">\(F_1\)</span>基于调和平均定义, <span
class="math inline">\(\frac{1}{F_1} = \frac{1}{2} \cdot (\frac{1}{P} +
\frac{1}{R})\)</span>.</p>
<p><span class="math inline">\(F_\beta\)</span>基于加权调和平均定义,
<span class="math inline">\(\frac{1}{F_\beta} = \frac{1}{1 + \beta^2}
\cdot (\frac{1}{P} + \frac{\beta^2}{R})\)</span></p>
</blockquote>
<p>若在n个二分类混淆矩阵上考察准确率和查全率,
我们有<strong>macro</strong>和<strong>micro</strong>两种选择.</p>
<p>对于<strong>宏(macro)</strong>, 在各个混淆矩阵上分别计算<span
class="math inline">\(P\)</span>和<span
class="math inline">\(R\)</span>,
再取平均.得到<strong>宏查准率(macro-P)</strong>,
<strong>宏查全率(macro-R)</strong>, <strong>宏F1(macro-F1)</strong></p>
<p><span class="math display">\[\begin{equation}
macro\text{-}P = \frac{1}{n} \sum_{i=1}^{n} P_i\tag{2.12}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
macro\text{-}R = \frac{1}{n} \sum_{i=1}^{n} R_i\tag{2.13}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
macro\text{-}F1 = \frac{2 \times macro\text{-}P \times
macro\text{-}R}{macro\text{-}P + macro\text{-}R}\tag{2.14}
\end{equation}\]</span></p>
<p>对于<strong>微(micro)</strong>, 先平均混淆矩阵得到$, , , $,
再计算出<strong>微查准率(micro-P)</strong>,
<strong>微查全率(micro-R)</strong>, <strong>微F1(micro-F1)</strong></p>
<p><span class="math display">\[\begin{equation}
micro\text{-}P =
\frac{\overline{TP}}{\overline{TP}+\overline{FP}}\tag{2.15}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
micro\text{-}R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}
\tag{2.16}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
micro\text{-}F1 = \frac{2 \times micro\text{-}P \times
micro\text{-}R}{micro\text{-}P + micro\text{-}R}\tag{2.17}
\end{equation}\]</span></p>
<h4 id="roc与auc">2.3.3 ROC与AUC</h4>
<p>现重新考虑查准率和查全率, 首先我们来看看学习器如何给正/反的分类.</p>
<p>很多学习器为测试样本产生一个实值或概率预测,
将预测值与<strong>分类阈值(Threshold)</strong>比较, 大于阈值则为正类,
否则为反类. 根据该实值或概率预测进行排序, 概率高的在前, 概率低的在后,
则这个分类阈值就是<strong>截断点(Cut Point)</strong>, 前一部分为正例,
后一部分为负例.</p>
<p>不难得到以下结论: 截断点越靠前, 查准率增高而查全率降低; 截断点越靠后,
查准率降低而查全率增高. 同时,
排序质量越好的学习器"在一般情况下"泛化性能越好,
ROC基于此度量模型的泛化能力.</p>
<p><strong>受试者工作特征(Receiver Operating Characteristic,
ROC)</strong>, 根据学习器的预测结果对样例进行排序,
顺序逐个把样本作为正例进行预测(选择不同的截断点),计算
<strong>真正例率(True Positive Rate, TPR)</strong>,
<strong>假正例率(False Positive Rate, FPR)</strong> 作为纵横轴.</p>
<p><span class="math display">\[\begin{equation}
TPR = \frac{TP}{TP + FN}
\tag{2.18}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
FPR = \frac{FP}{TN + FP}
\tag{2.19}
\end{equation}\]</span></p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-4.png" class="" title="pic2-4">
<p>对角线对应随即猜测模型, 点(0, 1)对应所有正例在负例前的理想模型.</p>
<ul>
<li><strong>AUC(Area Under ROC Curve):</strong> ROC曲线下面积.
为依据两个模型绘制的ROC曲线比较两个模型的优劣而引入.</li>
</ul>
<p>对于离散样本, 计算AUC:</p>
<p><span class="math display">\[\begin{equation}
AUC = \frac{1}{2} \sum^{m - 1}_{i=1}(x_{i+1} - x_i)\cdot(y_i + y_{i + 1}
)
\tag{2.19}
\end{equation}\]</span></p>
<p>形式化上AUC度量排序质量, 记有<span
class="math inline">\(m^+\)</span>个正例, <span
class="math inline">\(m^-\)</span>个反例, 令<span
class="math inline">\(D^+\)</span>为正例集合, <span
class="math inline">\(D^-\)</span>为负例集合,
定义排序<strong>损失(loss):</strong></p>
<p><span class="math display">\[\begin{equation}
\mathscr{l}_{rank} = \frac{1}{m^+ m^-}\sum_{x^+ \in D^+} \sum_{m^- \in
D^-}\left(\mathbb{I}(f(x^+)&lt;f(x^-)) + \frac{1}{2} \mathbb{I}(f(x^+)=
f(x^-))\right)
\tag{2.21}
\end{equation}\]</span></p>
<p>如何理解这个式子? 考虑每一对正反例, 若正例小于反例记一个"罚分",
相等则记半个. 不难看出, 对于每个正例/负例, 可能造成的"罚分"与其"位置",
越"错误"的位置会引起越多的"罚分", 这与AUC计算过程及其相似. 实际上, <span
class="math inline">\(\mathscr{l}_{rank}\)</span>对应ROC曲线上方的面积,
有</p>
<p><span class="math display">\[\begin{equation}
AUC = 1 - \mathscr{l}_{rank}
\tag{2.22}
\end{equation}\]</span></p>
<h4 id="代价敏感错误率与代价曲线">2.3.4 代价敏感错误率与代价曲线</h4>
<p>为权衡不同类型错误所造成的不同损失,
我们为错误赋予<strong>非均等代价(UnEqual Cost)</strong>.</p>
<p>以二分类为例, <strong>代价矩阵(Cost Matrix)</strong>如下:</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/tab2-2.png" class="" title="tab2-2">
<p>若将0类记为正例, 1类记为负例, 定义<span class="math inline">\(D^+,
D^-\)</span>, <strong>代价敏感(Cost-Sensitive)</strong> 错误率为</p>
<p><span class="math display">\[\begin{equation}
E(f;D;cost) = \frac{1}{m} \left(\sum_{\boldsymbol{x}_i \in D^+}
\mathbb{I}(f(\boldsymbol{x}_i) \neq y_i) \times cost_{01} +
\sum_{\boldsymbol{x}_i \in D^-} \mathbb{I}(f(\boldsymbol{x}_i) \neq y_i)
\times cost_{10}\right)
\tag{2.23}
\end{equation}\]</span></p>
<p>非均等情况下, <strong>代价曲线(Cost
Curve)</strong>可以解决ROC曲线不能反映出学习器的期望<strong>总体代价(Total
Cost)</strong>问题.</p>
<p>其横轴是取值为<span
class="math inline">\([0,1]的\)</span>正例概率代价, 其中<span
class="math inline">\(p\)</span>为样例是正例的概率</p>
<p><span class="math display">\[\begin{equation}
P(+)cost=\frac{p \times cost_{01}}{p \times cost_{01} + (1 - p) \times
cost_{10}}
\tag{2.24}
\end{equation}\]</span></p>
<p>纵轴是取值为<span
class="math inline">\([0,1]\)</span>的归一化代价,FPR为假正例率,
FNR为假反例率</p>
<p><span class="math display">\[\begin{equation}
cost_{norm} = \frac{FNR \times p \times cost_{01} + FPR \times (1 - p)
\times cost_{10}}{p \times cost_{01} + (1 - p) \times cost_{10}}
\tag{2.25}
\end{equation}\]</span></p>
<p>绘制代价曲线时, ROC曲线上每个点对应代价平面上的一条线段,
设ROC点坐标为<span class="math inline">\((FPR, TPR)\)</span>,
然后在代价平面上绘制一条从<span class="math inline">\((0,
FPR)\)</span>到<span class="math inline">\((1, FNR)\)</span>的线段,
线段下面积代表了该条件下的期望总体代价.如此为每个点绘制线段, 取线段下界,
围成面积即为在所有条件下学习器的总体期望代价.</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-5.png" class="" title="pic2-5">
<blockquote>
<p><strong>Addtional:</strong> 如何理解代价曲线?</p>
<p>笔者在此给出一篇参考<a
href="https://www.zhihu.com/question/63492375"><strong>[知乎|代价曲线的理解]</strong></a>.这篇参考中对大部分问题给到了解释.</p>
<p>在此额外补充一点困惑笔者许久的问题, 每一条线段代表什么?</p>
<p>每一条线段代表当前<strong>阈值</strong>条件下,
对不同样本集的期望代价. 具体来说,
是以FPR和FNR为预测值对不同样本集的预测.</p>
</blockquote>
<h3 id="比较检验">2.4 比较检验</h3>
<p><strong>统计假设检验(Hypothesis Test)</strong>
为比较学习器性能提供了重要依据. 本节默认以错误率为性能度量, 用<span
class="math inline">\(\epsilon\)</span>表示.</p>
<h4 id="假设检验">2.4.1 假设检验</h4>
<p>现实中我们无法知道学习器的泛化错误率 <span
class="math inline">\(\epsilon\)</span>, 只能获知其测试错误率 <span
class="math inline">\(\hat{\epsilon}\)</span>.
常用测试错误率估推出泛化错误率.</p>
<p>对于 <span class="math inline">\(m\)</span> 个测试样本,
如果测试错误率为 <span class="math inline">\(\hat{\epsilon}\)</span>,
则被误分类的样本数量 <span class="math inline">\(m&#39;=\hat{\epsilon}
\times m\)</span>, 假定测试样本从样本总体分布中独立采样获得,
由<strong>二项(Binomial)分布</strong>, 泛化错误率为 <span
class="math inline">\(\hat{\epsilon}\)</span> 的学习器恰有 <span
class="math inline">\(m&#39;\)</span> 个样本被误分类的概率是 <span
class="math inline">\(\binom{m}{m&#39;}\epsilon^{m&#39;}(1-\epsilon)^{m-m&#39;}\)</span>
. 同时, 这也表示泛化错误率为 <span
class="math inline">\(\epsilon\)</span> 的学习器在<span
class="math inline">\(m\)</span>个样本上测试得到测试错误率为 <span
class="math inline">\(\hat{\epsilon}\)</span> 的概率:</p>
<p><span class="math display">\[\begin{equation}
P(\hat{\epsilon};\epsilon)=\binom{m}{\hat{\epsilon} \times m}
\epsilon^{\hat{\epsilon} \times m} (1 - \epsilon)^{m - \hat{\epsilon}
\times m}
\tag{2.26}
\end{equation}\]</span></p>
<p>由二项分布性质, 或者计算 <span
class="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 对 <span
class="math inline">\(\epsilon\)</span> 的偏导, 可以知道 <span
class="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 在 <span
class="math inline">\(\epsilon = \hat{\epsilon}\)</span> 时最大, <span
class="math inline">\(|\epsilon - \hat{\epsilon}|\)</span> 增大时 <span
class="math inline">\(P(\hat{\epsilon};\epsilon)\)</span> 减小.</p>
<p>若取 <span class="math inline">\(m=10, \epsilon = 0.3\)</span>,
示意图如2.6所示.</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-6.png" class="" title="pic2-6">
<blockquote>
<p><strong>Tips:</strong>
<del>死去的《概率论与数理统计》突然复活起来攻击我</del>, 推荐复习笔记<a
href="https://zhuanlan.zhihu.com/p/243215469"><strong>[知乎|概率论与数理统计复习整理]</strong></a>.</p>
</blockquote>
<p>由<strong>二项检验(Binomial Test)</strong>, 考虑假设<span
class="math inline">\(\epsilon \leq \epsilon_0\)</span>, 在 <span
class="math inline">\(1 - \alpha\)</span>
的概率内能观测到的最大错误率为</p>
<p><span class="math display">\[\begin{equation}
\bar{\epsilon} = \min \epsilon \ \ \text{s.t.} \ \ \sum_{i = \epsilon
\times m + 1}^{m} \binom{m}{i}\epsilon_0^i (1 - \epsilon_0)^{m - i} &lt;
\alpha
\tag{2.27}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(1-\alpha\)</span>
为<strong>置信度(Confidence)</strong>, 直观上对应图2.6的非阴影部分;
"s.t."是"subject to", 使左边式子在右边式子条件满足时成立.</p>
<p>若测试错误率 <span class="math inline">\(\hat{\epsilon}\)</span>
大于临界值 <span class="math inline">\(\bar{\epsilon}\)</span>,
由二项检验, 我们可以认为在 <span class="math inline">\(\alpha\)</span>
的显著度下, 假设 <span class="math inline">\(\epsilon \leq
\hat{\epsilon}\)</span> 不能被拒绝, 即能以 <span
class="math inline">\(1-\alpha\)</span> 的置信度认为,
学习器的泛化错误率不高于 <span
class="math inline">\(\epsilon_0\)</span>; 否则可以拒绝假设, 在 <span
class="math inline">\(\alpha\)</span>
的显著度下可认为学习器的泛化错误率大于 <span
class="math inline">\(\epsilon_0\)</span>.</p>
<p>在通过多次测试中中我们会获得多个测试错误率,
此时可使用<strong>t检验(t-test)</strong>.</p>
<p>设<span class="math inline">\(k\)</span>个错误率 <span
class="math inline">\(\hat{\epsilon_1}, \hat{\epsilon_2}, ...,
\hat{\epsilon_k}\)</span>, 则平均错误率 <span
class="math inline">\(\mu\)</span>, 方差 <span
class="math inline">\(\sigma^2\)</span> 为</p>
<p><span class="math display">\[\begin{equation}
\mu = \frac{1}{k} \sum_{i=1}^k \hat{\epsilon_i}
\tag{2.28}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\sigma^2=\frac{1}{k-1} \sum^{k}_{i=1}(\hat{\epsilon_i} - \mu)^2
\tag{2.29}
\end{equation}\]</span></p>
<p><span class="math inline">\(k\)</span> 个测试错误率可看作是泛化错误率
<span class="math inline">\(\epsilon_0\)</span> 的独立采样, 则变量</p>
<p><span class="math display">\[\begin{equation}
\tau_t=\frac{\sqrt{k} (\mu - \epsilon_0)}{\sigma}
\tag{2.30}
\end{equation}\]</span></p>
<p>服从自由度为 <span class="math inline">\(k-1\)</span> 的 <span
class="math inline">\(t\)</span> 分布.</p>
<blockquote>
<p><strong>Addtional:</strong> <strong>基础知识补充</strong></p>
<p><span class="math inline">\(\chi^2\)</span> 分布: <span
class="math inline">\(X_1, X_2, ..., X_n\)</span> 为独立同分布随机变量,
服从 <span class="math inline">\(N(0, 1)\)</span>, 则 <span
class="math inline">\(\chi^2_n = \sum_{i=1}^n X^2_i\)</span>
为服从自由度为 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(\chi^2\)</span> 分布</p>
<p><span class="math inline">\(t\)</span> 分布: <span
class="math inline">\(X \sim N(0,1), Y \sim \chi^2(n)\)</span>, <span
class="math inline">\(X,Y\)</span> 独立, 称 <span
class="math inline">\(T = \frac{X}{\sqrt{\frac{Y}{n}}}\)</span>
为服从自由度为 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(t\)</span> 分布.</p>
</blockquote>
<blockquote>
<p><strong>Tips:</strong> <strong>推导补充</strong></p>
<p>原书中没有关于这个<span
class="math inline">\(\tau_t\)</span>服从<span
class="math inline">\(t\)</span>分布的推导, 笔者在此给出补充.</p>
<p>假设<span
class="math inline">\(X_1,X_2,...X_n\)</span>是来自正态总体<span
class="math inline">\(N(\mu,\sigma^2)\)</span>的样本.
我们有以下重要统计量:</p>
<p><span class="math display">\[
\begin{align}
\nonumber\text{样本均值}&amp; \ \bar{X}=\frac{1}{n}\sum_{i=1}^n &gt;X_i
\\
\nonumber\text{样本方差}&amp; \
S^2=\frac{1}{n-1}\sum_{i-1}^{n}(X_i-\bar{X})^2
\end{align}
\]</span></p>
<p>我们有几个重要结论:</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-3.png" class="" title="spic2-3">
<p>故而有推论:</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/spic2-4.png" class="" title="spic2-4">
</blockquote>
<p>对假设<span
class="math inline">\(\mu=\epsilon_0\)</span>和显著度<span
class="math inline">\(\alpha\)</span>, 可以算出临界值——在<span
class="math inline">\(1-\alpha\)</span>内能观测到的最大错误率.
考虑<strong>双边假设(Two-Tailed)</strong>, 若<span
class="math inline">\(\tau_t\)</span>位于临界区<span
class="math inline">\([t_{-\alpha/2},t_{\alpha/2}]\)</span>内(如图2.7所示),
则不能拒绝假设<span class="math inline">\(\mu=\epsilon_0\)</span>.
我们可以认为泛化错误率为<span
class="math inline">\(\epsilon_0\)</span>.</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-7.png" class="" title="pic2-7">
<h4 id="多学习器比较">2.4.2 多学习器比较</h4>
<p>笔者对这部分不做过多记录, 翻阅原书该部分即可.</p>
<p>对于两个学习器,我们有</p>
<ul>
<li>交叉验证t检验(基于成对t 检验)</li>
<li>McNember检验(基于列联表，卡方检验)</li>
</ul>
<p>对于多个学习器,我们有</p>
<ul>
<li>Friedman检验(基于序值，F检验; 判断”是否都相同”)</li>
<li>Nemenyi后续检验(基于序值，进一步判断两两差别)</li>
</ul>
<h3 id="偏差与方差">2.5 偏差与方差</h3>
<ul>
<li><strong>偏差-方差分解(Bias-variance Decomposition)</strong></li>
</ul>
<p>对测试样本<span class="math inline">\(\boldsymbol{x}\)</span>,
令<span class="math inline">\(y_D\)</span>为<span
class="math inline">\(\boldsymbol{x}\)</span>在数据集的集中标记, <span
class="math inline">\(y\)</span>为<span
class="math inline">\(\boldsymbol{x}\)</span>的真实标记, <span
class="math inline">\(f(\boldsymbol{x};D)\)</span>为训练集<span
class="math inline">\(D\)</span>上的学得模型<span
class="math inline">\(f\)</span>在<span
class="math inline">\(\boldsymbol{x}\)</span>上的预测输出.</p>
<p>以回归算法为例, 我们有如下定义(符号定义见<a
href="http://localhost:4000/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/#chapter-0-%E4%B8%BB%E8%A6%81%E7%AC%A6%E5%8F%B7%E8%A1%A8"><strong>[Lapluma|读书笔记-机器学习
Ch0-Ch1]</strong></a>):</p>
<p>学习算法的期望预测.</p>
<p><span class="math display">\[\begin{equation}
\bar{f}(\boldsymbol{x})=\mathbb{E}_D[f(\boldsymbol{x};D)]
\tag{2.37}
\end{equation}\]</span></p>
<p>使用样本数相同的不同训练集产生的方差,
度量了同样大小的训练集变动导致的学习性能变化,
刻画了数据扰动造成的影响.</p>
<p><span class="math display">\[\begin{equation}
\mathcal{var}(\boldsymbol{x})=\mathbb{E}_D[(f(\boldsymbol{x};D)-\bar{f}(x))^2]
\tag{2.38}
\end{equation}\]</span></p>
<p>噪声, 在当前学习任务上任何学习算法所能达到的期望泛化误差下界,
刻画了学习问题本身的难度.</p>
<p><span class="math display">\[\begin{equation}
\varepsilon^2=\mathbb{E}_D[(y_D-y)^2]
\tag{2.39}
\end{equation}\]</span></p>
<p>期望输出与真实标记的差别称为偏差,
度量了学习算法的期望预测与真是结果的偏离程度,
刻画了学习算法本身的拟合能力.</p>
<p><span class="math display">\[\begin{equation}
\mathcal{bias}^2(\boldsymbol{x})=(\bar{f}(\boldsymbol{x})-y)^2
\tag{2.40}
\end{equation}\]</span></p>
<p>便于讨论,我们假定噪声期望为0, 即<span
class="math inline">\(\mathbb{E}_D[y_D-y]=0\)</span>,
对期望泛化误差进行分解(推导略, 见原书), 有</p>
<p><span class="math display">\[\begin{equation}
E(f;D)=bias^2(\boldsymbol{x})+var(\boldsymbol{x})+\varepsilon ^2
\tag{2.42}
\end{equation}\]</span></p>
<p>即泛化误差可以分解为偏差, 方差和噪声之和.</p>
<p>一般来说, 偏差和方差存在冲突, 称为<strong>偏差-方差窘境(Bias-Variance
Dilemma)</strong>,见图2-9.</p>
<img src="/BookNote-MachineLearning-by-ZhihuaZhou-2/pic2-9.png" class="" title="pic2-9">
<p>训练不足时, 学习器拟合能力不足,
训练数据的扰动不足以使学习器产生显著变化,
此时偏差主导了泛化错误率;训练程度加深, 学习器拟合能力增强,
训练数据发生的扰动被学习器学习到, 方差逐渐主导了泛化错误率;训练充足后,
学习器拟合能力非常强. 训练数据发生轻微扰动都会导致学习器发生显著变化,
此时训练数据自身,非全局的性质被学习器学习, 发生过拟合.</p>
]]></content>
      <categories>
        <category>读书笔记-机器学习</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-On Java8 Ch0-Ch2</title>
    <url>/BookNote-OnJava8-by-BruceEckel-1/</url>
    <content><![CDATA[<p><strong>你所使用的编程语言会将你的思维模式固化并逐渐远离其他语言,
而且往往发生在潜移默化中. Java作为一门傲娇的语言尤其如此. —— Bruce
Eckel</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#书籍基本信息">书籍基本信息</a></li>
<li><a href="#chapter0-简介前言">Chapter0 简介&amp;前言</a></li>
<li><a href="#chapter1-对象的概念">Chapter1 对象的概念</a>
<ul>
<li><a href="#抽象">抽象</a>
<ul>
<li><a
href="#所有编程语言都提供抽象机制">所有编程语言都提供抽象机制</a></li>
<li><a href="#纯粹oop五大基本特征alan-kay">"纯粹"OOP五大基本特征(Alan
Kay)</a></li>
<li><a href="#grady-booch对对象的描述">Grady Booch对对象的描述</a></li>
</ul></li>
<li><a href="#接口">接口</a></li>
<li><a href="#服务提供">服务提供</a></li>
<li><a href="#封装">封装</a>
<ul>
<li><a href="#使用访问控制的原因">使用访问控制的原因</a></li>
<li><a href="#java访问控制关键字">Java访问控制关键字</a></li>
</ul></li>
<li><a href="#复用">复用</a>
<ul>
<li><a href="#关联关系">关联关系</a></li>
</ul></li>
<li><a href="#继承">继承</a>
<ul>
<li><a href="#区分基类与派生类">区分基类与派生类</a></li>
<li><a href="#is-a-与-is-like-a">is-a 与 is-like-a</a></li>
</ul></li>
<li><a href="#多态">多态</a></li>
<li><a href="#单继承结构">单继承结构</a></li>
<li><a href="#容器">容器</a>
<ul>
<li><a href="#泛型">泛型</a></li>
</ul></li>
<li><a href="#对象创建与生命周期">对象创建与生命周期</a></li>
<li><a href="#异常处理">异常处理</a></li>
</ul></li>
<li><a href="#chapter2-安装java和本书用例">Chapter2
安装Java和本书用例</a></li>
</ul>
<hr />
<h2 id="书籍基本信息">书籍基本信息</h2>
<p>Bruce Eckel "最新"力作<em>On Java 8</em>, 笔者因为课程需要遂阅读本书.
可以从<a
href="https://github.com/Knn120/OnJava8-PDF"><strong>此处</strong></a>获取电子书文件.</p>
<p>需要注意的是, 阅读本书需要一定的编程基础.</p>
<h2 id="chapter0-简介前言">Chapter0 简介&amp;前言</h2>
<blockquote>
<p><strong>语言决定世界观. ——
路德维希·维特根斯坦(Wittgenstein)</strong></p>
</blockquote>
<ul>
<li><p>Java的最核心变化: <strong>虚拟机</strong> 和
<strong>垃圾回收机制</strong></p></li>
<li><p>编程的过程就是复杂性管理的过程: 业务问题的复杂性,
以及依赖的计算机的复杂性.</p></li>
</ul>
<p><em>Thing in C</em> 可以在官方地址<a
href="www.OnJava8.com">www.OnJava8.com</a>免费下载.</p>
<p>示例代码可以通过官方地址<a
href="https://github.com/BruceEckel/OnJava8-examples">https://github.com/BruceEckel/OnJava8-examples</a>中下载.</p>
<h2 id="chapter1-对象的概念">Chapter1 对象的概念</h2>
<blockquote>
<p><strong>我们没有意识到惯用语言的结构有多大力量. 可以毫不夸张地说,
它通过语义反应机制奴役我们.
语言表现出来并在无意识中给我们留下深刻印象的结构会自动投射到我们周围的世界.
—— Alfred Korzybski(1930)</strong></p>
</blockquote>
<ul>
<li>面向对象编程(Object-Oriented Programming,
OOP)是一种编程思维方式和编码架构.</li>
</ul>
<h3 id="抽象">抽象</h3>
<h4 id="所有编程语言都提供抽象机制">所有编程语言都提供抽象机制</h4>
<p>某种程度上, 问题的复杂度直接取决于抽象的类型和质量.</p>
<ul>
<li><p>汇编语言是对底层机器的轻微抽象.</p></li>
<li><p>"命令式"语言(FORTRAN, BASIC, C)是对汇编语言的抽象.</p>
<blockquote>
<p><strong>Tips:</strong>
命令式语言的抽象原理依然要求程序员着重考虑计算机的结构而非问题本身的结构.</p>
</blockquote></li>
</ul>
<p>程序员必须要在<strong>机器模型(解决方案空间)</strong>
和实际解决的<strong>问题模型(问题空间)</strong> 之间建立一种关联.
这个过程既费精力, 又脱离编程语言本身的范畴.</p>
<ul>
<li><p>问题空间中的元素以及它们在解决方案空间的表示称作<strong>对象(Object)</strong>.</p></li>
<li><p>OOP允许程序员根据问题来描述问题,
而不是根据运行解决方案的计算机.</p>
<blockquote>
<p><strong>Tips:</strong> 每个对象都类似一台小计算机,
有自己的状态并且可以进行特定的操作; 与现实中的"对象"或"物体"相似,
有自己的特征和行为.</p>
</blockquote></li>
</ul>
<h4 id="纯粹oop五大基本特征alan-kay">"纯粹"OOP五大基本特征(Alan
Kay)</h4>
<ul>
<li><p>万物皆对象.</p></li>
<li><p>程序是一组对象, 通过消息传递来告知彼此该做什么.</p></li>
<li><p>每个对象有自己的存储空间, 可容纳其他对象.</p></li>
<li><p>每个对象都有一种类型.</p></li>
<li><p>同一类所有对象都能接收相同信息.</p>
<blockquote>
<p><strong>Tips:</strong> 这个表述有点抽象,
结合书中的解释会有所理解.</p>
<p>由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给“形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”
描述的对象，其中自然包括
“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。</p>
</blockquote></li>
</ul>
<h4 id="grady-booch对对象的描述">Grady Booch对对象的描述</h4>
<ul>
<li>一个对象具有自己的状态, 行为和标识.
即对象有自己的内部数据(提供状态), 方法(产生行为),
并彼此区分(每个对象[笔者注:
称之为实例instance或许更好理解]在内存中有唯一的地址).</li>
</ul>
<h3 id="接口">接口</h3>
<p>我们向对象发出的请求是通过它的<strong>接口(Interface)</strong>定义的,
对象的<strong>类型</strong> 或 <strong>类</strong> 规定了接口形式.</p>
<p>假设我们有一个<code>Class Light</code>,
其<strong>统一建模语言(Unified Modeling Language, UML)</strong>
设计图如下:</p>
<img src="/BookNote-OnJava8-by-BruceEckel-1/pic1-1.png" class="" title="pic1-1">
<p>可以通过这样的方式调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Light</span> <span class="variable">lt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>()</span><br><span class="line">lt.on()</span><br></pre></td></tr></table></figure>
<h3 id="服务提供">服务提供</h3>
<p>在开发或理解程序设计时, 可以将对象看成是<strong>服务提供者</strong>.
程序本身为用户提供服务, 并且能通过调用其他对象提供的服务来实现.</p>
<p>在开发时, 可以将分体一一分解, 抽象成一组服务,
每个对象都提供了一组紧密的服务.</p>
<p>软件设计的基本原则是<strong>高内聚</strong>: 每个组件内部作用明确,
功能紧密相关.</p>
<h3 id="封装">封装</h3>
<ul>
<li>编程的侧重领域可以划分为<strong>研发</strong> 和
<strong>应用</strong>.
应用程序员调用研发程序员构建的基础工具来做快速开发.</li>
</ul>
<h4 id="使用访问控制的原因">使用访问控制的原因</h4>
<ul>
<li><p>让应用程序员不要触摸他们不应该触摸的部分.</p></li>
<li><p>使类库的创建者(研发程序员)在不影响应用程序员使用的情况下完善更新工具库.</p></li>
</ul>
<h4 id="java访问控制关键字">Java访问控制关键字</h4>
<ul>
<li><p><strong>public</strong>: 任何人都可以访问和使用.</p></li>
<li><p><strong>private</strong>: 除了类本身和类内部方法,
外界无法直接访问.</p></li>
<li><p><strong>protected</strong>: 允许子类访问protected成员,
但不能访问private成员.</p></li>
<li><p><strong>default</strong>: 包访问,
可以被同一包(组件库)中其他类的成员访问.</p></li>
</ul>
<h3 id="复用">复用</h3>
<ul>
<li><p>一个类经创建和测试后, 理应是可复用的.</p></li>
<li><p>代码和设计方案的可复用性是OOP的优点之一.</p></li>
</ul>
<h4 id="关联关系">关联关系</h4>
<ul>
<li><p><strong>组合(Composition)</strong>: 表示<strong>拥有关系(has-a
relationship)</strong>.</p></li>
<li><p><strong>聚合(Aggregation)</strong>: 动态的组合.</p></li>
</ul>
<blockquote>
<p><strong>Tips: 组合与聚合</strong></p>
<ul>
<li><p>聚合关系中, 整件不会拥有部件的生命周期,
多个整件可以共享同一个部件.</p></li>
<li><p>组合关系中, 整件拥有部件的生命周期,
多个整件不可以共享同一个部件.</p></li>
</ul>
</blockquote>
<p>组合/聚合的设计相较继承, 更简单灵活, 设计更清晰.</p>
<h3 id="继承">继承</h3>
<ul>
<li><strong>基类(父类, 超类)</strong>
包含派生自它的类型之间的共享特征和行为, 表示思想的核心.</li>
<li><strong>派生类(子类, 继承类)</strong>
从基类中派生以表示核心的不同方式.</li>
</ul>
<p><strong>类的层次结构体现了class之间的相似性和差异性.</strong></p>
<h4 id="区分基类与派生类">区分基类与派生类</h4>
<ul>
<li><p>派生类中添加新功能.</p></li>
<li><p>派生类改变基类现有方法的行为,
即<strong>覆盖(overriding)</strong>.</p></li>
</ul>
<h4 id="is-a-与-is-like-a">is-a 与 is-like-a</h4>
<ul>
<li><p><strong>is-a</strong>: 继承只覆盖基类的方法,
不添加基类没有的方法.
此时派生类和基类可以认为是<strong>同一种类型</strong>(具有完全相同的接口).
称为<strong>纯粹替代</strong>.</p></li>
<li><p><strong>is-like-a</strong>: 派生类中添加了新的接口元素,
此时基类无法访问这些新的接口元素.</p></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> 此处笔者直接使用原书中的例子.</p>
<img src="/BookNote-OnJava8-by-BruceEckel-1/pic1-2.png" class="" title="pic1-2">
<img src="/BookNote-OnJava8-by-BruceEckel-1/pic1-3.png" class="" title="pic1-3">
<img src="/BookNote-OnJava8-by-BruceEckel-1/pic1-4.png" class="" title="pic1-4">
</blockquote>
<h3 id="多态">多态</h3>
<p>处理类的层次结构时, 通常把一个对象看成他所属的基类而不是具体类.
这样可以编写出不局限于特定类型的代码.</p>
<blockquote>
<p>在此给出一个多态的例子:</p>
<img src="/BookNote-OnJava8-by-BruceEckel-1/pic1-5.png" class="" title="pic1-5">
<p><code>Birld Controller</code>在<code>Relocate()</code>时不知道也不需要知道<code>Bird</code>的具体类,
也不需要知道执行的是<code>Goose move()</code>还是<code>Penguin move()</code>.</p>
</blockquote>
<ul>
<li><p><strong>早期绑定</strong>: 非OOP编译器产生的函数调用,
其地址在程序运行前就已确定, 调用会被解析为执行代码的绝对地址.</p></li>
<li><p><strong>后期绑定</strong>: 被调用的代码直到运行时才确定.
编译器确保方法存在, 对参数和返回值进行类型检测.</p></li>
</ul>
<p>多态的机制就是由后期绑定实现的.(在部分语言, 如C++中,
必须使用<code>virtual</code>关键字显示授予方法后期绑定属性)</p>
<p><strong>编译器和运行时系统会负责对所有细节的控制,
程序员只需要知道要做什么,
以及如何利用多态性来更好地设计程序.</strong></p>
<h3 id="单继承结构">单继承结构</h3>
<p>Java中所有的类都默认继承自一个基类<code>Object</code>. 与之相对的,
C++允许多继承方案.</p>
<h3 id="容器">容器</h3>
<p>通常我们不知道解决某个具体问题需要的对象数量和持续时间,
以及对象的存储方式. 所以我们该如何获知程序在运行时分配的内存对象?</p>
<p>在OOP中, 创建一个新类型的对象来引用, 容纳其他对象.
Java中通常使用<strong>容器(Collection)</strong>.</p>
<blockquote>
<p><strong>Tips</strong>: 笔者完全不知道翻译时为何要使用"集合"这个术语,
很容易与 <strong>set</strong> 混淆. C++中的<strong>STL(Standard Template
Library)</strong> 亦翻译为容器, 故笔者在此统一使用容器这个表述.</p>
</blockquote>
<p>使用容器的经验告诉我们, 不存在一种容器可以满足所有需求,
针对具体的问题, 需要选择能解决这个问题的容器. 需要注意的是:</p>
<ul>
<li><p>容器可以提供不同类型的接口和外部行为.</p></li>
<li><p>不同集合对某些操作有不同的效率.</p></li>
</ul>
<h4 id="泛型">泛型</h4>
<p>Java5 之前的容器都只保存<code>Object</code>类型,
使用容器时需要对元素做"向上转型", 取出元素时需要做"向下转型".
但遗憾的是"向下转型" <strong>IS NOT SAFE</strong>.</p>
<p>Java5开始提供了<strong>泛型(Generic)</strong>的<strong>参数化类型机制(Parameterized
Type Mechanism)</strong>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="对象创建与生命周期">对象创建与生命周期</h3>
<p>对象可以放在<strong>栈(Stack, 自动变量/作用域变量)</strong> 或
<strong>静态存储域(Static Storage Area)</strong> 静态确定; 也可以在
<strong>堆(Heap)</strong>上动态创建.</p>
<p>C++中需要程序员自己处理对象的创建与回收的一整个生命周期,
以此保证效率.</p>
<p>Java使用动态内存分配, 其内存管理建立在垃圾回收器机制上,
提供了更高级别的保险, 防止了潜在的内存泄漏问题.</p>
<h3 id="异常处理">异常处理</h3>
<p>异常处理机制将程序错误直接交给编程语言甚至操作系统.</p>
<p><strong>异常(Exception)</strong>
是一个从出错点<strong>抛出(Thrown)</strong>
后能被特定类型的异常处理程序<strong>捕获(Catch)</strong> 的一个对象.</p>
<p>异常机制提供了一种可靠的从错误状态中恢复的方法.</p>
<h2 id="chapter2-安装java和本书用例">Chapter2 安装Java和本书用例</h2>
<p>笔者在此略去这部分内容, 有需要的读者可以查阅原书内容.</p>
]]></content>
      <categories>
        <category>读书笔记-OnJava8</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-On Java8 Ch3-Ch5</title>
    <url>/BookNote-OnJava8-by-BruceEckel-2/</url>
    <content><![CDATA[<p><strong>Java语言假设程序员只进行面向对象编程,
因此Java中(几乎)万物皆对象.</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#chapter3-万物皆对象">Chapter3 万物皆对象</a>
<ul>
<li><a href="#对象操纵">对象操纵</a></li>
<li><a href="#对象创建">对象创建</a>
<ul>
<li><a href="#数据存储">数据存储</a></li>
<li><a href="#基本类型存储">基本类型存储</a></li>
<li><a href="#高精度数值">高精度数值</a></li>
<li><a href="#数组存储">数组存储</a></li>
</ul></li>
<li><a href="#代码注释">代码注释</a></li>
<li><a href="#对象清理">对象清理</a>
<ul>
<li><a href="#作用域">作用域</a></li>
<li><a href="#对象作用域">对象作用域</a></li>
</ul></li>
<li><a href="#类的创建">类的创建</a>
<ul>
<li><a href="#类型">类型</a></li>
<li><a href="#字段field">字段(Field)</a></li>
<li><a href="#基本类型默认值">基本类型默认值</a></li>
<li><a href="#方法使用">方法使用</a></li>
<li><a href="#返回类型">返回类型</a></li>
<li><a href="#参数列表">参数列表</a></li>
</ul></li>
<li><a href="#程序编写">程序编写</a>
<ul>
<li><a href="#命名可见性">命名可见性</a></li>
<li><a href="#import">import</a></li>
<li><a href="#static">static</a></li>
</ul></li>
<li><a href="#编码风格">编码风格</a></li>
</ul></li>
<li><a href="#chapter4-运算符">Chapter4 运算符</a>
<ul>
<li><a href="#beginning">Beginning</a></li>
<li><a href="#优先级关联性">优先级&amp;关联性</a></li>
<li><a href="#赋值">赋值</a></li>
<li><a href="#算术运算符">算术运算符</a></li>
<li><a href="#自增自减">自增&amp;自减</a></li>
<li><a href="#关系运算符">关系运算符</a></li>
<li><a href="#逻辑运算符">逻辑运算符</a>
<ul>
<li><a href="#短路">短路</a></li>
</ul></li>
<li><a href="#字面值常量literal">字面值常量(Literal)</a></li>
<li><a href="#位运算符">位运算符</a></li>
<li><a href="#三目运算符">三目运算符</a></li>
</ul></li>
<li><a href="#chapter5-控制流">Chapter5 控制流</a>
<ul>
<li><a href="#if-else">if-else</a></li>
<li><a href="#for-while-do-while">for while do-while</a></li>
<li><a href="#return">return</a></li>
<li><a href="#breakcontinue">break&amp;continue</a>
<ul>
<li><a href="#标签">标签</a></li>
</ul></li>
<li><a href="#switch">switch</a></li>
</ul></li>
</ul>
<hr />
<h2 id="chapter3-万物皆对象">Chapter3 万物皆对象</h2>
<blockquote>
<p><strong>如果我们说另一种不同的语言, 我们会发觉一个不同的世界! ——
Ludwig Wittgenstein(1889-1951)</strong></p>
</blockquote>
<h3 id="对象操纵">对象操纵</h3>
<p>所有的编程语言都会操纵内存中的元素.</p>
<blockquote>
<ul>
<li>C/C++中对象的操纵是通过指针来完成的.</li>
<li>Java利用万物皆对象的思想和单一一致的语法方式来简化问题,
采用<strong>引用(Reference)</strong> 操纵对象.</li>
</ul>
</blockquote>
<h3 id="对象创建">对象创建</h3>
<p>Java中使用<strong>引用</strong>关联<strong>对象</strong>.</p>
<p>通常使用关键字<code>new</code>创建对象实例.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="数据存储">数据存储</h4>
<ul>
<li><strong>寄存器(Registers)</strong>: 最快的存储器, 位于CPU内部.
但数量有限,
且Java无法直接控制(C/C++允许开发者像编译器建议寄存器的分配).</li>
<li><strong>栈内存(Stack)</strong>: 位于<strong>随机访问存储器(Random
Access Memory, RAM)</strong> 中, CPU可通过栈指针直接访问.
栈指针下移分配内存, 上移释放内存. 但栈上的数据要求提前知晓对象生存周期,
因此栈内存上只存放部分Java数据, 对象本身存储在堆内存.</li>
<li><strong>堆内存(Heap)</strong>: RAM区域的一种通用内存池,
存放着所有的Java对象. 相较于栈区, 堆区的使用更灵活,
但代价是分配和清理对象会比栈区更耗时.</li>
<li><strong>常量存储(COnstant Storage)</strong>: 通常直接放在代码中,
可考虑置于<strong>只读存储器(Read Only Memory, ROM)</strong>.</li>
<li><strong>非RAM存储(Non-RAM Storage)</strong>: 数据存在于程序之外,
包括<strong>序列化对象</strong>和<strong>持久化对象</strong>.</li>
</ul>
<h4 id="基本类型存储">基本类型存储</h4>
<p>Java中使用和C/C++一样策略的基本类型数据, 存放在栈中,
其内存占用大小固定.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">基本类型</th>
<th style="text-align: center;">大小</th>
<th style="text-align: center;">最小值</th>
<th style="text-align: center;">最大值</th>
<th style="text-align: center;">包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">boolean</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">Boolean</td>
</tr>
<tr>
<td style="text-align: center;">char</td>
<td style="text-align: center;">16bits</td>
<td style="text-align: center;"><span class="math inline">\(Unicode\
0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(Unicode\
2^{16}-1\)</span></td>
<td style="text-align: center;">Character</td>
</tr>
<tr>
<td style="text-align: center;">byte</td>
<td style="text-align: center;">8bits</td>
<td style="text-align: center;"><span
class="math inline">\(-128\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(+127\)</span></td>
<td style="text-align: center;">Byte</td>
</tr>
<tr>
<td style="text-align: center;">short</td>
<td style="text-align: center;">16bits</td>
<td style="text-align: center;"><span
class="math inline">\(-2^{15}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(+2^{15}-1\)</span></td>
<td style="text-align: center;">Short</td>
</tr>
<tr>
<td style="text-align: center;">int</td>
<td style="text-align: center;">32bits</td>
<td style="text-align: center;"><span
class="math inline">\(-2^{31}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(+2^{31}-1\)</span></td>
<td style="text-align: center;">Integer</td>
</tr>
<tr>
<td style="text-align: center;">long</td>
<td style="text-align: center;">64bits</td>
<td style="text-align: center;"><span
class="math inline">\(-2^{63}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(+2^{63}-1\)</span></td>
<td style="text-align: center;">Long</td>
</tr>
<tr>
<td style="text-align: center;">float</td>
<td style="text-align: center;">32bits</td>
<td style="text-align: center;"><span
class="math inline">\(IEEE754\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(IEEE754\)</span></td>
<td style="text-align: center;">Float</td>
</tr>
<tr>
<td style="text-align: center;">double</td>
<td style="text-align: center;">64bits</td>
<td style="text-align: center;"><span
class="math inline">\(IEEE754\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(IEEE754\)</span></td>
<td style="text-align: center;">Double</td>
</tr>
<tr>
<td style="text-align: center;">void</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">Void</td>
</tr>
</tbody>
</table>
<p>在堆区表示基本类型数据, 需要使用包装类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">Charactor</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Charactor</span>(c);</span><br><span class="line"><span class="type">Charactor</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Charactor</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">Charactor</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="comment">//自动开箱</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ch;</span><br></pre></td></tr></table></figure>
<h4 id="高精度数值">高精度数值</h4>
<p><code>BigInteger</code> &amp; <code>BigDecimal</code></p>
<h4 id="数组存储">数组存储</h4>
<p>Java设计主要目标之一是安全性, 尽管牺牲了部分效率, 但换来了安全性.</p>
<h3 id="代码注释">代码注释</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 跨行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单行注释</span></span><br></pre></td></tr></table></figure>
<h3 id="对象清理">对象清理</h3>
<h4 id="作用域">作用域</h4>
<p>C/C++和Java中的作用域由<code>&#123;&#125;</code>决定.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">114514</span>;</span><br><span class="line">        <span class="comment">//x &amp; q可用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅x可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是, 以下操作在Java中非法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">114514</span>; <span class="comment">//Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips:</strong> 尽管作者在书中如此说明,
但在新版的Java中(笔者使用为JDK17), 该操作是允许的,
仅仅是IDE给出一个提示.</p>
</blockquote>
<h4 id="对象作用域">对象作用域</h4>
<p>Java中的对象与基本类型具有不同的生命周期.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作用域终点</span></span><br><span class="line"><span class="comment">// x生命周期结束</span></span><br><span class="line"><span class="comment">// s生命周期独立作用域</span></span><br></pre></td></tr></table></figure>
<p>Java的内存回收不同于C++, 采用的是垃圾收集器机制,
通过不可达的判断回收对象. 可以有效避免<strong>内存泄漏</strong>问题.</p>
<h3 id="类的创建">类的创建</h3>
<h4 id="类型">类型</h4>
<p>Java中使用<code>class</code>关键字描述新对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br></pre></td></tr></table></figure>
<h4 id="字段field">字段(Field)</h4>
<p>字段可以是基本类型或引用类型.</p>
<p>与C++中对应则是<strong>成员变量</strong>.</p>
<h4 id="基本类型默认值">基本类型默认值</h4>
<p>默认值仅在Java初始化类时使用.</p>
<ul>
<li><p>基本类型会被赋值为<code>0</code>(<code>boolean</code>为<code>false</code>).</p></li>
<li><p>但局部变量不会被赋默认值, 如果不显式指定初始化,
编译器会报错.</p></li>
</ul>
<h4 id="方法使用">方法使用</h4>
<p>对应C++中的成员函数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">return</span> type] [method name](<span class="comment">/*args list*/</span>)&#123;</span><br><span class="line">    <span class="comment">//method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回类型">返回类型</h4>
<ul>
<li><strong>方法签名(Signature of the Method)</strong> 是方法的唯一标识,
包括方法名和参数列表.
(<strong>返回类型不是方法签名的一部分</strong>)</li>
</ul>
<h4 id="参数列表">参数列表</h4>
<p>Java中参数也是通过对象的形式传递, 也就是说,
传递的是对象引用(不包括基本类型).</p>
<h3 id="程序编写">程序编写</h3>
<h4 id="命名可见性">命名可见性</h4>
<ul>
<li><p>C++通过<strong>命名空间(namespace)</strong>
解决命名冲突.</p></li>
<li><p>Java为一个类库生成一个明确的名称来解决冲突.
使用反向URL关联命名空间和文件路径会导致源代码管理出现混乱,
比如说空目录问题(用于表示反向URL).</p></li>
</ul>
<h4 id="import">import</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>
<h4 id="static">static</h4>
<p>在类中的使用与C++基本一致.</p>
<ul>
<li>有时Java使用<strong>类数据(class data)</strong>
和<strong>类方法(class method)</strong> 来表示静态成员.</li>
</ul>
<h3 id="编码风格">编码风格</h3>
<p><strong>Java编程语言编码规范(Code Conventions for the Java
Programming Language).</strong> 采用驼峰命名法. 其中类首字母大写,
字段和方法首字母小写. 对于常量, 可采用全大写 + 下划线的命名方式.</p>
<h2 id="chapter4-运算符">Chapter4 运算符</h2>
<blockquote>
<p><strong>运算符操纵数据.</strong></p>
</blockquote>
<h3 id="beginning">Beginning</h3>
<ul>
<li><p>运算符接受一个或多个参数并生成新值.</p></li>
<li><p><strong>副作用(Side Effect):</strong>
运算符可改变运算对象的值.</p></li>
</ul>
<h3 id="优先级关联性">优先级&amp;关联性</h3>
<img src="/BookNote-OnJava8-by-BruceEckel-2/pic2-1.png" class="" title="pic2-1">
<blockquote>
<p><strong>Tips:</strong> 节选自<a
href="https://www.runoob.com/java/java-operators.html"><strong>[菜鸟教程|Java运算符]</strong></a></p>
</blockquote>
<h3 id="赋值">赋值</h3>
<ul>
<li><p><code>=</code>表示, 将右边的值赋给左边的变量.</p></li>
<li><p>基本类型的赋值是<strong>值传递</strong>.</p></li>
<li><p>对象的赋值是<strong>引用传递</strong>.</p>
<blockquote>
<p><strong>Tips:</strong> 实际上引用传递也是值传递,
只是这里传递的是<strong>内存地址</strong>.</p>
</blockquote></li>
</ul>
<blockquote>
<p><strong>Additional:</strong> <a
href="https://www.zhihu.com/question/31203609?sort=created"><strong>[知乎|Java
到底是值传递还是引用传递？]</strong></a></p>
</blockquote>
<h3 id="算术运算符">算术运算符</h3>
<ul>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,
<code>%</code></li>
</ul>
<h3 id="自增自减">自增&amp;自减</h3>
<ul>
<li><code>++</code>, <code>--</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b == a++; <span class="comment">//先传值后自增, b = 1</span></span><br><span class="line">c == ++a; <span class="comment">//先自增后传值, c = 3</span></span><br></pre></td></tr></table></figure>
<h3 id="关系运算符">关系运算符</h3>
<ul>
<li><p><code>&gt;</code>, <code>&lt;</code>, <code>==</code>,
<code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code></p></li>
<li><p>接受两个操作数,
返回一个<code>boolean</code>值表示操作数之间的关系.</p></li>
</ul>
<p>尽管<code>==</code>和<code>!=</code>可以比较对象,
但更推荐的方法是使用<code>equals()</code>, 需要注意的是,
自定义类型使用<code>equals()</code>需要手动<strong>覆写(Override)</strong>.</p>
<h3 id="逻辑运算符">逻辑运算符</h3>
<ul>
<li><p><code>&amp;&amp;</code>, <code>||</code>, <code>!</code></p></li>
<li><p>根据参数逻辑关系生成布尔值<code>true</code>,
<code>false</code>.</p></li>
</ul>
<h4 id="短路">短路</h4>
<p>当逻辑运算符运算结果确定时,
便会发生<strong>短路(short-circuiting)</strong>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShortCircuit</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    test() &amp;&amp; test() &amp;&amp; test()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行结果只会得到一条<code>test</code>而非三条,
<code>&amp;&amp;</code>在运算时发生了短路.</p>
<h3 id="字面值常量literal">字面值常量(Literal)</h3>
<p>可以指定字面值来确定常量的类型.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0x2f</span>; <span class="comment">//16进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">0177</span>; <span class="comment">//8进制</span></span><br><span class="line"><span class="type">long</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">200L</span>; <span class="comment">//long型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1f</span>; <span class="comment">//float</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1d</span>; <span class="comment">//double</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)<span class="number">0b00110101</span>; <span class="comment">//2进制</span></span><br></pre></td></tr></table></figure>
<h3 id="位运算符">位运算符</h3>
<ul>
<li><code>&amp;</code>, <code>|</code>, <code>~</code>(取反),
<code>^</code>(异或),<code>&lt;&lt;</code>, <code>&gt;&gt;</code>,
<code>&gt;&gt;&gt;</code>(按位右移补零)</li>
</ul>
<h3 id="三目运算符">三目运算符</h3>
<ul>
<li><code>?:</code> -&gt;
<code>variable x = (expression) ? value if true : value if false</code></li>
</ul>
<h2 id="chapter5-控制流">Chapter5 控制流</h2>
<blockquote>
<p><strong>程序必须在执行过程中控制它的世界并作出选择. 在Java中,
程序员需要执行控制语句来做出选择.</strong></p>
</blockquote>
<p>Java支持的关键字包括<code>if-else</code>, <code>while</code>,
<code>do-while</code>, <code>for</code>, <code>return</code>,
<code>break</code>, <code>switch</code>.</p>
<p>需要注意的是,
所有条件语句的Expression应当是<code>boolean</code>类型.</p>
<h3 id="if-else">if-else</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//允许省略else</span></span><br><span class="line"><span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最常见的形式</span></span><br><span class="line"><span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//允许嵌套</span></span><br><span class="line"><span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-while-do-while">for while do-while</h3>
<ul>
<li>循环语句又称迭代语句.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">while</span>(Boolean-Expression)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//do-while</span></span><br><span class="line"><span class="comment">//do-while中do的内容无论while判断是否成立都会被至少执行一次.</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;<span class="keyword">while</span>(Boolean-Expression)</span><br><span class="line"><span class="comment">//for</span></span><br><span class="line"><span class="keyword">for</span>(Initialization; Boolean-Expression; step)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for允许逗号操作符, 使用示例如下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++, j += i)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for-in/for-each</span></span><br><span class="line"><span class="keyword">for</span>(Type x: Contianer)&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : range(<span class="number">10</span>))&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br><span class="line">Container.forEach(</span><br><span class="line">(Var1, Var2, ...) -&gt; &#123;statement&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="return">return</h3>
<ul>
<li>退出当前方法, 返回方法返回值.</li>
</ul>
<h3 id="breakcontinue">break&amp;continue</h3>
<ul>
<li><p><code>break</code>与<code>continue</code>均用在循环体中.</p></li>
<li><p><code>break</code>表示跳出当前循环;
<code>continue</code>表示停止本次循环, 进行下一次循环.</p></li>
</ul>
<h4 id="标签">标签</h4>
<ul>
<li>源于<code>goto</code>机制, 在Java中,
允许为循环体定义<strong>label</strong>,
并允许<code>break</code>和<code>continue</code>使用<strong>label</strong>.</li>
</ul>
<p>具体规则如下:</p>
<ul>
<li><p><code>continue</code>会回退到最内层循环开头, 并继续执行.</p></li>
<li><p><code>continue label</code>会到达标签位置,
并重新进入紧接着那个标签后的循环.</p></li>
<li><p><code>break</code>会中断当前循环, 并移离当前标签末尾.</p></li>
<li><p><code>break label</code>会中断当前循环,
并移离由那个标签指示的循环末尾.</p></li>
</ul>
<p>我们来看两个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            innerLoop:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> outerLoop; <span class="comment">// 跳出外部循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i: &quot;</span> + i + <span class="string">&quot;, j: &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            innerLoop:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> outerLoop; <span class="comment">// 跳过外部循环的当前迭代</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i: &quot;</span> + i + <span class="string">&quot;, j: &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br></pre></td></tr></table></figure>
<h3 id="switch">switch</h3>
<p>其基本格式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector OR string-selector)&#123;</span><br><span class="line">  <span class="keyword">case</span> int1/string1: statement; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> int2/string2: statement; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> int3/string3: statement; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>switch</code>体中, <code>default</code>可以省略.
如果缺少<code>break</code>, <code>switch</code>将会发生穿透.
示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span>(x)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 1&quot;</span>).</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 2&quot;</span>).</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 3&quot;</span>).</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;case 4&quot;</span>).</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>).</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其结果如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case 2</span><br><span class="line">case 3</span><br><span class="line">case 4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记-OnJava8</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch1 引论</title>
    <url>/Course-Compiler-1/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch01
Introduction.</strong></p>
<span id="more"></span>
<h2 id="课程信息">课程信息</h2>
<p>NJU许畅老师(<a
href="https://cs.nju.edu.cn/changxu">主页</a>)开设的编译原理课程(<strong>Principles
and Techniques of Compilers</strong>).</p>
<blockquote>
<p><strong>Additonal:</strong></p>
<p>NJU谭添老师(<a
href="https://cs.nju.edu.cn/tiantan/courses/compiler-2025/index.html">主页</a>)开设的同名课程.</p>
</blockquote>
<p><strong>参考教材:</strong></p>
<p>《编译原理》(龙书),《编译方法、技术与实践》/《编译原理实践与指导教程》</p>
<h3 id="课程内容">课程内容</h3>
<ul>
<li><a href="https://la-pluma.github.io/Course-Compiler-1"><strong>Ch1
引论</strong></a></li>
<li><a href="https://la-pluma.github.io/Course-Compiler-3"><strong>Ch3
词法分析</strong></a></li>
<li><a href="https://la-pluma.github.io/Course-Compiler-4"><strong>Ch4
语法分析</strong></a></li>
<li><a href="https://la-pluma.github.io/Course-Compiler-5"><strong>Ch5
语法制导的编译技术</strong></a></li>
<li><a href="https://la-pluma.github.io/Course-Compiler-6"><strong>Ch6
中间代码生成</strong></a></li>
<li><a href="https://la-pluma.github.io/Course-Compiler-7"><strong>Ch7
运行时刻环境</strong></a></li>
<li><a href="https://la-pluma.github.io/Course-Compiler-8"><strong>Ch8
代码生成</strong></a></li>
<li><a href="https://la-pluma.github.io/Course-Compiler-9"><strong>Ch9
机器无关优化</strong></a></li>
</ul>
<h3 id="实验内容">实验内容</h3>
<p>因为笔者自身能力有限, 故而不卖弄浅薄的理解,
本课程暂无设置实验记录的想法.</p>
<blockquote>
<p>Tips: 在将来可能会公开一份参考实现,
但实现本身并不优秀且得分并不理想</p>
</blockquote>
<h2 id="引论">引论</h2>
<h3 id="编译器compiler-解释器interpreter">编译器(Compiler) &amp;
解释器(Interpreter)</h3>
<ul>
<li><strong>编译器</strong>
<ul>
<li>读入以某种语言(源语言) 编写的程序</li>
<li>输出等价的用另一种语言(目标语言) 编写的程序</li>
<li>通常目标程序是可执行的</li>
</ul></li>
</ul>
<img src="/Course-Compiler-1/pic1-1.png" class="" title="pic1-1">
<ul>
<li><strong>解释器</strong>
<ul>
<li>直接利用用户提供的输入，执行源程序中指定的操作</li>
<li>不生成目标程序，而是根据源程序的语义直接运行</li>
<li>Java语言的处理结合了编译和解释</li>
</ul></li>
</ul>
<h3 id="编译器的结构">编译器的结构</h3>
<p>编译器可以分为<strong>分析</strong>和<strong>综合</strong>两部分.</p>
<ul>
<li><strong>分析(Analysis)/前端(front end)</strong>
<ul>
<li>把源程序分解成组成要素，以及相应的语法结构</li>
<li>使用这个结构创建源程序的中间表示</li>
<li>同时收集和源程序相关的信息，存放到符号表</li>
</ul></li>
<li><strong>综合(Synthesis)/后端(back end)</strong>
<ul>
<li>根据中间表示和符号表信息构造目标程序</li>
</ul></li>
</ul>
<blockquote>
<p><strong>其中前端部分是机器无关的，后端部分是机器相关的</strong></p>
</blockquote>
<p>编译器执行步骤(phase)</p>
<img src="/Course-Compiler-1/pic1-2.png" class="" title="pic1-2">
<h3 id="词法分析">词法分析</h3>
<ul>
<li><strong>词法分析/扫描(lexical analysis/scanning)</strong>
<ul>
<li>读入源程序的字符流，输出为有意义的词素(lexeme)</li>
<li>格式: <code>&lt;token-name, attribute-value&gt;</code></li>
<li>token-name由语法分析步骤使用</li>
<li>attribute-value指向相应的符号表条目，由语义分析/代码生成步骤使用</li>
</ul>
<blockquote>
<p><strong>Example:</strong> <img src="/Course-Compiler-1/pic1-3.png" class="" title="pic1-3"></p>
</blockquote></li>
</ul>
<h3 id="语法分析">语法分析</h3>
<ul>
<li><strong>语法分析/解析(syntax analysis/parsing)</strong>
<ul>
<li>根据各个词法单元的第一个分量来创建树型的中间表示形式，通常是<strong>语法树(syntax
tree)</strong></li>
<li>中间表示形式指出了词法单元流的语法结构</li>
<li><img src="/Course-Compiler-1/pic1-4.png" class="" title="pic1-4"></li>
</ul></li>
</ul>
<h3 id="语义分析">语义分析</h3>
<ul>
<li><strong>语义分析(semantic analysis)</strong>
<ul>
<li>使用语法树和符号表中的信息，检查源程序是否满足语言定义的语义约束</li>
<li>同时收集类型信息，用于代码生成、类型检查、类型转换</li>
<li><img src="/Course-Compiler-1/pic1-5.png" class="" title="pic1-5"></li>
</ul></li>
</ul>
<h3 id="中间代码生成">中间代码生成</h3>
<p>根据语义分析输出，生成类机器语言的中间表示</p>
<ul>
<li><strong>三地址代码(three-address code)</strong>
<ul>
<li>每个指令最多包含三个运算分量</li>
<li>Example:
<code>t1 = inttofloat(60); t2 = id3 * t1; t3 = id2 + t2;</code></li>
<li>很容易生成机器语言指令</li>
<li><img src="/Course-Compiler-1/pic1-6.png" class="" title="pic1-6"></li>
</ul></li>
</ul>
<h3 id="中间代码优化">中间代码优化</h3>
<p>通过对中间代码的分析，改进中间代码的质量(更快、更短、能耗更低)</p>
<img src="/Course-Compiler-1/pic1-7.png" class="" title="pic1-7">
<h3 id="代码生成">代码生成</h3>
<p>把中间表示形式映射到目标语言(寄存器分配与指令选择)</p>
<img src="/Course-Compiler-1/pic1-8.png" class="" title="pic1-8">
<h3 id="语言与编译器的关系">语言与编译器的关系</h3>
<ul>
<li>程序设计语言的新发展向编译器设计者提出新的要求
<ul>
<li>设计相应的算法和表示方法来翻译和支持新的语言特征，如多态、动态绑定、类、类属(模板)
、…</li>
</ul></li>
<li>通过降低高级语言的执行开销，推动这些高级语言的使用</li>
<li>编译器设计者还需要更好地利用新硬件的能力
<ul>
<li>RISC技术、多核技术、大规模并行技术</li>
</ul></li>
</ul>
<h3 id="程序设计语言的基础概念">程序设计语言的基础概念</h3>
<h4 id="动态静态">动态&amp;静态</h4>
<ul>
<li><strong>静态:</strong> 支持编译器静态决定某个问题</li>
<li><strong>动态:</strong> 只允许在程序运行时刻作出决定</li>
</ul>
<h4 id="作用域">作用域</h4>
<p>x的作用域指程序文本的一个区域，其中对x的使用都指向这个声明</p>
<ul>
<li><strong>静态作用域(static scope):</strong>
通过静态阅读程序可决定</li>
<li><strong>动态作用域(dynamic scope):</strong> 运行时确定x的指向</li>
</ul>
<h4 id="环境状态">环境&amp;状态</h4>
<ul>
<li><strong>环境(environment):</strong> 是从名字到存储位置的映射</li>
<li><strong>状态(state):</strong> 从存储位置到它们值的映射</li>
</ul>
<img src="/Course-Compiler-1/pic1-9.png" class="" title="pic1-9">
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch3 词法分析</title>
    <url>/Course-Compiler-3/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch03
Lexical Analysis.</strong></p>
<span id="more"></span>
<h2 id="词法分析器的作用">词法分析器的作用</h2>
<ul>
<li>读入字符流，组成词素，输出<strong>词法单元</strong>序列</li>
<li>过滤空白、换行、制表符、注释等</li>
<li>将词素添加到符号表中</li>
<li>在逻辑上独立于语法分析，但是通常和语法分析器处于同一趟(pass)中</li>
</ul>
<img src="/Course-Compiler-3/pic3-1.png" class="" title="pic3-1">
<h3 id="独立词法分析器设置原因">独立词法分析器设置原因</h3>
<ul>
<li>简化编译器的设计
<ul>
<li>词法分析器可以首先完成一些简单的处理工作</li>
</ul></li>
<li>提高编译器效率
<ul>
<li>相对于语法分析，词法分析过程简单，可高效实现(<strong>下推自动机PDA</strong>&amp;<strong>有穷自动机DFA</strong>)</li>
</ul></li>
<li>增强编译器的可移植性</li>
</ul>
<h2 id="名词定义符号规约">名词定义&amp;符号规约</h2>
<blockquote>
<p><strong>Tips:</strong>
该部分涉及大量<strong>形式语言与自动机(FLA)</strong>的内容,
笔者在此给出一个参考笔记<a
href="https://fla.cuijiacai.com/"><strong>[崔家才|形式语言与自动机]</strong></a></p>
</blockquote>
<h3 id="名词定义">名词定义</h3>
<ul>
<li><strong>词法单元(token)</strong>
<ul>
<li><code>&lt;词法单元名, 属性值(可选) &gt;</code></li>
<li>单元名是表示词法单位种类的抽象符号，语法分析器通过单元名即可确定词法单元序列的结构</li>
<li>属性值通常用于语义分析之后的阶段</li>
</ul></li>
<li><strong>模式(pattern)</strong>
<ul>
<li>描述了一类词法单元的词素可能具有的形式</li>
</ul></li>
<li><strong>词素(lexeme)</strong>
<ul>
<li>源程序中的字符序列</li>
<li>它和某个词法单元的模式匹配，被词法分析器识别为该词法单元的实例</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Additional:</strong></p>
<img src="/Course-Compiler-3/pic3-2.png" class="" title="pic3-2">
<p>上面的定义稍显晦涩, 不妨结合例子来看.</p>
<p>不恰当的比喻来说, 词法单元是<strong>类型名</strong>,
模式是<strong>类型特征</strong>, 词素是<strong>具体实例</strong>.
即<code>猫 : 头顶有耳朵, 有尾巴的四足覆毛生物(非严谨) : 布偶猫</code>.</p>
</blockquote>
<h4 id="词法单元的属性">词法单元的属性</h4>
<ul>
<li>一个模式匹配多个词素时，必须通过属性来传递附加的信息
<ul>
<li>属性值将被用于语义分析、代码生成等阶段</li>
</ul></li>
<li>不同的目的需要不同的属性
<ul>
<li>属性值通常是一个结构化数据</li>
</ul></li>
<li>如词法单元id的属性
<ul>
<li>词素、类型、第一次出现的位置</li>
</ul></li>
</ul>
<h3 id="符号规约">符号规约</h3>
<blockquote>
<p><strong>Tips:</strong> 由于本部分内容基本已在FLA中学习过,
故此处笔者仅作最基本的符号规约和定义陈述.</p>
</blockquote>
<h4 id="串string和语言language">串(string)和语言(language)</h4>
<ul>
<li><p><strong>字母表(Alphabet):</strong> 一个有穷的符号集合<span
class="math inline">\(\Sigma\)</span></p></li>
<li><p><strong>串(String):</strong> 字母表中符号的有穷序列<span
class="math inline">\(s\)</span></p>
<ul>
<li><span class="math inline">\(|s|\)</span>, 串长</li>
<li><span class="math inline">\(\epsilon\)</span>, 空串</li>
</ul></li>
<li><p><strong>语言(language):</strong>
是某个给定字母表上的串的可数集合</p></li>
<li><p><strong>前缀(prefix)/后缀(suffix):</strong>
从串的尾部/头部删除0个或多个符号后得到的串</p></li>
<li><p><strong>子串(substring):</strong>
删除串的某个前缀和某个后缀得到的串</p></li>
<li><p><strong>子序列:</strong>
从原串中删除0个或者多个符号后得到的串</p></li>
<li><p><strong>真前缀, 真后缀, 真子串:</strong> 既不等于原串,
也不等于空串的前缀, 后缀, 子串</p></li>
<li><p><strong>串的运算</strong></p>
<blockquote>
<img src="/Course-Compiler-3/pic3-3.png" class="" title="pic3-3">
<p>其中<span class="math inline">\(\lambda\)</span>和<span
class="math inline">\(\epsilon\)</span>均表示空串</p>
</blockquote></li>
<li><p><strong>字母表的运算</strong></p>
<blockquote>
<img src="/Course-Compiler-3/pic3-4.png" class="" title="pic3-4">
</blockquote></li>
<li><p><strong>语言的运算</strong></p>
<blockquote>
<img src="/Course-Compiler-3/pic3-5.png" class="" title="pic3-5">
</blockquote></li>
</ul>
<h4 id="正则表达式re">正则表达式(RE)</h4>
<p><strong>归纳奠基:</strong></p>
<ul>
<li><span class="math inline">\(\epsilon\)</span>是一个正则表达式, <span
class="math inline">\(L(\epsilon) = \{\epsilon\}\)</span></li>
<li>如果<span class="math inline">\(a\)</span>是<span
class="math inline">\(\Sigma\)</span>上的一个符号，那么<span
class="math inline">\(a\)</span>是正则表达式, <span
class="math inline">\(L(a) = \{a\}\)</span></li>
</ul>
<p><strong>归纳递推:</strong></p>
<ul>
<li><strong>选择(或):</strong> <span class="math inline">\(r|s,
L(r|s)=L(r)\cup L(s)\)</span></li>
<li><strong>连接(拼接):</strong> <span class="math inline">\(rs,
L(rs)=L(r)L(s)\)</span></li>
<li><strong>闭包:</strong> <span class="math inline">\(r^*,
L(r^*)=L^*(r)\)</span></li>
</ul>
<blockquote>
<p><strong>正则表达式的扩展运算:</strong></p>
<img src="/Course-Compiler-3/pic3-6.png" class="" title="pic3-6">
</blockquote>
<h4 id="dfanfa">DFA&amp;NFA</h4>
<p>详见<a
href="https://fla.cuijiacai.com/02-fa/"><strong>崔家才|有穷自动机</strong></a></p>
<p>内容包括</p>
<ul>
<li>DFA&amp;NFA的定义</li>
<li>DFA&lt;-&gt;NFA的转化
<ul>
<li><a
href="https://blog.csdn.net/weixin_43655282/article/details/108963761"><strong>CSDN|NFA-&gt;DFA</strong></a></li>
</ul></li>
<li>DFA最小化算法
<ul>
<li><a
href="https://zhuanlan.zhihu.com/p/31166841"><strong>知乎|Hopcroft
算法</strong></a></li>
</ul></li>
</ul>
<h3 id="词法单元的规约">词法单元的规约</h3>
<p><strong>正则表达式</strong>可以高效、简洁地描述处理词法单元时用到的模式类型</p>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-3/pic3-7.png" class="" title="pic3-7">
</blockquote>
<h3 id="词法单元的识别">词法单元的识别</h3>
<ul>
<li>词法分析器要求能够检查输入字符串，在其前缀中找出和某个模式匹配的词素</li>
<li>首先通过正则定义来描述各种词法单元的模式</li>
<li>定义<span class="math inline">\(ws \rightarrow(blank | tab |
newline)^+\)</span>来消除空白
<ul>
<li>当词法分析器识别出这个模式时，不返回词法单元，继续识别其它模式</li>
</ul></li>
</ul>
<img src="/Course-Compiler-3/pic3-8.png" class="" title="pic3-8">
<h4 id="状态转移图transition-diagram">状态转移图(transition
diagram)</h4>
<p>词法分析器最重要的组件之一.</p>
<ul>
<li><strong>状态(state):</strong> 表示在识别词素时可能出现的情况
<ul>
<li>状态看作是已处理部分的总结</li>
<li>某些状态为接受状态或最终状态，表明已找到词素</li>
<li>加上*的接受状态表示最后读入的符号不在词素中</li>
<li>开始状态(初始状态)：用Start边表示</li>
</ul></li>
<li><strong>边(edge):</strong> 从一个状态指向另一个状态.
<ul>
<li>边的标号是一个或多个符号</li>
<li>当前状态为s，下一个输入符号为a，就沿着从s离开，标号为a的边到达下一个状态</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-3/pic3-9.png" class="" title="pic3-9">
</blockquote>
<h3 id="词法分析器的体系结构">词法分析器的体系结构</h3>
<ul>
<li>从转换图构造词法分析器的方法
<ul>
<li>变量state记录当前状态</li>
<li>一个switch语句根据state的值转到相应的代码</li>
<li>每个状态对应于一段代码
<ul>
<li>这段代码根据读入的符号，确定下一个状态</li>
<li>如果找不到相应的边，则调用<code>fail()</code>进行错误恢复</li>
</ul></li>
<li>进入某个接受状态时，返回相应的词法单元
<ul>
<li>注意状态有*标记时，需要回退forward指针</li>
</ul></li>
</ul></li>
<li>实际是模拟转换图的运行</li>
</ul>
<h4 id="处理多个模式的方法">处理多个模式的方法</h4>
<ul>
<li>按照优先级，顺序地尝试各个状态转换图，如果引发<code>fail()</code>，回退并尝试下一个状态图</li>
<li>更好的方法：并行地运行各个状态转换图；通过greedy策略，识别最长的与某个模式匹配的输入前缀</li>
<li>实际使用的方法：预先把各个状态转换图合成一个状态转换图，然后运行这个状态转换图</li>
</ul>
<h3 id="词法分析工具lexflex">词法分析工具Lex/Flex</h3>
<h4 id="lex源程序的结构">Lex源程序的结构</h4>
<ul>
<li><strong>声明部分</strong>
<ul>
<li>常量：表示常数的标识符</li>
<li>正则定义</li>
</ul></li>
<li><strong>转换规则:</strong> <code>模式&#123; 动作 &#125;</code>
<ul>
<li>模式是正则表达式</li>
<li>动作表示识别到相应模式时应采取的处理方式</li>
<li>处理方式通常用是C语言代码表示</li>
</ul></li>
<li><strong>辅助函数</strong>
<ul>
<li>各个动作中使用的函数</li>
</ul></li>
</ul>
<img src="/Course-Compiler-3/pic3-10.png" class="" title="pic3-10">
<blockquote>
<p>例子详见ppt: <a
href="https://cs.nju.edu.cn/changxu/2_compiler/slides/Chapter_3.pdf#page=35"><strong>传送链接</strong></a></p>
</blockquote>
<h4 id="词法分析器的工作方式">词法分析器的工作方式</h4>
<ul>
<li>Lex生成的词法分析器作为一个函数被调用</li>
<li>在每次调用过程中，不断读入余下的输入符号</li>
<li>发现最长的、与某个模式匹配的输入前缀时
<ul>
<li>调用相应的动作，该动作进行相关处理</li>
<li>之后词法分析器继续寻找其它词素</li>
</ul></li>
</ul>
<h4 id="lex中的冲突解决方法">Lex中的冲突解决方法</h4>
<img src="/Course-Compiler-3/pic3-11.png" class="" title="pic3-11">
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch6 中间代码生成</title>
    <url>/Course-Compiler-6/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch06
Intermediate Code Generation.</strong></p>
<span id="more"></span>
<h2 id="编译器前端的逻辑结构">编译器前端的逻辑结构</h2>
<ul>
<li>前端是对源语言进行分析并产生中间表示</li>
<li>处理与源语言相关的细节，与目标机器无关</li>
<li>前端后端分开的好处：不同的源语言、不同的机器可以得到不同的编译器组合(<code>m * n</code>)</li>
</ul>
<img src="/Course-Compiler-6/pic6-1.png" class="" title="pic6-1">
<h2 id="中间代码表示">中间代码表示</h2>
<ul>
<li><strong>形式</strong>
<ul>
<li>多种中间表示，不同层次</li>
<li>抽象语法树, 三地址代码</li>
</ul></li>
<li><strong>重定位</strong>
<ul>
<li>为新的机器建编译器，只需要做从中间代码到新的目标代码的翻译器<strong>(前端独立)</strong></li>
</ul></li>
<li><strong>高层次的优化</strong>
<ul>
<li>优化与源语言和目标机器都无关</li>
</ul></li>
</ul>
<h3 id="中间代码的实现">中间代码的实现</h3>
<ul>
<li><strong>静态类型检查</strong>和<strong>中间代码生成</strong>的过程都可以用语法制导的翻译来描述和实现</li>
</ul>
<h4 id="生成抽象语法树的语法制导定义">生成抽象语法树的语法制导定义</h4>
<img src="/Course-Compiler-6/pic6-2.png" class="" title="pic6-2">
<h4 id="表达式的有向无环图">表达式的有向无环图</h4>
<ul>
<li>语法树中，公共子表达式每出现一次，就有一颗对应的子树</li>
<li>表达式的<strong>有向无环图(Directed Acyclic Graph,
DAG)</strong>能够指出表达式中的公共子表达式，更简洁地表示表达式</li>
</ul>
<h5 id="dag构造">DAG构造</h5>
<ul>
<li>可以用和构造抽象语法树一样的SDD来构造</li>
<li><strong>不同的处理:</strong>
在函数Leaf和Node每次被调用时，构造新节点前先检查是否存在同样的结点(值编码+散列表)，如果已存在，则返回这个已有结点</li>
</ul>
<img src="/Course-Compiler-6/pic6-3.png" class="" title="pic6-3">
<h2 id="三地址代码">三地址代码</h2>
<ul>
<li>每条指令右侧最多有一个运算符
<ul>
<li>一般情况可以写成<code>x = y op z</code></li>
</ul></li>
<li>允许的<strong>运算分量</strong>(地址)
<ul>
<li>名字：源程序中的变量名字作为三地址代码的地址</li>
<li>常量：源程序中出现或生成的常量</li>
<li>编译器生成的临时变量</li>
</ul></li>
</ul>
<h3 id="指令集合">指令集合</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算/赋值指令</td>
<td><code>x = y op z</code> / <code>x = op y</code></td>
</tr>
<tr>
<td>复制指令</td>
<td><code>x = y</code></td>
</tr>
<tr>
<td>无条件转移指令</td>
<td><code>goto L</code></td>
</tr>
<tr>
<td>条件转移指令</td>
<td><code>if x goto L</code> <code>if False x goto L</code>
<code>if x relop y goto L</code></td>
</tr>
<tr>
<td>过程调用/返回</td>
<td><code>param x1 \\设置参数</code><br><code>param x2</code><br><code>...</code><br><code>param xn</code><br><code>call p, n \\调用过程p,n为参数个数(可能嵌套调用)</code></td>
</tr>
<tr>
<td>带下标的复制指令</td>
<td><code>x= y[i]</code> <code>x[i] = y</code>
<code>\\i表示距离数组位置i个内存单元(字节),不是数组的第i个元素</code></td>
</tr>
<tr>
<td>地址/指针赋值指令</td>
<td><code>x = &amp;y</code> <code>x = *y</code> <code>*x = y</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-6/pic6-4.png" class="" title="pic6-4">
</blockquote>
<h3 id="三地址码表示">三地址码表示</h3>
<ul>
<li>在实现时，可使用<strong>四元式/三元式/间接三元式/静态单赋值</strong>来表示三地址指令</li>
</ul>
<h4 id="四元式表示">四元式表示</h4>
<ul>
<li><strong>四元式(quadruple):</strong> 可以实现为记录(或结构)
<ul>
<li>格式(字段): <code>op arg1 arg2 result</code></li>
<li>op：运算符的内部编码</li>
<li>arg1, arg2, result是地址</li>
<li><strong>Example:</strong> <code>x = y + z -&gt; + y z x</code></li>
</ul></li>
<li>单目运算符不使用arg2</li>
<li>param运算不使用arg2和result</li>
<li>条件/非条件转移将目标标号放在result字段</li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-6/pic6-5.png" class="" title="pic6-5">
</blockquote>
<h4 id="三元式表示">三元式表示</h4>
<ul>
<li><p><strong>三元式(triple):</strong>
<code>op arg1 arg2</code></p></li>
<li><p>使用三元式的位置来引用三元式的运算结果</p></li>
<li><p>优化时经常需要移动/删除/添加三元式，导致三元式运算结果的位置变化(四元式无此问题)</p></li>
<li><p><code>x = y op z</code>转化为<code>? op y z</code>
<code>= x (?)</code>, 其中<code>?</code>为位置</p></li>
<li><p><code>x[i] = y</code>需要拆分为两个三元式,
求<code>x[i]</code>的地址，然后再赋值</p>
<blockquote>
<table>
<thead>
<tr>
<th>exp</th>
<th>op</th>
<th>arg1</th>
<th>arg2</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x[i] = y</code></td>
<td><code>[]=</code></td>
<td><code>i</code></td>
<td><code>y</code></td>
<td><code>x</code></td>
</tr>
<tr>
<td><code>y = x[i]</code></td>
<td><code>=[]</code></td>
<td><code>x</code></td>
<td><code>i</code></td>
<td><code>y</code></td>
</tr>
</tbody>
</table>
</blockquote></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-6/pic6-6.png" class="" title="pic6-6">
</blockquote>
<h4 id="间接三元式表示">间接三元式表示</h4>
<ul>
<li><strong>间接三元式(indirect triple):</strong>
包含了一个指向三元式的指针的列表</li>
<li>可对该列表进行操作(重新排序)，完成优化功能，操作时不影响三元式本身</li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<p><code>a = b * -c + b * -c</code></p>
<img src="/Course-Compiler-6/pic6-7.png" class="" title="pic6-7">
</blockquote>
<h4 id="静态单赋值形式">静态单赋值形式</h4>
<img src="/Course-Compiler-6/pic6-8.png" class="" title="pic6-8">
<h5 id="ssa的构造">SSA的构造</h5>
<ul>
<li>为每个变量维护一个计数器</li>
<li>从函数入口开始遍历函数体</li>
<li>遇到变量赋值时，为其生成新名字，并替换</li>
<li>将新变量名传播到后续相应的使用处，并替换</li>
</ul>
<blockquote>
<p><strong>Tips:</strong> 通常只针对函数内的变量(即局部变量) 计算SSA,
而全局变量的SSA在实际当中难以计算</p>
</blockquote>
<h5 id="ssa对分支的处理">SSA对分支的处理</h5>
<img src="/Course-Compiler-6/pic6-24.png" class="" title="pic6-24">
<h5 id="ssa对循环的处理">SSA对循环的处理</h5>
<img src="/Course-Compiler-6/pic6-25.png" class="" title="pic6-25">
<h5 id="ssa的作用">SSA的作用</h5>
<ul>
<li>每个变量只被赋值一次，相当于都变成const变量</li>
<li>简化了数据流分析和某些优化</li>
<li>使得定义-使用链(def-use chain)易于计算
<ul>
<li>关联每个变量的定义(赋值)及其相应的使用</li>
<li>许多分析和优化所需的关键信息</li>
<li>SSA形式中，定义-使用关系非常清晰，且可以线性复杂度进行计算</li>
</ul></li>
</ul>
<img src="/Course-Compiler-6/pic6-26.png" class="" title="pic6-26">
<img src="/Course-Compiler-6/pic6-27.png" class="" title="pic6-27">
<h2 id="类型和声明">类型和声明</h2>
<ul>
<li><strong>类型检查(type checking)</strong>
<ul>
<li>利用一组规则来检查运算分量的类型和运算符的预期类型是否匹配</li>
</ul></li>
<li>类型信息的用途
<ul>
<li>查错、确定名字需要的内存空间、计算数组元素的地址、类型转换、选择正确的运算符</li>
</ul></li>
</ul>
<h3 id="类型分类">类型分类</h3>
<ul>
<li><strong>基本类型</strong>
<ul>
<li>程序设计语言中的原子类型
<ul>
<li>如: <code>boolean, char, integer, float, void, ...</code></li>
</ul></li>
<li>通常这些类型的运算都有对应的机器指令</li>
</ul></li>
<li><strong>复合类型</strong>
<ul>
<li>由基本类型或其它复合组合而成的类型，为程序设计语言提供更强的抽象和表达能力
<ul>
<li>如: 结构体, 数组, 函数, ...</li>
</ul></li>
</ul></li>
<li><strong>类型表达式(Typeexpression):</strong> 表示类型的表达式
<ul>
<li>基本类型：类型名字</li>
<li>复合类型：通过类型构造算子作用于类型表达式得到</li>
</ul></li>
</ul>
<h4 id="数组类型">数组类型</h4>
<ul>
<li>表示同类型数据的聚合</li>
<li>类型构造算子array，有两个参数
<ul>
<li>数字：表示数组的长度</li>
<li>类型：表示数组元素的类型</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong> <code>int [2][3]</code></p>
<p>对应类型表达式<code>array(2, array(3, integer))</code></p>
</blockquote>
<h4 id="记录类型">记录类型</h4>
<ul>
<li>表示不同类型数据的聚合(结构体、类)</li>
<li>类型构造算子record，有多组字段
<ul>
<li>字段名：字段名字，可用于在记录中引用该字段</li>
<li>类型：字段对应数据的类型</li>
</ul></li>
<li>记录的基本构造算子是笛卡尔积<code>×</code>
<ul>
<li>如果<code>s</code>,
<code>t</code>是类型表达式，其笛卡尔积<code>s × t</code>也是类型表达式</li>
<li>在记录类型的构造中起组合作用
<ul>
<li>组合字段名与相应类型</li>
<li>组合多组字段</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong>
<code>struct&#123;int a[10]; float f;&#125; st;</code></p>
<p>对应类型表达式<code>record((a × array(10, int)) × (f × float))</code></p>
</blockquote>
<h4 id="函数类型">函数类型</h4>
<ul>
<li>表示程序中函数的类型</li>
<li>类型构造算子<span
class="math inline">\(\rightarrow\)</span>，接收参数类型与返回值类型，并构造出函数类型</li>
</ul>
<blockquote>
<p><strong>Example:</strong>
<code>int foo(float x, long[5] y) &#123;...&#125;</code></p>
<p>对应类型表达式<code>(float × array(5, long)) -&gt; int</code></p>
</blockquote>
<h3 id="类型等价">类型等价</h3>
<ul>
<li>不同的语言有不同的类型等价的定义</li>
<li><strong>名等价(name equivalence)</strong>
<ul>
<li>类型表达式t与u等价当且仅当它们对应的类型名字相同</li>
</ul></li>
<li><strong>结构等价(structurally equivalent)</strong>
<ul>
<li>对于基本类型，比较它们名字是否相同</li>
<li>对于复合类型，比较类型构造算子; 若相同,
递归比较构造算子的各参数分量</li>
</ul></li>
</ul>
<h3 id="类型的声明">类型的声明</h3>
<ul>
<li>处理基本类型、数组类型或记录类型的文法
<ul>
<li><img src="/Course-Compiler-6/pic6-9.png" class="" title="pic6-9"></li>
</ul></li>
<li>应用该文法及其对应的语法制导定义，除了得到<strong>类型表达式</strong>之外，还得进行各种类型的<strong>存储布局</strong></li>
</ul>
<h4 id="局部变量的存储布局">局部变量的存储布局</h4>
<ul>
<li>变量的类型可以确定变量需要的内存
<ul>
<li>即类型的宽度(该类型一个对象所需的存储单元的数量)</li>
<li>可变大小的数据结构(如动态数组)只需要考虑指针</li>
<li>特殊：对齐(aligned)、补白(padding)、压缩(pack)</li>
</ul></li>
<li>函数的局部变量总是分配在连续的区间
<ul>
<li>因此给每个变量分配一个相对于这个区间开始处的相对地址</li>
</ul></li>
<li>变量的类型信息保存在符号表中</li>
</ul>
<h5 id="内存补齐padding">内存补齐(Padding)</h5>
<ul>
<li>提升内存访问效率的一种技术</li>
<li>内存（通常）不能“跨行”访问</li>
</ul>
<img src="/Course-Compiler-6/pic6-28.png" class="" title="pic6-28">
<img src="/Course-Compiler-6/pic6-29.png" class="" title="pic6-29">
<h3 id="表达式翻译">表达式翻译</h3>
<h4 id="计算t的类型和宽度的sdt">计算T的类型和宽度的SDT</h4>
<img src="/Course-Compiler-6/pic6-10.png" class="" title="pic6-10">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-6/pic6-11.png" class="" title="pic6-11">
</blockquote>
<h4 id="声明序列的sdt">声明序列的SDT</h4>
<ul>
<li>在处理一个过程/函数时，局部变量应该放到单独的符号表中去</li>
<li>这些变量的内存布局独立
<ul>
<li>相对地址从0开始，变量的放置和声明的顺序相同</li>
</ul></li>
<li>SDT的处理方法
<ul>
<li>变量offset记录当前可用的相对地址</li>
<li>每分配一个变量，offset增加相应的值(加宽度)</li>
</ul></li>
<li><span class="math inline">\(top.put(id.lexeme, T.type,
offset)\)</span>
<ul>
<li>在符号表中创建条目，记录标识符的类型和偏移量</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-6/pic6-12.png" class="" title="pic6-12">
<img src="/Course-Compiler-6/pic6-30.png" class="" title="pic6-30">
</blockquote>
<h4 id="记录和类中的字段">记录和类中的字段</h4>
<ul>
<li>记录变量声明的翻译方案</li>
<li>约定
<ul>
<li>一个记录中各个字段的名字必须互不相同</li>
<li>字段名的偏移量(相对地址)，是相对于该记录的数据区字段而言的</li>
</ul></li>
<li>记录类型使用一个<strong>专用的符号表</strong>，对其各个字段的类型和相对地址进行编码</li>
<li>记录类型<span
class="math inline">\(record(t):record\)</span>是类型构造算子, <span
class="math inline">\(t\)</span>是符号表对象，保存该记录类型各个字段的信息</li>
</ul>
<img src="/Course-Compiler-6/pic6-13.png" class="" title="pic6-13">
<h5 id="env环境">Env环境</h5>
<ul>
<li>当程序中的作用域发生嵌套时，用一个栈Env辅助维护各作用域对应的符号表，栈中存储指向各符号表的指针</li>
<li>进入一个新作用域时，保存上一作用域(压栈)</li>
<li>从一个作用域退出时，恢复上一作用域(出栈)</li>
</ul>
<img src="/Course-Compiler-6/pic6-31.png" class="" title="pic6-31">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-6/pic6-32.png" class="" title="pic6-32">
</blockquote>
<h4 id="表达式代码的sdd">表达式代码的SDD</h4>
<img src="/Course-Compiler-6/pic6-14.png" class="" title="pic6-14">
<h4 id="增量式翻译方案">增量式翻译方案</h4>
<img src="/Course-Compiler-6/pic6-15.png" class="" title="pic6-15">
<h4 id="数组元素的寻址">数组元素的寻址</h4>
<ul>
<li>假设数组元素被存放在连续的存储空间中, 元素从<span
class="math inline">\(0\)</span>到<span
class="math inline">\(n−1\)</span>编号, 第<span
class="math inline">\(i\)</span> 个元素的地址为: <span
class="math inline">\(base + i * w\)</span></li>
<li>k维数组的寻址: 假设数组按行存放, 首先存放<span
class="math inline">\(A[0][i_2]...[i_k]\)</span>, 然后 存放<span
class="math inline">\(A[1][i_2]...[i_k]\)</span>, ...那么<span
class="math inline">\(A[i_1][i_2]...[i_k]\)</span>的地址为
<ul>
<li><span class="math inline">\(base + i_1 * w_1 + i_2 * w_2 + ... + i_k
* w_k\)</span></li>
</ul></li>
</ul>
<h5 id="数组引用的翻译">数组引用的翻译</h5>
<ul>
<li>为数组引用生成代码要解决的主要问题
<ul>
<li>数组引用的文法和地址计算相关联</li>
</ul></li>
<li>假定数组编号从0开始，基于宽度来计算相对地址</li>
<li>数组引用相关文法
<ul>
<li>非终结符号L生成数组名，加上一个下标表达式序列</li>
<li><span class="math inline">\(L \rightarrow [L]\ |\ id\
[E]\)</span></li>
</ul></li>
</ul>
<h5 id="数组引用生成代码的翻译方案">数组引用生成代码的翻译方案</h5>
<img src="/Course-Compiler-6/pic6-16.png" class="" title="pic6-16">
<img src="/Course-Compiler-6/pic6-17.png" class="" title="pic6-17">
<img src="/Course-Compiler-6/pic6-18.png" class="" title="pic6-18">
<img src="/Course-Compiler-6/pic6-19.png" class="" title="pic6-19">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-6/pic6-20.png" class="" title="pic6-20">
</blockquote>
<h2 id="类型检查和转换">类型检查和转换</h2>
<ul>
<li><strong>类型系统(type system)</strong>
<ul>
<li>给每一个组成部分赋予一个类型表达式</li>
<li>通过一组逻辑规则来表达类型表达式必须满足的条件</li>
<li>可发现错误、提高代码效率、确定临时变量的大小</li>
</ul></li>
<li>类型检查可以分为动态和静态两种</li>
<li>如果编译器中的类型系统能够保证它接受的程序在运行时刻不会发生类型错误，则该语言的这种实现称为<strong>强类型</strong>的</li>
</ul>
<blockquote>
<p><strong>Addtional:</strong></p>
<p>也有说法按照类型系统严格性进行强弱区分，如C/C++允许通过指针操作绕过常规类型检查，因此被认为是<strong>弱类型语言</strong></p>
</blockquote>
<h3 id="类型系统的分类">类型系统的分类</h3>
<ul>
<li><strong>类型综合(type synthesis)</strong>
<ul>
<li>根据子表达式的类型构造出表达式的类型</li>
<li>如果<code>f</code>的类型为<code>s-&gt;t</code>且<code>x</code>的类型为<code>s</code>,
则<code>f(x)</code>的类型为<code>t</code></li>
</ul></li>
<li><strong>类型推导(type inference)</strong>
<ul>
<li>根据语言结构的使用方式来确定该结构的类型</li>
<li>如果<code>f(x)</code>是一个表达式,
则对于某些类型<code>α</code>和<code>β</code>,
<code>f</code>的类型为<code>α-&gt;β</code>且<code>x</code>的类型为<code>α</code></li>
</ul></li>
</ul>
<h3 id="类型规则">类型规则</h3>
<img src="/Course-Compiler-6/pic6-33.png" class="" title="pic6-33">
<img src="/Course-Compiler-6/pic6-34.png" class="" title="pic6-34">
<h4 id="函数运算符重载">函数/运算符重载</h4>
<img src="/Course-Compiler-6/pic6-35.png" class="" title="pic6-35">
<h3 id="类型转换">类型转换</h3>
<img src="/Course-Compiler-6/pic6-21.png" class="" title="pic6-21">
<h4 id="类型转换规则">类型转换规则</h4>
<img src="/Course-Compiler-6/pic6-22.png" class="" title="pic6-22">
<h4 id="处理类型转换的sdt">处理类型转换的SDT</h4>
<img src="/Course-Compiler-6/pic6-23.png" class="" title="pic6-23">
<h2 id="布尔表达式的控制流翻译">布尔表达式的控制流翻译</h2>
<ul>
<li>生成的代码执行时跳转到两个标号之一
<ul>
<li>表达式的值为真时，跳转到<span
class="math inline">\(B.true\)</span></li>
<li>表达式的值为假时，跳转到<span
class="math inline">\(B.false\)</span></li>
</ul></li>
<li><span class="math inline">\(B.true\)</span>和<span
class="math inline">\(B.false\)</span>是两个继承属性，根据B所在的上下文指向不同的位置</li>
</ul>
<h3 id="控制流语句的翻译">控制流语句的翻译</h3>
<img src="/Course-Compiler-6/pic6-36.png" class="" title="pic6-36">
<h4 id="语法制导的定义">语法制导的定义</h4>
<img src="/Course-Compiler-6/pic6-37.png" class="" title="pic6-37">
<img src="/Course-Compiler-6/pic6-38.png" class="" title="pic6-38">
<h3 id="布尔表达式的翻译">布尔表达式的翻译</h3>
<img src="/Course-Compiler-6/pic6-39.png" class="" title="pic6-39">
<img src="/Course-Compiler-6/pic6-40.png" class="" title="pic6-40">
<img src="/Course-Compiler-6/pic6-41.png" class="" title="pic6-41">
<blockquote>
<p><strong>Example: 短路求值</strong></p>
<img src="/Course-Compiler-6/pic6-42.png" class="" title="pic6-42">
</blockquote>
<h4 id="布尔值和跳转代码">布尔值和跳转代码</h4>
<img src="/Course-Compiler-6/pic6-43.png" class="" title="pic6-43">
<img src="/Course-Compiler-6/pic6-44.png" class="" title="pic6-44">
<h3 id="指令的标号与索引">指令的标号与索引</h3>
<img src="/Course-Compiler-6/pic6-45.png" class="" title="pic6-45">
<h4 id="一趟完成">一趟完成</h4>
<img src="/Course-Compiler-6/pic6-46.png" class="" title="pic6-46">
<h3 id="回填">回填</h3>
<ul>
<li>为布尔表达式和控制流语句生成目标代码
<ul>
<li>关键问题：某些跳转指令应该跳转到哪里？</li>
</ul></li>
<li><strong>基本思想</strong>
<ul>
<li>翻译过程中，若遇到跳转目标未知的情况，则先生成<strong>跳转指令坯</strong>，备用<code>goto __/if ... goto __</code></li>
<li>将指令坯并向父结点传递(综合属性)</li>
<li>翻译过程中，若遇到某条指令是跳转目标，则记录其索引，备用如<code>S -&gt; if (B) ▲ S1</code></li>
<li>当父结点收集齐跳转指令坯及其跳转目标索引时，将索引填入指令坯</li>
</ul></li>
</ul>
<img src="/Course-Compiler-6/pic6-47.png" class="" title="pic6-47">
<h4 id="控制转移语句的回填">控制转移语句的回填</h4>
<img src="/Course-Compiler-6/pic6-48.png" class="" title="pic6-48">
<img src="/Course-Compiler-6/pic6-49.png" class="" title="pic6-49">
<img src="/Course-Compiler-6/pic6-50.png" class="" title="pic6-50">
<h5 id="回填与非回填对比">回填与非回填对比</h5>
<img src="/Course-Compiler-6/pic6-51.png" class="" title="pic6-51">
<img src="/Course-Compiler-6/pic6-52.png" class="" title="pic6-52">
<h4 id="布尔表达式的回填翻译">布尔表达式的回填翻译</h4>
<img src="/Course-Compiler-6/pic6-53.png" class="" title="pic6-53">
<h5 id="回填与非回填对比-1">回填与非回填对比</h5>
<img src="/Course-Compiler-6/pic6-54.png" class="" title="pic6-54">
<img src="/Course-Compiler-6/pic6-55.png" class="" title="pic6-55">
<blockquote>
<p><strong>Example: 布尔表达式回填</strong></p>
<img src="/Course-Compiler-6/pic6-56.png" class="" title="pic6-56">
</blockquote>
<h4 id="break-continue的处理">Break &amp; Continue的处理</h4>
<ul>
<li>虽然break、continue在语法上是一个独立的句子，但是它的代码和外围语句相关</li>
<li>方法：(break语句)
<ul>
<li>跟踪外围循环语句S</li>
<li>生成一个跳转指令坯</li>
<li>将这个指令坯的索引加入到S的nextlist中</li>
</ul></li>
</ul>
<h4 id="switch-case的处理">Switch Case的处理</h4>
<img src="/Course-Compiler-6/pic6-57.png" class="" title="pic6-57">
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch5 语法制导的翻译技术/语义分析</title>
    <url>/Course-Compiler-5/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch05
Syntax-Directed Translation / Semantic Analysis.</strong></p>
<span id="more"></span>
<h2
id="使用上下文无关文法引导语言的翻译">使用上下文无关文法引导语言的翻译</h2>
<ul>
<li>CFG的非终结符号代表了语言的某个构造</li>
<li>程序设计语言的构造由更小的构造组合而成</li>
<li>一个构造的语义可以由小构造的含义综合而来
<ul>
<li>比如：表达式<code>x+y</code>的类型由<code>x, y</code>的类型和运算符<code>+</code>决定</li>
</ul></li>
<li>也可以从附近的构造继承而来
<ul>
<li>比如:
声明<code>int x</code>中<code>x</code>的类型由它左边的类型表达式决定</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Tips: 为什么语法分析技术不能检查语义?</strong></p>
<p>语法分析基于CFG, 而语义分析往往与语法元素的上下文密切相关.</p>
<img src="/Course-Compiler-5/pic5-1.png" class="" title="pic5-1">
</blockquote>
<h2 id="语法制导定义和语法制导翻译">语法制导定义和语法制导翻译</h2>
<ul>
<li><strong>语法制导定义:</strong>
<ul>
<li>将文法符号和某些属性相关联，并通过语义规则来描述如何计算属性的值
<ul>
<li><span class="math inline">\(E \rightarrow E_1 + T\)</span>,
则有<span class="math inline">\(E.code = E_1.code\ ||\ T.code\ ||\
&#39;+&#39;\)</span></li>
</ul></li>
<li>属性code代表表达式的逆波兰表示，规则说明加法表达式的逆波兰表示由两个分量的逆波兰表示并置，然后加上'+'得到(中缀表达式=&gt;后缀表达式)</li>
</ul></li>
<li><strong>语法制导翻译:</strong>
<ul>
<li>在产生式体中加入语义动作，并在适当时候执行动作
<ul>
<li><span class="math inline">\(E \rightarrow E_1 + T\)</span> 对应
<code>&#123;print'+';&#125;</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="语法制导的定义sdd">语法制导的定义(SDD)</h2>
<ul>
<li><strong>Syntax-Directed Definition(SDD)</strong>
是上下文无关文法和属性/规则的结合
<ul>
<li>SDD三要素：文法、属性、规则</li>
<li>属性和文法符号相关联，按照需要来确定各个文法符号需要哪些属性</li>
<li>规则和产生式相关联</li>
</ul></li>
<li>对于文法符号<span class="math inline">\(X\)</span>和属性<span
class="math inline">\(a\)</span>，我们用<span
class="math inline">\(X.a\)</span>表示分析树中某个标号为<span
class="math inline">\(X\)</span>的结点的值
<ul>
<li>一个分析树结点和它的分支对应一个产生式规则，而对应的语义规则确定了这些结点上属性的取值和计算</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-2.png" class="" title="pic5-2">
<img src="/Course-Compiler-5/pic5-3.png" class="" title="pic5-3">
</blockquote>
<h3 id="综合属性继承属性">综合属性&amp;继承属性</h3>
<ul>
<li><strong>综合属性(synthesized attribute)</strong> [自底向上]
<ul>
<li>结点<span class="math inline">\(N\)</span>的属性值由<span
class="math inline">\(N\)</span>的产生式所关联的语义规则来定义</li>
<li>通过<span class="math inline">\(N\)</span>的子结点或<span
class="math inline">\(N\)</span>本身的属性值来定义</li>
</ul></li>
<li><strong>继承属性(inherited attribute)</strong> [自顶向下]
<ul>
<li>结点<span class="math inline">\(N\)</span>的属性值由<span
class="math inline">\(N\)</span>的父结点所关联的语义规则来定义</li>
<li>依赖于<span class="math inline">\(N\)</span>的父结点, <span
class="math inline">\(N\)</span>本身和<span
class="math inline">\(N\)</span>的兄弟结点上的属性值</li>
</ul></li>
<li><strong>约束</strong>
<ul>
<li>不允许<span class="math inline">\(N\)</span>的继承属性通过<span
class="math inline">\(N\)</span>的子结点上的属性来定义，但允许<span
class="math inline">\(N\)</span>的综合属性依赖于<span
class="math inline">\(N\)</span>本身的继承属性</li>
<li>终结符号有综合属性(来自词法分析)，但无继承属性</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-4.png" class="" title="pic5-4">
</blockquote>
<h2 id="语法分析树上的sdd求值">语法分析树上的SDD求值</h2>
<ul>
<li>实践中很少先构造语法分析树再进行SDD求值，但在分析树上求值有助于翻译方案的可视化，便于理解</li>
<li><strong>注释语法分析树(Annotated Parse Tree)</strong>
<ul>
<li>包含了各个结点的各属性值的语法分析树</li>
</ul></li>
<li><strong>步骤</strong>
<ul>
<li>对于任意的输入串，首先构造出相应的分析树</li>
<li>给各个结点(根据其文法符号)加上相应的属性</li>
<li>按照语义规则计算这些属性的值</li>
</ul></li>
<li>按照分析树中的分支对应的文法产生式，应用相应的语义规则计算属性值</li>
<li><strong>计算顺序</strong>
<ul>
<li>如果某个结点<span class="math inline">\(N\)</span>的属性<span
class="math inline">\(a\)</span>为<span class="math inline">\(f(N_1.b_1,
N_2.b_2, ..., N_k.b_k)\)</span>, 那么我们需要先算出<span
class="math inline">\(N_1.b_1, N_2.b_2, ..., N_k.b_k\)</span>的值</li>
</ul></li>
<li>如果可以给各个属性值排出计算顺序，那么就可以计算得到这个注释分析树
<ul>
<li>S属性的SDD一定可以按照自底向上的方式求值</li>
</ul></li>
<li>下面的SDD不能计算(循环定义)
<ul>
<li><span class="math inline">\(A \rightarrow B\ \ \ \ \ A.s = B.i\ \ \
\ \ B.i = A.s + 1\)</span></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example: 注释语法分析树</strong></p>
<img src="/Course-Compiler-5/pic5-5.png" class="" title="pic5-5">
</blockquote>
<blockquote>
<p><strong>Additional: 适用于自顶向下分析的SDD</strong></p>
<ul>
<li>前面的文法存在左递归，我们无法用自顶向下的分析方法进行处理</li>
<li>但消除左递归之后，我们无法直接使用属性val进行处理(语法树结构与抽象语法不匹配)
<ul>
<li>比如规则: <span class="math inline">\(T \rightarrow F T&#39;\ \ \ \
\ T&#39; \rightarrow * F T&#39;\ |\ \epsilon\)</span></li>
<li><span
class="math inline">\(T\)</span>对应的项中，第一个因子对应<span
class="math inline">\(F\)</span>，而运算符却在<span
class="math inline">\(T&#39;\)</span>中</li>
<li>需要用<strong>继承属性</strong>来完成这样的计算</li>
</ul></li>
<li><img src="/Course-Compiler-5/pic5-6.png" class="" title="pic5-6"></li>
<li><strong>3*5的注释分析树</strong></li>
</ul>
<blockquote>
<img src="/Course-Compiler-5/pic5-7.png" class="" title="pic5-7">
</blockquote>
<ul>
<li><strong>消除直接左递归时语义规则的处理</strong></li>
</ul>
<blockquote>
<img src="/Course-Compiler-5/pic5-8.png" class="" title="pic5-8">
</blockquote>
</blockquote>
<h3 id="sdd的求值顺序">SDD的求值顺序</h3>
<ul>
<li>在对SDD的求值过程中
<ul>
<li>如果结点<span class="math inline">\(N\)</span>的属性<span
class="math inline">\(a\)</span>依赖于结点<span
class="math inline">\(M_1\)</span>的属性<span
class="math inline">\(a_1\)</span>, <span
class="math inline">\(M_2\)</span>的属性<span
class="math inline">\(a_2\)</span>, ...那么我们必须先计算出<span
class="math inline">\(M_i\)</span>的属性<span
class="math inline">\(a_i\)</span>, 才能计算<span
class="math inline">\(N\)</span>的属性<span
class="math inline">\(a\)</span></li>
</ul></li>
<li>使用<strong>依赖图(Dependency Graph)</strong> 来表示计算顺序
<ul>
<li>这些值的计算顺序形成一个<strong>偏序关系</strong>，如果依赖图中出现了环，表示属性值无法计算</li>
</ul></li>
</ul>
<h4 id="依赖图">依赖图</h4>
<ul>
<li>描述了某棵特定的分析树上各个属性之间的信息流(计算顺序)
<ul>
<li>从实例<span class="math inline">\(a_1\)</span>到实例<span
class="math inline">\(a_2\)</span>的有向边表示计算<span
class="math inline">\(a_2\)</span>时需要<span
class="math inline">\(a_1\)</span>的值</li>
</ul></li>
<li>对于分析树结点<span class="math inline">\(N\)</span>, 与<span
class="math inline">\(N\)</span>关联的每个属性<span
class="math inline">\(a\)</span>都对应依赖图的一个结点<span
class="math inline">\(N.a\)</span></li>
</ul>
<img src="/Course-Compiler-5/pic5-9.png" class="" title="pic5-9">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-10.png" class="" title="pic5-10">
</blockquote>
<h4 id="属性值的计算顺序">属性值的计算顺序</h4>
<ul>
<li>各个属性值需要按照依赖图的<strong>拓扑排序(Topological
Sort)</strong>的顺序进行计算
<ul>
<li>如果依赖图中存在环，则属性计算无法进行(无法排序)</li>
</ul></li>
<li>给定一个SDD，很难判定是否存在一棵分析树，其对应的依赖图包含环</li>
<li>特定类型的SDD一定不包含环，且有固定的计算顺序
<ul>
<li>如：S属性的SDD，L属性的SDD</li>
</ul></li>
</ul>
<h2 id="s属性的sdd">S属性的SDD</h2>
<ul>
<li>只包含综合属性的SDD称为S属性的SDD
<ul>
<li>每个语义规则都根据产生式体中的属性值来计算头部非终结符号的属性值</li>
</ul></li>
<li>S属性的SDD可以和LR语法分析器一起实现
<ul>
<li>栈中的状态/文法符号可以附加相应的属性值</li>
<li>归约时，按照语义规则计算归约得到的符号的属性值</li>
</ul></li>
<li>语义规则不应该有复杂的副作用
<ul>
<li>要求副作用不影响其它属性的求值</li>
<li>没有副作用的SDD称为<strong>属性文法(Attribute Grammar)</strong></li>
</ul></li>
</ul>
<h3 id="计算s属性的sdd">计算S属性的SDD</h3>
<ul>
<li>每个属性都是综合属性，都是根据子构造的属性计算出父构造的属性</li>
<li>在依赖图中，总是通过子结点的属性值来计算父结点的属性值，可以与自底向上或自顶向下的语法分析过程一起计算
<ul>
<li><strong>自底向上</strong>
<ul>
<li>在构造分析树结点的同时计算相关的属性(此时其子结点的属性必然已经计算完毕)</li>
</ul></li>
<li><strong>自顶向下</strong>
<ul>
<li>在递归子程序法中，在过程A()的最后计算A的属性(此时A调用的其它过程(对应于其子结构)已经调用完毕)</li>
</ul></li>
</ul></li>
</ul>
<h3 id="在分析树上计算sdd">在分析树上计算SDD</h3>
<img src="/Course-Compiler-5/pic5-11.png" class="" title="pic5-11">
<h3 id="s属性sdd的局限">S属性SDD的局限</h3>
<ul>
<li>S属性的SDD中每个属性都是综合属性</li>
<li>无法计算同时需要继承和综合属性的语义信息
<ul>
<li><img src="/Course-Compiler-5/pic5-12.png" class="" title="pic5-12"></li>
</ul></li>
</ul>
<h2 id="l属性的sdd">L属性的SDD</h2>
<ul>
<li>每个属性
<ul>
<li>是<strong>综合属性</strong>，或</li>
<li>是<strong>继承属性</strong>，且<span class="math inline">\(A
\rightarrow X_1X_2...X_n\)</span>中计算<span
class="math inline">\(X_i.a\)</span>的规则只用
<ul>
<li><span class="math inline">\(A\)</span>的继承属性，或</li>
<li><span class="math inline">\(X_i\)</span>左边的文法符号<span
class="math inline">\(X_j\)</span>的继承属性或综合属性，或</li>
<li><span
class="math inline">\(X_i\)</span>自身的继承或综合属性(这些属性间的依赖关系不形成环)</li>
</ul></li>
</ul></li>
<li>特点
<ul>
<li>依赖图中的边
<ul>
<li>综合属性从下到上</li>
<li>继承属性从上到下，或从左到右</li>
</ul></li>
<li>计算一个属性值时，它所依赖的属性值都已计算完毕</li>
</ul></li>
</ul>
<h3 id="l属性sdd和自顶向下语法分析">L属性SDD和自顶向下语法分析</h3>
<ul>
<li>在递归子程序法中实现L属性
<ul>
<li>对于每个非终结符号A，其所对应过程的<strong>参数为继承属性，返回值为综合属性</strong></li>
</ul></li>
<li>在处理规则<span class="math inline">\(A \rightarrow
X_1X_2...X_n\)</span>时
<ul>
<li>在调用<span class="math inline">\(X_i()\)</span>之前计算<span
class="math inline">\(X_i\)</span>的继承属性值，然后以它们为参数调用<span
class="math inline">\(X_i()\)</span></li>
<li>在该产生式对应代码的最后计算A的综合属性</li>
<li>如果所有文法符号的属性计算按上面的方式进行，计算顺序必然与依赖关系一致</li>
</ul></li>
</ul>
<img src="/Course-Compiler-5/pic5-13.png" class="" title="pic5-13">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-23.png" class="" title="pic5-23">
<img src="/Course-Compiler-5/pic5-24.png" class="" title="pic5-24">
</blockquote>
<blockquote>
<p><strong>Addtional:</strong></p>
<p>L属性的例子: 基本类型和数组类型的L属性定义</p>
<p>非L属性的例子: <span class="math inline">\(A \rightarrow BC\ \ \
A.s=B.b\ \ \ B.i=f(C.c, A.s)\)</span></p>
</blockquote>
<h3 id="具有受控副作用的语义规则">具有受控副作用的语义规则</h3>
<ul>
<li>属性文法没有<strong>副作用</strong>，但增加了描述的<strong>复杂度</strong>
<ul>
<li>比如语法分析时，如果没有副作用，标识符表就必须作为属性传递</li>
<li>可以把标识符表作为全局变量，然后通过函数来添加新的标识符</li>
</ul></li>
<li><strong>受控的副作用</strong>
<ul>
<li>不会对属性求值产生约束，即可以按照任何拓扑顺序求值，不会影响最终结果</li>
<li>或者对求值过程添加简单的约束</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<ul>
<li><span class="math inline">\(L \rightarrow E_n\ \ \
\{print(E.val);\}\)</span></li>
</ul>
<blockquote>
<p>通过副作用打印出E的值; 总在最后执行，不影响其它属性的求值</p>
</blockquote>
<ul>
<li><strong>变量声明SDD中的副作用</strong></li>
</ul>
<blockquote>
<img src="/Course-Compiler-5/pic5-16.png" class="" title="pic5-16">
</blockquote>
</blockquote>
<h3 id="类型">类型</h3>
<ul>
<li>非严谨的概括: 类型<span
class="math inline">\(\approx\)</span>数据<span
class="math inline">\(+\)</span>操作
<ul>
<li><strong>数据</strong>: 一个类型包含的所有取值集合</li>
<li><strong>操作</strong>: 一个类型支持的所有操作集合</li>
</ul></li>
<li>类型检查
<ul>
<li>计算各表达式的类型</li>
<li>检查各个运算是否是相关类型所支持的合法操作</li>
</ul></li>
</ul>
<h4 id="类型系统">类型系统</h4>
<ul>
<li>类型可视为一种属性，为程序中的元素（变量、语句、表达式…）赋予类型的一套规则称为<strong>类型系统</strong></li>
<li>类型系统规定了每个类型的元素能支持的操作，违反规定的操作称为<strong>类型错误(Type
Error)</strong></li>
<li>检查程序中是否有违反类型错误的过程称为<strong>类型检查(Type
Checking)</strong></li>
</ul>
<h5 id="静态动态">静态&amp;动态</h5>
<ul>
<li><strong>静态类型</strong>: 在编译期进行类型检查</li>
<li><strong>动态类型</strong>: 在运行时进行类型检查</li>
<li>并非绝对
<ul>
<li>静中有动：反射(Reflection)</li>
<li>动中有静：类型注解，Gradual Typing</li>
</ul></li>
</ul>
<h5 id="强类型弱类型">强类型&amp;弱类型</h5>
<ul>
<li>并无精确定义，可理解为类型检查的严格程度
<ul>
<li>强类型的类型规则更为严格</li>
<li>一些在强类型的类型系统中被视为类型错误的行为可能在一个弱类型的系统中是被允许的</li>
</ul></li>
<li>通常强类型的语言倾向于在编译器进行类型检查
<ul>
<li>强类型!=静态类型</li>
</ul></li>
</ul>
<h5 id="类型系统的作用">类型系统的作用</h5>
<ul>
<li>编译器视角
<ul>
<li>类型可以决定数据的大小(size)</li>
<li>指导编译器生成操作数据的相应指令</li>
<li>指导编译器进行正确的内存布局</li>
</ul></li>
<li>程序员视角
<ul>
<li>通常类型错误意味着程序逻辑错误
<ul>
<li>整型与字符串相加、为接收整型的函数传入字符串参数...</li>
</ul></li>
<li>帮助找出程序中的bug</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example: 基本类型的变量声明</strong></p>
<img src="/Course-Compiler-5/pic5-14.png" class="" title="pic5-14">
</blockquote>
<blockquote>
<p><strong>Example: 语句文法</strong></p>
<img src="/Course-Compiler-5/pic5-15.png" class="" title="pic5-15">
</blockquote>
<h4 id="类型结构">类型结构</h4>
<img src="/Course-Compiler-5/pic5-17.png" class="" title="pic5-17">
<img src="/Course-Compiler-5/pic5-18.png" class="" title="pic5-18">
<h3 id="类型表达式的生成过程">类型表达式的生成过程</h3>
<img src="/Course-Compiler-5/pic5-19.png" class="" title="pic5-19">
<h2 id="sdd的应用">SDD的应用</h2>
<ul>
<li>抽象语法树的构造</li>
<li>基本类型和数组类型的L属性定义</li>
</ul>
<h3 id="语法分析树parse-tree">语法分析树(Parse Tree)</h3>
<ul>
<li><strong>具体语法树(Concrete Syntax Tree)</strong>
<ul>
<li>保留所有词法元素(包含对分析无用的噪音)</li>
<li>所有词法元素都有对应节点(节点数量大)</li>
<li>完整地还原非终结符到串的推导过程(包含所有中间推导过程,
引入大量中间节点)</li>
<li>严格符合源语言的上下文无关文法(可根据文法自动生成)</li>
</ul></li>
<li><strong>抽象语法树(Abstract Syntax Tree)</strong>
<ul>
<li>只保留必要的词法元素</li>
<li>某些词法元素信息存入父节点的属性</li>
<li>移除没有实质信息的中间推导过程</li>
<li>不符合源语言的上下文无关文法</li>
</ul></li>
</ul>
<blockquote>
<p><strong>AST的优势</strong></p>
<ul>
<li>更少的结点数量与种类</li>
<li>更易于分析和处理</li>
<li>独立于具体文法</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-20.png" class="" title="pic5-20">
</blockquote>
<h3 id="构造抽象语法树的sdd">构造抽象语法树的SDD</h3>
<ul>
<li><strong>抽象语法树</strong>
<ul>
<li>每个结点代表一个语法结构，对应于<strong>运算符</strong></li>
<li>结点的每个子结点代表其子结构，对应于<strong>运算分量</strong></li>
<li>表示这些子结构按照特定的方式组成了较大的结构</li>
<li>可以忽略掉一些标点符号等非本质的东西</li>
</ul></li>
<li>抽象语法树的表示方法
<ul>
<li>每个结点用一个对象表示</li>
<li>对象有多个域
<ul>
<li>叶子结点中只存放词法值</li>
<li>内部结点中存放了op值和参数(通常指向其子结点)</li>
</ul></li>
</ul></li>
</ul>
<h4
id="构造简单表达式的抽象语法树的sdd">构造简单表达式的抽象语法树的SDD</h4>
<img src="/Course-Compiler-5/pic5-21.png" class="" title="pic5-21">
<img src="/Course-Compiler-5/pic5-22.png" class="" title="pic5-22">
<h2 id="语法制导的翻译方案">语法制导的翻译方案</h2>
<ul>
<li><strong>语法制导的翻译方案(SDT)</strong>
是在产生式体中嵌入语义动作(程序片断)的上下文无关文法</li>
<li><strong>SDT的基本实现方法</strong>
<ul>
<li>建立语法分析树</li>
<li>将语义动作看作是虚拟结点</li>
<li>从左到右、深度优先地遍历分析树(前序遍历)，在访问虚拟结点时执行相应的语义动作</li>
</ul></li>
<li>用SDT实现两类重要的SDD(无需建分析树)
<ul>
<li>基本文法是LR的，且SDD是S属性的</li>
<li>基本文法是LL的，且SDD是L属性的</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-25.png" class="" title="pic5-25">
</blockquote>
<h3 id="可在语法分析过程中实现的sdt">可在语法分析过程中实现的SDT</h3>
<ul>
<li>实现SDT时，实际上并不会真的构造语法分析树，而是在分析过程中执行语义动作</li>
<li>即使基础文法可以应用某种分析技术，仍可能因为动作的缘故导致此技术不可应用</li>
<li>判断是否可在分析过程中实现
<ul>
<li>将每个语义动作替换为一个独有的非终结符号<span
class="math inline">\(M_i\)</span>，其产生式为<span
class="math inline">\(M_i \rightarrow \epsilon\)</span></li>
<li>如果新的文法可以由某种方法进行分析，那么这个SDT就可以在这个分析过程中实现</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-26.png" class="" title="pic5-26">
</blockquote>
<h3 id="后缀翻译方案">后缀翻译方案</h3>
<ul>
<li>文法可以自底向上分析(即LR的)且其SDD是S属性的，必然可以构造出后缀SDT</li>
<li><strong>后缀SDT</strong>: 所有动作都在产生式最右端的SDT</li>
<li><strong>构造方法</strong>
<ul>
<li>将每个语义规则看作是一个赋值语义动作</li>
<li>将所有的语义动作放在规则的最右端</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-27.png" class="" title="pic5-27">
</blockquote>
<h4 id="后缀sdt的语法分析栈实现">后缀SDT的语法分析栈实现</h4>
<ul>
<li>可以在LR语法分析的过程中实现
<ul>
<li>归约时执行相应的语义动作</li>
<li>定义用于记录各文法符号属性的union结构(可放指针)</li>
<li>栈中的每个文法符号(或状态)都附带一个这样的union类型的值</li>
<li>在按照产生式<span class="math inline">\(A \rightarrow
XYZ\)</span>归约时，<span
class="math inline">\(Z\)</span>的属性可以在栈顶找到，<span
class="math inline">\(Y\)</span>的属性可以在下一个位置找到，<span
class="math inline">\(X\)</span>的属性可以在再下一个位置找到</li>
</ul></li>
</ul>
<img src="/Course-Compiler-5/pic5-28.png" class="" title="pic5-28">
<h5 id="分析栈实现的例子">分析栈实现的例子</h5>
<ul>
<li>假设语法分析栈存放在一个被称为<code>stack</code>的记录数组中，下标<code>top</code>指向栈顶
<ul>
<li><code>stack[top]</code>指向这个栈的栈顶</li>
<li><code>stack[top – 1]</code>指向栈顶下一个位置</li>
</ul></li>
<li>如果不同的文法符号有不同的属性集合，我们可以使用<code>union</code>来保存这些属性值
<ul>
<li>归约时能够知道栈顶向下的各个符号分别是什么，因此我们也能够确定各个<code>union</code>中存放了什么值</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-29.png" class="" title="pic5-29">
</blockquote>
<h3 id="产生式内部带有语义动作的sdt">产生式内部带有语义动作的SDT</h3>
<ul>
<li>动作左边的所有符号(以及动作)处理完成后, 就立刻执行这个动作: <span
class="math inline">\(B \rightarrow X\{a\}Y\)</span>
<ul>
<li>自底向上分析时，在<span
class="math inline">\(X\)</span>出现在栈顶时执行动作<span
class="math inline">\(a\)</span></li>
<li>自顶向下分析时，在试图展开<span
class="math inline">\(Y\)</span>或者在输入中检测到<span
class="math inline">\(Y\)</span>的时刻执行<span
class="math inline">\(a\)</span></li>
</ul></li>
<li>对一般的SDT，都可以先建立分析树(语义动作作为虚拟结点),
然后进行前序遍历并执行动作</li>
<li>不是所有的SDT都可以在分析过程中实现
<ul>
<li>后缀SDT以及L属性对应的SDT可以在分析时完成</li>
</ul></li>
</ul>
<h3 id="消除左递归时sdt的转换">消除左递归时SDT的转换</h3>
<img src="/Course-Compiler-5/pic5-30.png" class="" title="pic5-30">
<img src="/Course-Compiler-5/pic5-31.png" class="" title="pic5-31">
<h3 id="l属性的sdt">L属性的SDT</h3>
<ul>
<li>除了通用的SDT实现技术，若基础文法是LL的，则可以将L属性SDD转换成一个SDT，该SDT可以在自顶向下的分析过程中实现</li>
<li>从L属性的SDD到SDT的转换
<ul>
<li>将每个语义规则看作是一个赋值语义动作</li>
<li>将赋值语义动作放到相应产生式<span class="math inline">\(A
\rightarrow X_1X_2...X_n\)</span>的适当位置
<ul>
<li>计算<span
class="math inline">\(X_i\)</span>继承属性的动作插入到产生式体中<span
class="math inline">\(X_i\)</span>的左边</li>
<li>计算产生式头<span
class="math inline">\(A\)</span>综合属性的动作在产生式的最右边</li>
</ul></li>
</ul></li>
</ul>
<h4 id="while语句的sdd和sdt">while语句的SDD和SDT</h4>
<ul>
<li>产生式<span class="math inline">\(S \rightarrow while (C)
S_1\)</span>
<ul>
<li>为while语句生成中间代码</li>
<li>主要说明语句控制流中的标号生成</li>
</ul></li>
<li>while语句的含义
<ul>
<li>首先对<span
class="math inline">\(C\)</span>求值，若为真，则控制转向<span
class="math inline">\(S_1\)</span>的开始处</li>
<li>若为假，则转向while语句的后续语句开始</li>
<li><span
class="math inline">\(S_1\)</span>结束时，要能够跳转到while语句的代码开始处(此例子中仅有部分考虑)</li>
</ul></li>
</ul>
<h5 id="while语句的l属性sdd">while语句的L属性SDD</h5>
<img src="/Course-Compiler-5/pic5-32.png" class="" title="pic5-32">
<h5 id="转化为sdt">转化为SDT</h5>
<img src="/Course-Compiler-5/pic5-33.png" class="" title="pic5-33">
<h5 id="while语句的sdt">while语句的SDT</h5>
<img src="/Course-Compiler-5/pic5-34.png" class="" title="pic5-34">
<h3 id="l属性sdd的实现">L属性SDD的实现</h3>
<ul>
<li>使用递归下降的语法分析器
<ul>
<li>每个非终结符号对应一个函数<span class="math inline">\(S.next
\rightarrow S(next)\)</span></li>
<li>函数的参数接受继承属性，返回值包含了综合属性</li>
</ul></li>
<li>在函数体中
<ul>
<li>首先选择适当的产生式</li>
<li>使用局部变量来保存属性 <strong>(避免副作用)</strong></li>
<li>对于产生式体中的终结符号，读入符号并获取其(经词法分析得到的)综合属性</li>
<li>对于非终结符号，使用适当的方式调用相应函数，并记录返回值</li>
</ul></li>
</ul>
<h4 id="递归下降实现l属性sdd的例子">递归下降实现L属性SDD的例子</h4>
<img src="/Course-Compiler-5/pic5-35.png" class="" title="pic5-35">
<h4 id="边扫描边生成属性">边扫描边生成属性</h4>
<ul>
<li>当属性值的体积很大，对其进行运算会效率很低
<ul>
<li>code可能是一个上百K的串，对其进行并置会很低效</li>
</ul></li>
<li>可逐步生成属性的各个部分，并增量式地添加到最终的属性值中(如数组或输出文件中)</li>
<li>三个条件
<ul>
<li>存在一个主属性，且其为综合属性</li>
<li>在产生式中，主属性是通过产生式体中各非终结符号的主属性连接而得到，同时还会连接一些其它元素</li>
<li>各个非终结符号的主属性的连接顺序与它们在产生式体中的顺序相同</li>
</ul></li>
<li><strong>基本思想</strong>
<ul>
<li>在适当的时候发出元素，并拼接到适当的地方</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example1:</strong></p>
<img src="/Course-Compiler-5/pic5-36.png" class="" title="pic5-36">
</blockquote>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-5/pic5-37.png" class="" title="pic5-37">
<img src="/Course-Compiler-5/pic5-38.png" class="" title="pic5-38">
</blockquote>
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch4 语法分析</title>
    <url>/Course-Compiler-4/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch04
Syntax Analysis.</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p><strong>笔者注:</strong> 语法分析部分的内容实在是过于繁杂和细碎,
以至于不知道该如何进行笔记整理, 暂且归纳出如下的版本.</p>
<blockquote>
<p><strong>Tips:</strong> <del>你这做的是笔记吗, 我都懒得喷你,
什么ppt高级截图手()</del></p>
</blockquote>
<h2 id="语法分析器的作用">语法分析器的作用</h2>
<ul>
<li>从词法分析器获得词法单元的序列，确认该序列是否可以由语言的文法生成</li>
<li>对于语法错误的程序，报告错误信息</li>
<li>对于语法正确的程序，生成<strong>语法分析树</strong>(简称语法树)</li>
</ul>
<img src="/Course-Compiler-4/pic4-1.png" class="" title="pic4-1">
<h2 id="语法分析器的分类">语法分析器的分类</h2>
<ul>
<li>通用语法分析器
<ul>
<li>可以对任意文法进行语法分析</li>
<li>效率很低，不适合用于编译器</li>
</ul></li>
<li><strong>自顶向下</strong>语法分析器(通常用于处理LL文法)
<ul>
<li>从语法分析树的根部开始构造语法分析树</li>
</ul></li>
<li><strong>自底向上</strong>语法分析器(通常用于处理LR文法)
<ul>
<li><p>从语法分析树的叶子开始构造语法分析树</p>
<blockquote>
<p><strong>Tips:</strong>
自顶向下和自底向上总是从左到右、逐个扫描词法单元，只能处理特定类型的文法，但足以描述程序设计语言</p>
</blockquote></li>
</ul></li>
</ul>
<h2 id="程序设计语言构造的描述">程序设计语言构造的描述</h2>
<ul>
<li>程序设计语言构造的语法可使用<strong>上下文无关文法(CFG)</strong>或<strong>BNF表示
法</strong>来描述
<ul>
<li>文法可给出精确易懂的语法规则</li>
<li>可以自动构造出某些类型的文法的语法分析器</li>
<li>文法指出了语言的结构，有助于进一步的语义处理/代码生成</li>
<li>支持语言的演化和迭代</li>
</ul></li>
</ul>
<h2 id="名词定义符号规约">名词定义&amp;符号规约</h2>
<p>与词法分析一致, 语法分析部分也涉及大量的自动机理论知识,
主要是<strong>下推自动机PDA</strong>和<strong>上下文无关文法CFG</strong>.</p>
<p><strong>参考链接:</strong> <a
href="https://fla.cuijiacai.com/"><strong>[崔家才|形式语言与自动机]</strong></a></p>
<h3 id="上下文无关文法">上下文无关文法</h3>
<img src="/Course-Compiler-4/pic4-2.png" class="" title="pic4-2">
<img src="/Course-Compiler-4/pic4-3.png" class="" title="pic4-3">
<ul>
<li><strong>最左/最右推导(leftmost/rightmost derivation):</strong> <span
class="math inline">\(\alpha/\beta\)</span>是由终结符构成的字符串.
<ul>
<li>符号: <span class="math inline">\(\Rightarrow^*_{lm}/
\Rightarrow^*_{rm}\)</span></li>
</ul></li>
<li><strong>句型(sentential form):</strong> 若<span
class="math inline">\(S \Rightarrow^* \alpha\)</span>, 称<span
class="math inline">\(\alpha\)</span>是文法<span
class="math inline">\(S\)</span>的句型.
<ul>
<li>可能既包含非终结符号，又包含终结符号，也可以是空串</li>
</ul></li>
<li><strong>句子(sentence):</strong>
文法的句子就是不包含非终结符号的句型</li>
<li><strong>语言(language):</strong> 文法<span
class="math inline">\(G\)</span>的语言就是<span
class="math inline">\(G\)</span>的句子的集合，记为<span
class="math inline">\(L(G)\)</span>
<ul>
<li><span class="math inline">\(\omega\)</span>在<span
class="math inline">\(L(G)\)</span>中当且仅当<span
class="math inline">\(\omega\)</span>是<span
class="math inline">\(G\)</span>的句子，即<span class="math inline">\(S
\Rightarrow^* \omega\)</span></li>
</ul></li>
</ul>
<h3 id="下推自动机">下推自动机</h3>
<img src="/Course-Compiler-4/pic4-4.png" class="" title="pic4-4">
<h3 id="语法分析树解析树">语法分析树(解析树)</h3>
<ul>
<li>推导的图形表示形式
<ul>
<li>根结点的标号是文法的开始符号</li>
<li>每个叶子结点的标号是非终结符号、终结符号或<span
class="math inline">\(\epsilon\)</span></li>
<li>每个内部结点的标号是非终结符号</li>
<li>每个内部结点表示某个产生式的一次应用
<ul>
<li>结点的标号为产生式头，其子结点从左到右是产生式的体</li>
</ul></li>
</ul></li>
<li>树的叶子组成的序列是根的文法符号的一个句型</li>
<li>一棵语法分析树可对应多个推导序列
<ul>
<li>但只有唯一的最左推导及最右推导</li>
</ul></li>
</ul>
<h4 id="从推导序列构造分析树">从推导序列构造分析树</h4>
<img src="/Course-Compiler-4/pic4-5.png" class="" title="pic4-5">
<h4 id="二义性">二义性</h4>
<ul>
<li><strong>二义性(ambiguity):</strong>
如果一个文法可以为某个句子生成多棵语法分 析树，这个文法就是二义的
<ul>
<li>二义性是<strong>文法</strong>的性质, 而非句型的缘故.</li>
</ul></li>
</ul>
<blockquote>
<p>程序设计语言的文法通常是无二义的, 因此需要消除这种二义性.</p>
</blockquote>
<h2 id="设计文法">设计文法</h2>
<ul>
<li><strong>文法能够描述程序设计语言的大部分语法</strong>
<ul>
<li>但有特例，比如，标识符的先声明后使用则无法用上下文无关文法描述</li>
<li>因此语法分析器接受的语言是程序设计语言的超集；必须通过语义分析来剔除一些符合文法、但不合法的程序</li>
</ul></li>
<li><strong>在进行高效的语法分析之前，需要对文法做以下处理</strong>
<ul>
<li>消除二义性</li>
<li>消除左递归</li>
<li>提取左公因子</li>
</ul></li>
</ul>
<h3 id="二义性消除">二义性消除</h3>
<ul>
<li>一些二义性文法可被改成等价的无二义性的文法</li>
<li>二义性的消除方法没有规律可循, 只能具体情况具体分析</li>
<li>尽管如此, 仍然可以寻得部分"共性"
<ul>
<li><img src="/Course-Compiler-4/pic4-19.png" class="" title="pic4-19"></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong> if-then</p>
<img src="/Course-Compiler-4/pic4-6.png" class="" title="pic4-6">
<img src="/Course-Compiler-4/pic4-7.png" class="" title="pic4-7">
</blockquote>
<h3 id="左递归消除">左递归消除</h3>
<ul>
<li><p><strong>左递归:</strong> 文法中一个非终结符号<span
class="math inline">\(A\)</span>使得对某个串<span
class="math inline">\(\alpha\)</span>, 存在一个推导<span
class="math inline">\(A \rightarrow^* A\alpha\)</span>,
则称这个文法是左递归的</p></li>
<li><p><strong>立即左递归:</strong> 文法中存在一个形如<span
class="math inline">\(A \rightarrow A\alpha\)</span>的产生式</p></li>
<li><p><strong>多步左递归:</strong> 形如<span class="math inline">\(S
\rightarrow A, A \rightarrow S|a\)</span>的文法, 有<span
class="math inline">\(S \Rightarrow^* Sa\)</span></p></li>
<li><p>自顶向下的语法分析技术不能处理左递归的情况，因此需要消除左
递归，但是自底向上的技术可以处理左递归</p></li>
</ul>
<h4 id="直接左递归消除">直接左递归消除</h4>
<img src="/Course-Compiler-4/pic4-8.png" class="" title="pic4-8">
<blockquote>
<p><strong>Additional:</strong></p>
<p>举一个例子就知道为什么可以这么转化了.</p>
<p><span class="math inline">\(A \rightarrow A\alpha |
\beta\)</span></p>
<p>对于上述文法, 可以有<span class="math inline">\(A \Rightarrow^*
\beta, \beta\alpha, \beta\alpha\alpha...\)</span></p>
<p>不难注意到由上述文法产生的句型, 开头一定是<span
class="math inline">\(\beta\)</span> (<span
class="math inline">\(A\)</span>为非终结符),
那么就可以稍微修改变为"右递归": <span class="math inline">\(A
\rightarrow \beta A&#39;, A&#39; \rightarrow \alpha A&#39; |
\epsilon\)</span></p>
</blockquote>
<h4 id="通用左递归消除">通用左递归消除</h4>
<img src="/Course-Compiler-4/pic4-9.png" class="" title="pic4-9">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-10.png" class="" title="pic4-10">
</blockquote>
<h3 id="提取公因子">提取公因子</h3>
<h4 id="预测分析法">预测分析法</h4>
<ul>
<li>试图从开始符号推导出输入符号串</li>
<li>每次为最左边的非终结符号选择适当的产生式
<ul>
<li>通过查看<strong>下一个输入符号</strong>来选择这个产生式</li>
<li>有多个可能的产生式时则无能为力</li>
</ul></li>
<li>当两个产生式具有相同前缀时无法预测
<ul>
<li>因此需要提取左公因子</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> 此处仅作最基本释义, 具体实现参见下文内容.</p>
</blockquote>
<h4 id="提取公因子的文法变换">提取公因子的文法变换</h4>
<img src="/Course-Compiler-4/pic4-11.png" class="" title="pic4-11">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-12.png" class="" title="pic4-12">
</blockquote>
<h2 id="自顶向下的语法分析">自顶向下的语法分析</h2>
<ul>
<li><strong>为输入串构造语法分析树</strong>
<ul>
<li>从分析树的根节点开始, 按照先后次序, 深度优先创建各个节点</li>
<li>对应于<strong>最左推导</strong></li>
</ul></li>
<li><strong>基本步骤(预测分析法)</strong>
<ul>
<li>确定对句型中最左边的非终结符应用哪个生产式</li>
<li>然后确定该生产式与输入符号进行匹配</li>
</ul></li>
<li><strong>关键问题</strong>
<ul>
<li>确定对最左边的非终结符应用哪个生产式</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-13.png" class="" title="pic4-13">
</blockquote>
<h3 id="递归下降的语法分析">递归下降的语法分析</h3>
<ul>
<li>每个非终结符对应一个过程, 该过程负责扫描此非终结符对应的结构</li>
<li>程序执行从开始符号对应的过程开始</li>
<li>算法框架:
<ul>
<li><img src="/Course-Compiler-4/pic4-14.png" class="" title="pic4-14"></li>
</ul></li>
</ul>
<h4 id="递归下降的回溯">递归下降的回溯</h4>
<ul>
<li>如果没有足够的信息来唯一确定可能的产生式，那么分析过程就产生回溯</li>
<li>回溯需要来回扫描，甚至撤销已完成的语义动作</li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<p>文法G: <span class="math inline">\(S \rightarrow cAd, A \rightarrow
ab|a\)</span></p>
<p>input: <span class="math inline">\(cad\)</span></p>
<ul>
<li><strong>step1:</strong> <span
class="math inline">\(S\)</span>选择唯一的生产式<span
class="math inline">\(cAd\)</span></li>
<li><strong>step2:</strong> <span
class="math inline">\(A\)</span>选择<span
class="math inline">\(ab\)</span>, 但<span
class="math inline">\(b\)</span>与<span
class="math inline">\(d\)</span>不匹配, 发生<strong>回溯</strong></li>
<li><strong>step3:</strong> <span
class="math inline">\(A\)</span>选择<span
class="math inline">\(a\)</span>, 成功匹配</li>
<li><strong>conclusion:</strong> <span class="math inline">\(cad \in
L(G)\)</span></li>
</ul>
</blockquote>
<h5 id="如何避免回溯">如何避免回溯?</h5>
<ul>
<li>在自顶向下的分析技术中，使用向前看几个符号来确定产生式(通常只看一个符号)</li>
<li>当前句型是<span
class="math inline">\(xA\beta\)</span>，而输入是<span
class="math inline">\(xa...\)</span>，那么选择产生式<span
class="math inline">\(A \rightarrow \alpha\)</span>的必要条件是下列之一
<ul>
<li><span class="math inline">\(\alpha \Rightarrow ^* a...\)</span></li>
<li><span class="math inline">\(\alpha \Rightarrow ^* \epsilon\)</span>,
且<span class="math inline">\(\beta\)</span>以<span
class="math inline">\(a\)</span>开头</li>
</ul></li>
<li>若上述选择是唯一的, 则可以避免回溯的过程</li>
</ul>
<h3 id="基于ll1文法的递归下降">基于LL(1)文法的递归下降</h3>
<p>由于递归下降法回溯的性能开销问题, 使得该技术并不实用.</p>
<p>接下来介绍可以消除回溯的基于LL(1)文法的优化.</p>
<h4 id="什么是llk">什么是LL(k)</h4>
<ul>
<li><strong>L:</strong> left-to-right, 从左到右扫描</li>
<li><strong>L:</strong> left-most, 最左推导</li>
<li><strong>k:</strong> 向前看k个符号</li>
</ul>
<blockquote>
<p><strong>LL(1):
每次为最左边的非终结符号选择产生式时，向前看1个输入符号，预测要使用的产生式</strong></p>
</blockquote>
<h4 id="first-follow">FIRST &amp; FOLLOW</h4>
<p>为了简化表述, 我们按如下方式定义FIRST, FOLLOW.</p>
<img src="/Course-Compiler-4/pic4-15.png" class="" title="pic4-15">
<img src="/Course-Compiler-4/pic4-16.png" class="" title="pic4-16">
<h5 id="first的计算">FIRST的计算</h5>
<img src="/Course-Compiler-4/pic4-17.png" class="" title="pic4-17">
<blockquote>
<p><strong>Tips:</strong> ppt上写的比较拗口, 其实就是FIRST的定义</p>
</blockquote>
<h5 id="follow的计算">FOLLOW的计算</h5>
<img src="/Course-Compiler-4/pic4-18.png" class="" title="pic4-18">
<blockquote>
<p><strong>Tips:</strong> 为什么第二条规则是对的?</p>
<p>现考虑<span class="math inline">\(S \rightarrow Aa,\ A \rightarrow
\alpha B,\ B \rightarrow b\)</span></p>
<p>易见有<span class="math inline">\(FOLLOW(A) = \{\$, a\}\)</span></p>
<p>那么对于<span class="math inline">\(S \rightarrow Aa\)</span>,
有<span class="math inline">\(S \Rightarrow \alpha Ba\)</span>,
即作为<span
class="math inline">\(A\)</span>可能的产生式的末尾非终结符<span
class="math inline">\(B\)</span>, <span
class="math inline">\(B\)</span>可以共享<span
class="math inline">\(A\)</span>的<span
class="math inline">\(FOLLOW(A)\)</span></p>
</blockquote>
<blockquote>
<p><strong>Example:</strong></p>
<p><strong>文法</strong></p>
<ul>
<li><span class="math inline">\(E \rightarrow TE&#39;\)</span></li>
<li><span class="math inline">\(E&#39; \rightarrow
+TE&#39;|\epsilon\)</span></li>
<li><span class="math inline">\(T \rightarrow FT&#39;\)</span></li>
<li><span class="math inline">\(T&#39; \rightarrow
*FT&#39;|\epsilon\)</span></li>
<li><span class="math inline">\(F \rightarrow (E) | id\)</span></li>
</ul>
<p><strong>FIRST</strong></p>
<ul>
<li><span class="math inline">\(FIRST(F) = \{ (, id \}\)</span></li>
<li><span class="math inline">\(FIRST(T) = FIRST(F) = \{ (, id
\}\)</span></li>
<li><span class="math inline">\(FIRST(E) = FIRST(T) = \{ (, id
\}\)</span></li>
<li><span class="math inline">\(FIRST(E&#39;) = \{ +, \epsilon
\}\)</span></li>
<li><span class="math inline">\(FIRST(T&#39;) = \{ *, \epsilon
\}\)</span></li>
</ul>
<p><strong>FOLLOW</strong></p>
<ul>
<li><span class="math inline">\(FOLLOW(E) = \{ \$, ) \} \quad
\text{(since E is the starting symbol)}\)</span></li>
<li><span class="math inline">\(FOLLOW(E&#39;) = \{ \$, ) \} \quad
\text{(since } E \to TE&#39; \text{)}\)</span></li>
<li><span class="math inline">\(FOLLOW(T) = \{ +, \$, ) \} \quad
\text{(since } E&#39; \to +TE&#39; \text{)}\)</span></li>
<li><span class="math inline">\(FOLLOW(T&#39;) = \{ +, \$, ) \} \quad
\text{(since } T \to FT&#39; \text{)}\)</span></li>
<li><span class="math inline">\(FOLLOW(F) = \{ *, +, \$, ) \} \quad
\text{(since } T \to FT&#39; \text{)}\)</span></li>
</ul>
</blockquote>
<h4 id="ll1文法">LL(1)文法</h4>
<ul>
<li><strong>定义:</strong> 对文法的任意两个产生式<span
class="math inline">\(A \rightarrow \alpha| \beta\)</span>
<ul>
<li>不存在终结符号<span class="math inline">\(a\)</span>使得<span
class="math inline">\(\alpha\)</span>和<span
class="math inline">\(\beta\)</span>都可推导出以<span
class="math inline">\(a\)</span>开头的串</li>
<li><span class="math inline">\(\alpha\)</span>和<span
class="math inline">\(\beta\)</span>最多只有一个可推导出空串</li>
<li>如果<span
class="math inline">\(\beta\)</span>可推导出空串，那么<span
class="math inline">\(\alpha\)</span>不能推导出以<span
class="math inline">\(FOLLOW(A)\)</span>中任何终结符号开头的串</li>
</ul></li>
<li><strong>形式化定义为</strong>
<ul>
<li><span class="math inline">\(FIRST(\alpha) \cap FIRST(\beta) =
\emptyset\)</span></li>
<li><span class="math inline">\(\text{if}\ \epsilon \in FIRST(\beta),
\text{then}\ FIRST(\alpha) \cap FOLLOW(A) = \emptyset\)</span></li>
<li><span class="math inline">\(\text{if}\ \epsilon \in FIRST(\alpha),
\text{then}\ FIRST(\beta) \cap FOLLOW(A) = \emptyset\)</span></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Additional: 为什么需要条件三?</strong></p>
<p>不妨考虑<span class="math inline">\(a \in FOLLOW(A), \alpha
\Rightarrow^* aw, \beta \Rightarrow^* \epsilon\)</span></p>
<p>向前看到下一个字符是<span class="math inline">\(a\)</span>,
此时考虑<span class="math inline">\(A\)</span>的产生式应选择<span
class="math inline">\(\alpha\)</span>或<span
class="math inline">\(\beta\)</span></p>
<p>于是发生了冲突, 因为无论选择<span
class="math inline">\(\alpha\)</span>还是<span
class="math inline">\(\beta\)</span>都可能推导出<span
class="math inline">\(a\)</span>(选择<span
class="math inline">\(\beta\)</span>时将产生<span
class="math inline">\(a\)</span>的任务交给了下一个非终结符)</p>
</blockquote>
<h4 id="ll1文法的递归下降分析">LL(1)文法的递归下降分析</h4>
<ul>
<li>递归下降语法分析程序由一组过程组成</li>
<li>每个非终结符号对应于一个过程，该过程负责扫描该非终结符号对应的结构</li>
<li>可以使用当前的输入符号来<strong>唯一</strong>地选择产生式</li>
</ul>
<h4 id="预测分析表">预测分析表</h4>
<p>FIRST和FOLLOW的定义并不适合计算机的查询操作,
因此为了便于计算机的程序实现, 需要根据FIRST和FOLLOW构建预测分析表.</p>
<ul>
<li>输入: 文法G</li>
<li>输出: 预测分析表M</li>
<li>方法:
<ul>
<li>对于文法G的每一个生产式<span class="math inline">\(A \rightarrow
\alpha\)</span>
<ul>
<li>对于<span
class="math inline">\(FIRST(\alpha)\)</span>中的每个终结符<span
class="math inline">\(a\)</span>, 将<span class="math inline">\(A
\rightarrow \alpha\)</span>添加进<code>M[A, a]</code></li>
<li>若<span class="math inline">\(\epsilon \in FIRST(\alpha)\)</span>,
对于<span class="math inline">\(\forall b \in FOLLOW(A)\)</span>, 将
<span class="math inline">\(A \rightarrow \alpha\)</span>
添加进<code>M[A, b]</code></li>
</ul></li>
<li>上述过程结束后在剩余条目中填入<code>Error</code></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-20.png" class="" title="pic4-20">
</blockquote>
<h5 id="预测分析表的冲突">预测分析表的冲突</h5>
<p>如果预测分析表中某个条目包含大于一个生产式, 则称发生了冲突.</p>
<blockquote>
<p><strong>这种冲突是由文法本身引起的, 因此这个文法是二义的. 可以证明,
LL(1)文法构造的预测分析表不存在冲突.</strong></p>
</blockquote>
<h3 id="非递归的预测分析">非递归的预测分析</h3>
<p>基于LL(1)文法可以消除递归下降的回溯问题, 至此,
预测分析法不再依赖于回溯, 因此也就没有必要进行递归.</p>
<p>我们先来看看自顶向下的预测分析法中需要干什么:</p>
<ul>
<li>匹配掉句型中左边的所有终结符号</li>
<li>对于最左边的非终结符号，选择适当的产生式展开</li>
<li>匹配成功的终结符号不会再被考虑，因此只需要记住句型的余下部分，以及尚未匹配的输入终结符号串</li>
<li>由于展开的动作总是发生在余下部分的左端，我们可以用栈来存放这些符号</li>
</ul>
<h4 id="非递归的预测分析算法">非递归的预测分析算法</h4>
<ul>
<li>初始化时，栈中仅包含开始符号S(和$)</li>
<li>如果栈顶元素是终结符号，那么进行匹配</li>
<li>如果栈顶元素是非终结符号
<ul>
<li>使用预测分析表来选择适当的产生式</li>
<li>在栈顶用产生式右部替换产生式左部</li>
</ul></li>
</ul>
<h4 id="分析表驱动的预测分析器">分析表驱动的预测分析器</h4>
<img src="/Course-Compiler-4/pic4-21.png" class="" title="pic4-21">
<img src="/Course-Compiler-4/pic4-22.png" class="" title="pic4-22">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-23.png" class="" title="pic4-23">
</blockquote>
<blockquote>
<p><strong>Tips: 学到这里感觉很乱?</strong></p>
<p>这一块内容ppt以需要什么从而展开什么的方法进行讲述.</p>
<p>自顶向下的分析过程思想即是<strong>预测分析法</strong>,
接下来最朴素的算法<strong>递归下降</strong>可以实现预测分析法.
但我们发现有严重的性能问题.</p>
<p>这部分开销主要消耗在回溯上,
因此想办法研究<strong>如何避免回溯</strong>,
发现问题出在选择的<strong>不唯一性</strong>.</p>
<p>自然引申出了<strong>LL(1)文法</strong>和辅助函数<strong>FIRST&amp;FOLLOW</strong>.
为便于计算机实现, 构造出<strong>预测分析表</strong>.</p>
<p>此时<strong>递归下降</strong>中的<strong>递归</strong>已然不是必要的了,
可以使用<strong>栈Stack</strong>更为便捷地实现预测分析法.</p>
<p>至此, 便整理出了本节内容的逻辑.</p>
</blockquote>
<h3 id="自顶向下的局限">自顶向下的局限</h3>
<ul>
<li>根据极为有限的信息预测(猜)产生式</li>
<li>能识别的文法有局限性
<ul>
<li>需要改造文法消除左递归</li>
<li>改造后的文法不直观</li>
<li>生成的语法树不易理解和处理</li>
</ul></li>
</ul>
<h2 id="自底向上的语法分析">自底向上的语法分析</h2>
<ul>
<li>为一个输入串构造语法分析树的过程</li>
<li>从叶子(输入串中的终结符号，将位于分析树的底端) 开始，向上到达根结点
<ul>
<li>在实际的语法分析过程中并不一定会构造出相应的分析树，但是用分析树的概念可以方便理解</li>
</ul></li>
<li>自底向上语法分析的通用框架:
<strong>移植-规约(shift-reduce)</strong></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-24.png" class="" title="pic4-24">
</blockquote>
<h3 id="移入-归约分析技术">移入-归约分析技术</h3>
<h4 id="规约">规约</h4>
<ul>
<li>自底向上的语法分析过程可以看成是从串<span
class="math inline">\(\omega\)</span>归约为文法开始符号<span
class="math inline">\(S\)</span>的过程</li>
<li><strong>行为:</strong>
一个与某产生式体相匹配的特定子串被替换为该产生式头部的非终结符号</li>
<li><strong>关键问题:</strong>
<ul>
<li>何时规约?(规约哪些字符串)</li>
<li>如何规约?(归约到哪个非终结符)</li>
</ul></li>
</ul>
<h4 id="句柄">句柄</h4>
<ul>
<li>对输入从左到右扫描，并进行自底向上的语法分析，实际可以反向构造出一个<strong>最右推导</strong></li>
<li><strong>句柄(handle)</strong>
<ul>
<li>最右句型中和某个产生式体相匹配的子串，对它的归约代表了该最右句型的最右推导的最后一步</li>
<li><strong>定义:</strong> 若<span class="math inline">\(S
\Rightarrow^*_{rm} \alpha A \omega \Rightarrow_{rm} \alpha \beta
\omega\)</span>, 称<span class="math inline">\(\beta\)</span>是<span
class="math inline">\(A \rightarrow \beta\)</span>的一个句柄</li>
</ul></li>
<li>在一个最右句型中，句柄右边只有终结符号</li>
<li>如果文法是无二义性的，那么每个句型有且只有一个句柄</li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-25.png" class="" title="pic4-25">
<p>这个例子看起来有一点"反直觉",
为什么<code>id1 * id2</code>的句柄是<code>id1</code>?
因为最右推导是<strong>正向的</strong>,
<code>E -&gt; T*F -&gt; T*id2 -&gt; F*id2 -&gt; id1*id2</code>.
但是句柄的定义是<strong>反向的</strong>,
所以第一行的句柄是<code>id1</code></p>
</blockquote>
<h4 id="移入-规约模型">移入-规约模型</h4>
<ul>
<li>使用一个栈来保存归约/扫描移入的文法符号</li>
<li>栈中符号(从底向上)
和待扫描的符号组成了一个<strong>最右句型</strong></li>
<li>开始时刻：栈中只包含<span
class="math inline">\(\$\)</span>，而输入为<span
class="math inline">\(\omega\$\)</span></li>
<li>结束时刻：栈中为<span
class="math inline">\(S\$\)</span>，而输入为<span
class="math inline">\(\$\)</span></li>
<li>在分析过程中，不断移入符号，并在识别到句柄时进行归约</li>
<li>句柄被识别时总是出现在栈的顶部</li>
</ul>
<h5 id="行为定义">行为定义</h5>
<ul>
<li><strong>移入(shift):</strong> 将下一个输入符号移入到栈顶</li>
<li><strong>归约(reduce):</strong> 将句柄归约为相应的非终结符号
<ul>
<li>句柄总是在栈顶</li>
<li>具体操作时弹出句柄，压入被归约到的非终结符号</li>
</ul></li>
<li><strong>接受(accept):</strong> 宣布分析过程成功完成</li>
<li><strong>报错(error):</strong> 发现语法错误，调用错误恢复子程序</li>
</ul>
<blockquote>
<p><strong>Tips: 为什么句柄总是在栈顶?</strong></p>
<img src="/Course-Compiler-4/pic4-26.png" class="" title="pic4-26">
</blockquote>
<h4 id="移入-归约分析中的冲突">移入-归约分析中的冲突</h4>
<p><strong>对于有些不能使用移入-归约分析的文法，不管用什么样的移入-归约分析器都会到达这样的格局.</strong></p>
<ul>
<li>即使知道了栈中所有内容、以及下面k个输入符号，人们仍然无法知道是否该进行归约(<strong>移入-归约冲突</strong>)，或者不知道按照什么产生式进行归约(<strong>归约-归约冲突</strong>)</li>
<li>设栈中符号串是<span class="math inline">\(\alpha
\beta\)</span>，接下来的k个符号是<span
class="math inline">\(x\)</span>，产生移入/归约冲突的原因是存在<span
class="math inline">\(y\)</span>和<span
class="math inline">\(y&#39;\)</span>使得<span
class="math inline">\(a\beta xy\)</span>是最右句型且<span
class="math inline">\(\beta\)</span>是句柄(需归约)，而<span
class="math inline">\(a\beta
xy&#39;\)</span>也是最右句型，但是句柄还在右边(需移入)</li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-27.png" class="" title="pic4-27">
</blockquote>
<h3 id="lr语法分析技术">LR语法分析技术</h3>
<ul>
<li><strong>LR(k)</strong>
<ul>
<li>L: 从左往右扫面</li>
<li>R: 最右推导</li>
<li>k: 向前看k个符号</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> 当k增大时, 相应的语法分析器的规模急剧增大.
而<code>k = 0,1</code>时已经具有实践意义.</p>
</blockquote>
<h4 id="lr语法分析器的优点">LR语法分析器的优点</h4>
<ul>
<li>由表格驱动，虽然复杂语法对应的表格很大，但表格可以自动生成</li>
<li>对于几乎所有的程序设计语言，只要写出上下文无关文法，就能够构造出识别该语言的LR语法分析器</li>
<li>最通用的无回溯移入-归约分析技术</li>
<li>能分析的文法比LL(k)文法更多</li>
</ul>
<h3 id="lr0语法分析">LR(0)语法分析</h3>
<h4 id="lr语法分析思路">LR语法分析思路</h4>
<img src="/Course-Compiler-4/pic4-28.png" class="" title="pic4-28">
<img src="/Course-Compiler-4/pic4-29.png" class="" title="pic4-29">
<img src="/Course-Compiler-4/pic4-30.png" class="" title="pic4-30">
<h4 id="相关定义">相关定义</h4>
<h5 id="增广文法">增广文法</h5>
<ul>
<li><strong>增广文法(augmented grammar)</strong>
<ul>
<li><span class="math inline">\(G\)</span>的增广文法<span
class="math inline">\(G&#39;\)</span>是在<span
class="math inline">\(G\)</span>中增加新开始符号<span
class="math inline">\(S&#39;\)</span>，并加入产生式<span
class="math inline">\(S&#39; \rightarrow S\)</span>而得到的</li>
<li>显然<span class="math inline">\(G&#39;\)</span>和<span
class="math inline">\(G\)</span>接受相同的语言，且按照<span
class="math inline">\(S&#39; \rightarrow
S\)</span>进行归约实际上就表示已经将输入符号串归约成为开始符号</li>
</ul></li>
</ul>
<h5 id="项集闭包">项集闭包</h5>
<ul>
<li><strong>项集闭包(CLOSURE):</strong> 如果<span
class="math inline">\(I\)</span>是文法<span
class="math inline">\(G\)</span>的一个项集，<span
class="math inline">\(CLOSURE(I)\)</span>就是根据下列两条规则从<span
class="math inline">\(I\)</span>构造得到的项集
<ul>
<li>将<span class="math inline">\(I\)</span>中的各项加入<span
class="math inline">\(CLOSURE(I)\)</span>中</li>
<li>如果<span class="math inline">\(A \rightarrow \alpha \cdot B
\beta\)</span>在<span
class="math inline">\(CLOSURE(I)\)</span>中，而<span
class="math inline">\(B \rightarrow
\gamma\)</span>是一个产生式，且项<span class="math inline">\(B
\rightarrow \cdot \gamma\)</span>不在<span
class="math inline">\(CLOSURE(I)\)</span>中，就将该项加入其中，不断应用该规则直到没有新项可加入</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> <span class="math inline">\(A \rightarrow
\alpha \cdot B \beta\)</span>，表示希望看到由<span
class="math inline">\(B \beta\)</span>推导出的串，那要先看到由<span
class="math inline">\(B\)</span>推导出的串，因此加上<span
class="math inline">\(B\)</span>的各个产生式对应的项</p>
</blockquote>
<blockquote>
<p><strong>Additional: 项集闭包构造算法</strong></p>
<img src="/Course-Compiler-4/pic4-31.png" class="" title="pic4-31">
</blockquote>
<blockquote>
<p><strong>Example:</strong></p>
<p><strong>增广文法</strong></p>
<ul>
<li><span class="math inline">\(E&#39; \rightarrow E\)</span></li>
<li><span class="math inline">\(E \rightarrow E+T\ |\ T\)</span></li>
<li><span class="math inline">\(T \rightarrow T*F\ |\ F\)</span></li>
<li><span class="math inline">\(F \rightarrow (E)\ |\ id\)</span></li>
</ul>
<p>现求项集<span class="math inline">\(\{[E&#39; \rightarrow \cdot
E]\}\)</span>的闭包</p>
<ul>
<li><strong>step1:</strong> <span class="math inline">\([E&#39;
\rightarrow \cdot E]\)</span>加入闭包</li>
<li><strong>step2:</strong> <span class="math inline">\([E \rightarrow
\cdot E+T]\)</span>, <span class="math inline">\([E \rightarrow \cdot
T]\)</span>加入闭包</li>
<li><strong>step3:</strong> <span class="math inline">\([T \rightarrow
\cdot T*F]\)</span>, <span class="math inline">\([T \rightarrow \cdot
F]\)</span>加入闭包</li>
<li><strong>step4:</strong> <span class="math inline">\([F \rightarrow
\cdot (E)]\)</span>, <span class="math inline">\([F \rightarrow \cdot
id]\)</span>加入闭包</li>
<li><strong>step5:</strong> 没有更多的项可以加入闭包了,算法终止</li>
</ul>
</blockquote>
<h5 id="goto函数">GOTO函数</h5>
<img src="/Course-Compiler-4/pic4-32.png" class="" title="pic4-32">
<h4 id="求lr0项集规范族算法">求LR(0)项集规范族算法</h4>
<ul>
<li>从初始项集开始，不断计算各种可能的后继，直到生成所有的项集</li>
</ul>
<img src="/Course-Compiler-4/pic4-33.png" class="" title="pic4-33">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-41.png" class="" title="pic4-41">
<p>有点看不懂这张图? 这是正常现象, 这个例子并不直观,
接下来推导前几步来帮助理解.</p>
<ul>
<li><strong>step1:</strong>
初始时<code>C &lt;- CLOSURE(&#123;E' -&gt; E&#125;)</code>,
其中<code>CLOSURE(&#123;E' -&gt; E&#125;)</code>对应图中<code>I0</code></li>
<li><strong>step2:</strong> 接着为<code>I0</code>遍历所有的文法符号,
合法的符号有<code>E, T, F, (, id</code>(<code>GOTO(I0, x)</code>非空),
以<code>E</code>为例,
<code>GOTO(I0, E)</code>得到的项集为<code>I1</code>,
执行<code>C &lt;- I1</code>(等价<code>C &lt;- GOTO(I0, E)</code>)</li>
<li><strong>step3:</strong> 重复上述过程至<code>C</code>不再变化</li>
</ul>
</blockquote>
<h4 id="lr0自动机构造">LR(0)自动机构造</h4>
<ul>
<li>基于规范LR(0)项集族可以构造LR(0)自动机</li>
<li>规范LR(0)项集族中的每个<strong>项集</strong>对应于LR(0)自动机的一个<strong>状态</strong></li>
<li><strong>状态转换:</strong> 如果GOTO(I, X) =
J，则从I到J有一个标号为X的转换</li>
<li>开始状态为<span class="math inline">\(CLOSURE(\{S&#39; \rightarrow
\cdot S\})\)</span>对应的状态</li>
<li>接受状态为<span class="math inline">\(GOTO(CLOSURE(\{S&#39;
\rightarrow S \cdot\}), \$)\)</span>对应的状态</li>
</ul>
<h5 id="lr0自动机的作用">LR(0)自动机的作用</h5>
<ul>
<li>假设文法符号串<span
class="math inline">\(\gamma\)</span>使LR(0)自动机从开始状态运行到状态(项集)
<span class="math inline">\(j\)</span></li>
<li>如果<span class="math inline">\(j\)</span>中存在项<span
class="math inline">\(A \rightarrow \alpha \cdot\)</span>，那么
<ul>
<li>在<span
class="math inline">\(\gamma\)</span>之后添加一些终结符号可以得到一个最右句型</li>
<li><span class="math inline">\(\alpha\)</span>是<span
class="math inline">\(\gamma\)</span>的后缀，且是该句型的句柄(对应于产生式<span
class="math inline">\(A \rightarrow \alpha\)</span>)</li>
<li>表示可能找到了当前最右句型的句柄，可以归约</li>
</ul></li>
<li>如果<span class="math inline">\(j\)</span>中存在项<span
class="math inline">\(B \rightarrow \alpha \cdot X\beta\)</span>，那么
<ul>
<li>在<span class="math inline">\(\gamma\)</span>之后添加<span
class="math inline">\(X\beta\)</span>和一些终结符号可以得到一个最右句型</li>
<li>该句型中<span class="math inline">\(\alpha X
\beta\)</span>是句柄，但还没找到，还需移入</li>
</ul></li>
<li>LR(0)自动机的使用
<ul>
<li>移入-归约时，LR(0)自动机被用于识别句型</li>
<li>已得到的文法符号序列对应于LR(0)自动机的一条路径</li>
</ul></li>
<li>LR(0)自动机运行过程中用<strong>栈</strong>记录状态变化
<ul>
<li><strong>文法符号可省略</strong>，由LR(0)状态可确定相应的文法符号
<ul>
<li>状态间的转换是唯一的，转换边上有文法符号</li>
</ul></li>
<li>在移入后，根据原来的栈顶状态可以知道新的状态
<ul>
<li>根据原栈顶状态和移入符号，查询GOTO</li>
</ul></li>
<li>在归约时，根据归约产生式的右部长度弹出相应状态，也可以根据此时的栈顶状态知道新的状态
<ul>
<li>归约相当于先弹出，再移入</li>
</ul></li>
</ul></li>
</ul>
<h4 id="lr语法分析器的结构">LR语法分析器的结构</h4>
<img src="/Course-Compiler-4/pic4-34.png" class="" title="pic4-34">
<h5 id="lr语法分析表的结构">LR语法分析表的结构</h5>
<img src="/Course-Compiler-4/pic4-35.png" class="" title="pic4-35">
<h4 id="lr语法分析器的格局">LR语法分析器的格局</h4>
<img src="/Course-Compiler-4/pic4-36.png" class="" title="pic4-36">
<h4 id="lr语法分析器的行为">LR语法分析器的行为</h4>
<img src="/Course-Compiler-4/pic4-37.png" class="" title="pic4-37">
<h4 id="lr语法分析器的算法">LR语法分析器的算法</h4>
<img src="/Course-Compiler-4/pic4-38.png" class="" title="pic4-38">
<h4 id="simple-lr语法分析表的构造">Simple LR语法分析表的构造</h4>
<img src="/Course-Compiler-4/pic4-39.png" class="" title="pic4-39">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-40.png" class="" title="pic4-40">
</blockquote>
<h4 id="slr语法分析过程分析">SLR语法分析过程分析</h4>
<p>至此, 我们已经完整理出了SLR语法分析所需的全部理论知识.</p>
<p>接下来来看一个例子来体验其全过程.</p>
<p><strong>(已编号)文法G:</strong></p>
<ol type="1">
<li><span class="math inline">\(E \rightarrow E + T\)</span></li>
<li><span class="math inline">\(E \rightarrow T\)</span></li>
<li><span class="math inline">\(T \rightarrow T*F\)</span></li>
<li><span class="math inline">\(T \rightarrow F\)</span></li>
<li><span class="math inline">\(F \rightarrow (E)\)</span></li>
<li><span class="math inline">\(F \rightarrow id\)</span></li>
</ol>
<p>下面给出方便分析的辅助FIRST, FOLLOW信息.</p>
<ul>
<li><p><code>FIRST(E) = &#123;id, (&#125;</code></p></li>
<li><p><code>FIRST(T) = &#123;id, (&#125;</code></p></li>
<li><p><code>FIRST(F) = &#123;id, (&#125;</code></p></li>
<li><p><code>FOLLOW(E) = &#123;+, ), $&#125;</code></p></li>
<li><p><code>FOLLOW(T) = &#123;*, +, ), $&#125;</code></p></li>
<li><p><code>FOLLOW(F) = &#123;*, +, ), $&#125;</code></p></li>
</ul>
<h5 id="构造分析表">构造分析表</h5>
<p>首先要构造文法G的增广文法的项集规范族,
上述的讨论已经给出了其作为例子的示例.</p>
<img src="/Course-Compiler-4/pic4-41.png" class="" title="pic4-41">
<p>接着跟据项集规范族构造分析表.</p>
<p>我们约定<strong>移入</strong>操作为<strong>s(store)</strong>,
<strong>规约</strong>操作为<strong>r(reduce)</strong>.</p>
<ul>
<li>其中GOTO的表项较容易构造, 直接找出所有以非终结符箭头连接的项集即可,
例如<code>GOTO(I0, E) = I1</code>, <code>GOTO(I7, F) = I10</code>等</li>
<li>接着看项集中待扫描为终结符的条目, 如<code>I0</code>中的<span
class="math inline">\(F \rightarrow \cdot(E)\)</span>, <span
class="math inline">\(F \rightarrow \cdot id\)</span>
,注意到这两条都有相应的GOTO条目, 于是有<code>ACTION[I0, (] = s4</code>,
<code>ACTION[I0, id] = s5</code></li>
<li>最后看项集中全部都已经扫描结束的项
<ul>
<li>如果是<span class="math inline">\(E&#39; \rightarrow E
\cdot\)</span>
有<code>ACTION[Ii, $] = acc</code>(本例中为<code>ACTION[I1, $] = acc</code>)</li>
<li>其余情况中, 以<code>I2</code>为例, 注意到<span
class="math inline">\(E \rightarrow T \cdot\)</span>已经扫描结束,
计算<code>FOLLOW(E) = &#123;+, ), $&#125;</code>,
ACTION表项中填入<code>ACTION[I2, +] = r2</code>,
<code>ACTION[I2, )] = r2</code>,
<code>ACTION[I2, $] = r2</code>(生产式<span class="math inline">\(E
\rightarrow T\)</span>编号为2)</li>
</ul></li>
</ul>
<p>构造结束后的表如图所示:</p>
<img src="/Course-Compiler-4/pic4-42.png" class="" title="pic4-42">
<h5 id="跟据分析表运行lr0自动机">跟据分析表运行LR(0)自动机</h5>
<img src="/Course-Compiler-4/pic4-43.png" class="" title="pic4-43">
<p>同样的, 为了便于理解, 在此给出前几步的推导过程.</p>
<ul>
<li><strong>step0:</strong> 因为是增广语法,
初始时一定从<code>E'</code>开始, 即<code>I0</code>,
此时栈中压入状态<code>0</code></li>
<li><strong>step1:</strong> 此时输入符号为终结符<code>id</code>,
查询表项<code>ACTION[I0, id] = s5</code>, 执行移入,
将状态<code>5</code>压入栈中, 输入后移一位</li>
<li><strong>step2:</strong> 此时输入为终结符<code>*</code>,
查询表项有<code>ACTION[I5, *] = r6</code>, 执行规约,
对应编号为6的生产式为<span class="math inline">\(F \rightarrow
id\)</span>. 其中<span class="math inline">\(|id| = 1\)</span>,
栈中弹出一个符号, 此时栈顶状态为<code>0</code>,
查询表项<code>GOTO[I0, F] = I3</code>, 将状态<code>3</code>压入栈中,
输入不变.</li>
<li>下略</li>
</ul>
<blockquote>
<p><strong>Tips: 如何理解LR自动机的运行过程?</strong></p>
<p>LR自动机的执行实际上是证明CFG和PDA等价的特例. 可以证明,
为CFG构造的PDA,
可以识别相应CFG定义的语言(具体证明见<strong>形式语言与自动机理论</strong>).
然而其证明过程是在<strong>NPDA(非确定下推自动机)</strong>中模拟CFG的推导过程,
其过程并不适用于计算机进行语法分析判断某个输入是否可接受.</p>
<p>可以看出, LR与LL一样,
都是在寻求推导过程的<strong>唯一性</strong>.</p>
</blockquote>
<h4 id="slr语法分析器的弱点">SLR语法分析器的弱点</h4>
<blockquote>
<p><strong>Additional: SLR解决冲突的思想</strong></p>
<p>假如要按照<span class="math inline">\(A \rightarrow
\beta\)</span>进行归约，只有当下一个输入符号在<span
class="math inline">\(FOLLOW(A)\)</span>中时才可以归约.
但不是所有的冲突都能通过查看下一个输入符号来解决</p>
</blockquote>
<ul>
<li><strong>SLR技术解决冲突的方法</strong>
<ul>
<li>项集中包含<span class="math inline">\([A \rightarrow \alpha
\cdot]\)</span>时，按照<span class="math inline">\(A \rightarrow
\alpha\)</span>进行归约的条件是下一个输入符号x可以在某个句型中跟在A之后
<ul>
<li>如果此时对于x还有其它的移入/归约操作，则出现冲突</li>
</ul></li>
<li>假设此时栈中的符号串为<span class="math inline">\(\beta
\alpha\)</span>
<ul>
<li>如果<span class="math inline">\(\beta
Ax\)</span>不是任何最右句型的前缀，那么即使x在某个句型中跟在A之后，仍不应该按<span
class="math inline">\(A \rightarrow \alpha\)</span>归约</li>
<li>进行归约的条件更加严格可以降低冲突的可能性</li>
</ul></li>
</ul></li>
<li><span class="math inline">\([A \rightarrow \alpha
\cdot]\)</span><strong>出现在项集中的条件</strong>
<ul>
<li>首先<span class="math inline">\([A \rightarrow \cdot
\alpha]\)</span>出现在某个项集中，然后逐步读入/归约到<span
class="math inline">\(\alpha\)</span>中的符号，点不断后移，到达末端</li>
<li>而<span class="math inline">\([A \rightarrow \cdot
\alpha]\)</span>出现的条件是<span class="math inline">\(B \rightarrow
\beta \cdot A \gamma\)</span>出现在项中</li>
<li>期望首先按照<span class="math inline">\(A \rightarrow
\alpha\)</span>归约，然后将<span class="math inline">\(B \rightarrow
\beta \cdot A \gamma\)</span>中的点移到A之后</li>
<li>显然，在按照<span class="math inline">\(A \rightarrow
\alpha\)</span>归约时要求下一个输入符号是<span
class="math inline">\(\gamma\)</span>的第一个符号，但是从LR(0)项集中不能确定这个信息</li>
</ul></li>
</ul>
<h3 id="更强大的lr语法分析器">更强大的LR语法分析器</h3>
<ul>
<li><strong>规范LR方法(LR方法)</strong>
<ul>
<li>添加项<span class="math inline">\([A \rightarrow \cdot
\alpha]\)</span>时，把期望的向前看符号也加入项中(<strong>成为LR(1)项集</strong>)</li>
<li>向前看符号(串)的长度即为LR(k)中的k</li>
<li>这个做法可以充分利用向前看符号，但是状态很多</li>
</ul></li>
<li><strong>向前看LR(LALR方法)</strong>
<ul>
<li>基于LR(0)项集族，但每个LR(0)项都带有向前看符号</li>
<li>分析能力强于SLR方法，且分析表和SLR分析表一样大</li>
<li>LALR已经可以处理大部分的程序设计语言</li>
</ul></li>
</ul>
<h3 id="lr1语法分析">LR(1)语法分析</h3>
<h4 id="可行前缀">可行前缀</h4>
<ul>
<li><strong>可行前缀(viable prefix):</strong>
可以出现在语法分析器栈中的<strong>最右句型的前缀</strong>，且没有越过该句型的句柄的右端.</li>
<li><strong>有效项:</strong> 如果存在一个推导过程<span
class="math inline">\(S\)</span>到<span class="math inline">\(\alpha A
\omega \Rightarrow \alpha \beta_1 \beta_2
\omega\)</span>，那么我们说项<span class="math inline">\(A \rightarrow
\beta_1 \cdot \beta_2\)</span>是可行前缀<span
class="math inline">\(\alpha \beta_1\)</span>的有效项
<ul>
<li>如果我们知道项<span class="math inline">\(A \rightarrow \beta_1
\cdot \beta_2\)</span>对<span class="math inline">\(\alpha
\beta_1\)</span>有效
<ul>
<li><span
class="math inline">\(\beta_2\)</span>不等于空，表示句柄尚未出现在栈中，应该<strong>移入</strong></li>
<li>如果<span
class="math inline">\(\beta_2\)</span>等于空，表示句柄已出现在栈中，应该<strong>归约</strong></li>
</ul></li>
<li>如果在某个时刻存在两个有效项要求对同一个可行前缀执行不同的动作，就应该设法解决冲突
<ul>
<li>冲突实际上表示该可行前缀可能是两个最右句型的前缀，第一个包含了句柄，而另一个尚未包含句柄</li>
<li>也可能都认为包含句柄，但是规则不一样</li>
</ul></li>
</ul></li>
</ul>
<h4 id="lr1项">LR(1)项</h4>
<ul>
<li>LR(1)项中包含更多信息来消除一些归约动作</li>
<li>实际的做法相当于“分裂”一些LR(0)状态，精确指明何时应该归约</li>
<li><strong>LR(1)项的形式</strong><span class="math inline">\([A
\rightarrow \alpha \cdot \beta, a]\)</span>
<ul>
<li>a称为向前看符号，可以是终结符号或者$</li>
<li>a表示如果将来要按照<span class="math inline">\(A \rightarrow \alpha
\beta\)</span>进行归约，归约时的下一个输入符号必须是a</li>
<li>当<span
class="math inline">\(\beta\)</span>非空时，移入动作不考虑a，a传递到下一状态</li>
</ul></li>
</ul>
<h5 id="lr1与可行前缀">LR(1)与可行前缀</h5>
<img src="/Course-Compiler-4/pic4-44.png" class="" title="pic4-44">
<h5 id="lr1项的作用">LR(1)项的作用</h5>
<ul>
<li>形如<span class="math inline">\([A \rightarrow \alpha \cdot,
a]\)</span>，辅助归约决策</li>
<li>形如<span class="math inline">\(A \rightarrow \alpha \cdot B \beta,
a\)</span>，辅助计算<span class="math inline">\([B \rightarrow \theta
\cdot, b]\)</span>
<ul>
<li><span class="math inline">\([A \rightarrow \alpha \cdot B \beta, a]
\rightarrow [B \rightarrow \cdot \theta, b] \rightarrow [B \rightarrow
\theta \cdot , b]\)</span></li>
<li>产生式<span class="math inline">\([A \rightarrow \alpha \cdot B
\beta]\)</span>的信息传递到了<span class="math inline">\([B \rightarrow
\theta \cdot, b]\)</span></li>
<li>辅助归约<span class="math inline">\(B \rightarrow
\theta\)</span></li>
</ul></li>
</ul>
<h4 id="lr1项集族构造">LR(1)项集族构造</h4>
<h5 id="构造closure">构造CLOSURE</h5>
<ul>
<li>在<span class="math inline">\(CLOSURE\)</span>中，当由项<span
class="math inline">\([A \rightarrow \alpha \cdot B \beta,
a]\)</span>生成新项<span class="math inline">\([B \rightarrow \cdot
\theta, b]\)</span>时，b必须在<span class="math inline">\(FIRST(\beta
\alpha)\)</span>中</li>
<li>对LR(1)项集中的任意项<span class="math inline">\([A \rightarrow
\alpha \cdot B \beta, a]\)</span>，总有：a在<span
class="math inline">\(FOLLOW(A)\)</span>中
<ul>
<li>初始项满足这个条件</li>
<li>每次求<span
class="math inline">\(CLOSURE\)</span>项集时，新产生的项也满足这个条件</li>
</ul></li>
</ul>
<img src="/Course-Compiler-4/pic4-45.png" class="" title="pic4-45">
<h5 id="构造goto">构造GOTO</h5>
<img src="/Course-Compiler-4/pic4-46.png" class="" title="pic4-46">
<h5 id="构造lr1项集族">构造LR(1)项集族</h5>
<img src="/Course-Compiler-4/pic4-47.png" class="" title="pic4-47">
<h4 id="lr1语法分析表的构造">LR(1)语法分析表的构造</h4>
<img src="/Course-Compiler-4/pic4-48.png" class="" title="pic4-48">
<blockquote>
<p><strong>Example: LR(1)语法分析过程</strong></p>
<img src="/Course-Compiler-4/pic4-49.png" class="" title="pic4-49">
<img src="/Course-Compiler-4/pic4-50.png" class="" title="pic4-50">
<img src="/Course-Compiler-4/pic4-51.png" class="" title="pic4-51">
</blockquote>
<blockquote>
<p><strong>Tips:</strong> 从直觉上来看,
LR(1)之比LR(0)多"往前看"了一个字符,
这使得其在内层规约上可以获得更多信息,
其原理比起LR(0)并没有太大的变化.</p>
</blockquote>
<h3 id="lalr语法分析">LALR语法分析</h3>
<ul>
<li>SLR(1)语法分析表的分析能力<strong>较弱</strong></li>
<li>LR(1)语法分析表的状态数量<strong>很大</strong></li>
<li>LALR(1)是实践中常用的方法
<ul>
<li>状态数量和SLR(1)的状态数量相同</li>
<li>能够方便地处理大部分常见程序设计语言的构造</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Additional: LR(1)语法分析表的合并</strong></p>
<img src="/Course-Compiler-4/pic4-52.png" class="" title="pic4-52">
</blockquote>
<h4 id="lalr分析技术的基本思想">LALR分析技术的基本思想</h4>
<ul>
<li>寻找具有相同核心的LR(1)项集，并把它们合并成为一个项集
<ul>
<li>项集的核心(core)就是项的第一分量的集合
<ul>
<li><code>I4</code>和<code>I7</code>的核心都是<span
class="math inline">\(\{C \rightarrow d \cdot\}\)</span></li>
<li><code>I3</code>和<code>I6</code>的核心<span
class="math inline">\(\{C \rightarrow c \cdot C, C \rightarrow \cdot cC,
C \rightarrow \cdot d\}\)</span></li>
</ul></li>
<li>一个LR(1)项集的核心是一个LR(0)项集</li>
<li>GOTO(I, X)的核心只由I的核心决定，因此被合并项集的GOTO目标也可以合并
<ul>
<li>这表示合并之后，我们仍可以建立GOTO关系</li>
</ul></li>
</ul></li>
</ul>
<h5 id="合并引起的冲突">合并引起的冲突</h5>
<ul>
<li>原来无冲突的LR(1)分析表在合并之后得到LALR(1)分析表，新表中可能存在冲突
<ul>
<li><strong>合并不会导致移入/归约冲突</strong>
<ul>
<li>假设合并之后在<span
class="math inline">\(a\)</span>上存在移入/归约冲突，即存在项<span
class="math inline">\([B \rightarrow \beta \cdot a \gamma,
_]\)</span>和<span class="math inline">\([A \rightarrow \alpha \cdot,
a]\)</span></li>
<li>因为被合并的项集具有相同的核心，因此被合并的所有项集中都包括<span
class="math inline">\([B \rightarrow \beta \cdot a \gamma,
_]\)</span>，而<span class="math inline">\([A \rightarrow \alpha \cdot,
a]\)</span>也必然在某个项集中，那么这个项集必然已经存在冲突.</li>
</ul></li>
<li><strong>合并会引起归约/归约冲突</strong>，即不能确定按照哪个产生式进行归约</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-53.png" class="" title="pic4-53">
</blockquote>
<h4 id="lalr分析表构造算法">LALR分析表构造算法</h4>
<img src="/Course-Compiler-4/pic4-54.png" class="" title="pic4-54">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-55.png" class="" title="pic4-55">
</blockquote>
<h4 id="lalr分析器和lr分析器">LALR分析器和LR分析器</h4>
<ul>
<li>处理语法正确的输入时，LALR语法分析器和LR语法分析器的<strong>动作序列完全相同</strong>
<ul>
<li>栈中的状态名字不同，但是状态序列之间有对应关系</li>
<li>如果LR分析器压入状态I，那么LALR分析器压入I对应的合并项集</li>
</ul></li>
<li>当处理错误的输入时，LALR可能多执行一些归约动作，但不会多移入一个符号</li>
</ul>
<h4 id="lalr技术本质">LALR技术本质</h4>
<ul>
<li>对LR(1)项集规范族中的同核心项集进行合并
<ul>
<li>使得分析表保持了LR(1)项中的向前看符号信息</li>
<li>又使状态数减少到与SLR分析表的一样多</li>
</ul></li>
</ul>
<h3 id="二义性文法的使用">二义性文法的使用</h3>
<ul>
<li>二义性文法都不是LR的</li>
<li>某些二义性文法是有用的
<ul>
<li>可以简洁地描述某些结构</li>
<li>隔离某些语法结构，对其进行特殊处理</li>
</ul></li>
<li>对于某些二义性文法
<ul>
<li>可以通过消除二义性规则来保证每个句子只有一棵语法分析树</li>
<li>可以在LR分析器中实现这个规则</li>
</ul></li>
</ul>
<h4 id="优先级结合性消除冲突">优先级/结合性消除冲突</h4>
<p><strong>二义性文法:</strong> <span class="math inline">\(E
\rightarrow E + E\ |\ E * E\ |\ (E)\ |\ id\)</span></p>
<p><strong>等价语法:</strong> <span class="math inline">\(E \rightarrow
E + T\ |\ T,\ T \rightarrow T * F\ |\ F,\ F \rightarrow (E)\ |\
id\)</span></p>
<ul>
<li><strong>二义性文法的优点</strong>
<ul>
<li>容易修改算符的优先级和结合性</li>
<li><strong>简洁:</strong>
如果有多个优先级，那么无二义性文法将引入太多的非终结符号</li>
<li><strong>高效:</strong> 不需要处理像<span class="math inline">\(E
\rightarrow T\)</span>这样的归约</li>
</ul></li>
</ul>
<h4 id="二义性表达式文法的lr0项集">二义性表达式文法的LR(0)项集</h4>
<img src="/Course-Compiler-4/pic4-56.png" class="" title="pic4-56">
<ul>
<li><strong>冲突的原因以及解决</strong>
<ul>
<li>当栈顶状态为7时，表明
<ul>
<li>栈中状态序列对应的文法符号序列为：… E + E</li>
<li>如果下一个符号为+或*，移入还是归约？</li>
</ul></li>
<li>如果*的优先级大于+，且+是左结合的
<ul>
<li>下一个符号为*时，我们应该移入*</li>
<li>下一个符号为+时，我们应该将E + E归约为E</li>
</ul></li>
</ul></li>
</ul>
<img src="/Course-Compiler-4/pic4-57.png" class="" title="pic4-57">
<h4 id="悬空else的二义性">悬空else的二义性</h4>
<img src="/Course-Compiler-4/pic4-58.png" class="" title="pic4-58">
<h2 id="语法错误的处理">语法错误的处理</h2>
<ul>
<li>错误难以避免，编译器需要有处理错误的能力</li>
<li>程序中可能存在不同层次的错误
<ul>
<li>词法错误、语法错误、语义错误、逻辑错误</li>
</ul></li>
<li>语法分析器中错误处理程序的设计目标
<ul>
<li>清晰准确地报告出现的错误，并指出错误的位置</li>
<li>能从当前错误中恢复，以继续检测后面的错误</li>
<li>尽可能地减少开销</li>
</ul></li>
</ul>
<h3 id="预测分析中的错误恢复">预测分析中的错误恢复</h3>
<ul>
<li><strong>错误恢复</strong>
<ul>
<li>当预测分析器报错时，表示输入的串不是句子</li>
<li>使用者希望预测分析器能够进行恢复处理后继续语法分析过程，以便在一次分析中找到更多的语法错误</li>
<li>可能恢复得并不成功，之后找到的语法错误是假的</li>
<li>进行错误恢复时可用的信息：栈里面的符号、待分析的符号</li>
</ul></li>
<li><strong>两类错误恢复方法</strong>
<ul>
<li>恐慌模式、短语层次的恢复</li>
</ul></li>
</ul>
<h4 id="恐慌模式">恐慌模式</h4>
<img src="/Course-Compiler-4/pic4-59.png" class="" title="pic4-59">
<h5 id="同步词法单元的确定">同步词法单元的确定</h5>
<img src="/Course-Compiler-4/pic4-60.png" class="" title="pic4-60">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-4/pic4-61.png" class="" title="pic4-61">
<img src="/Course-Compiler-4/pic4-62.png" class="" title="pic4-62">
</blockquote>
<h4 id="短语层次的恢复">短语层次的恢复</h4>
<ul>
<li>在预测语法分析表的空白条目中插入<strong>错误处理例程</strong>的函数指针
<ul>
<li>例程可以改变、插入或删除输入中的符号，并发出适当的错误消息</li>
</ul></li>
</ul>
<h4 id="lr语法分析中的错误恢复">LR语法分析中的错误恢复</h4>
<ul>
<li>查询ACTION表时可能发现报错条目
<ul>
<li>假设栈中的符号串为<span
class="math inline">\(\alpha\)</span>，当前输入符号为<span
class="math inline">\(a\)</span>，报错表示不可能存在终结符号串<span
class="math inline">\(x\)</span>使得<span class="math inline">\(\alpha
ax\)</span>是一个最右句型</li>
</ul></li>
<li><strong>恐慌模式的错误恢复策略</strong>
<ul>
<li>从栈顶向下扫描，找到状态s，s有一个对应于某个非终结符号A的GOTO目标(s之上的状态被丢弃)</li>
<li>在输入中丢弃一些符号，直到一个可以跟在A之后的符号b(不丢弃b)，并将GOTO(s,
A)压栈，继续进行分析</li>
<li><strong>基本思想:</strong>
假定当前试图归约到A但碰到了语法错误，因此设法扫描完包含语法错误的A的子串，假装找到了A的一个实例</li>
</ul></li>
<li>短语层次的恢复
<ul>
<li>检查LR分析表中的每个报错条目，根据语言的特性来确定程序员最可能犯了什么错误，然后构造适当的恢复程序</li>
</ul></li>
</ul>
<h3 id="语法分析器生成工具yacc">语法分析器生成工具Yacc</h3>
<img src="/Course-Compiler-4/pic4-63.png" class="" title="pic4-63">
<h4 id="yacc源程序的结构">Yacc源程序的结构</h4>
<img src="/Course-Compiler-4/pic4-64.png" class="" title="pic4-64">
<h4 id="yacc中的冲突处理">Yacc中的冲突处理</h4>
<ul>
<li><strong>缺省处理方法</strong>
<ul>
<li>归约/移入冲突：总是移入(悬空else的解决)</li>
<li>归约/归约冲突：选择列在前面的产生式</li>
<li>选项-v可在文件y.output中看到冲突的描述和解决方法</li>
</ul></li>
<li>通过确定终结符号的优先级/结合性来解决冲突
<ul>
<li>结合性：%left, %right, %nonassoc</li>
<li>移入a/按<code>A-&gt;α</code>归约：比较a和<code>A-&gt;α</code>的优先级再选择
<ul>
<li>终结符号的优先级按在声明部分的出现顺序而定</li>
<li>产生式的优先级设为它最右的终结符号的优先级，也可以加标记<code>%prec&lt;终结符号&gt;</code>，指明产生式的优先级等同于该终结符号</li>
</ul></li>
</ul></li>
</ul>
<h4 id="yacc的错误恢复">Yacc的错误恢复</h4>
<ul>
<li>使用错误产生式来完成语法错误恢复
<ul>
<li>错误产生式<code>A-&gt;error α</code></li>
<li>例如：<code>stmt→error</code></li>
</ul></li>
<li>定义哪些非终结符号有错误恢复动作
<ul>
<li>比如：表达式、语句、块、函数定义等非终结符号</li>
</ul></li>
<li>当语法分析器遇到错误时
<ul>
<li>不断弹出栈中状态，直到栈顶状态包含项<span
class="math inline">\(A\rightarrow \cdot error \ \alpha\)</span></li>
<li>分析器将error移入栈中</li>
<li>如果<span
class="math inline">\(\alpha\)</span>为空，分析器直接执行归约，并调用相关的语义动作；否则跳过一些符号，找到可以归约为<span
class="math inline">\(\alpha\)</span>的串为止</li>
</ul></li>
</ul>
<h2 id="后记">后记</h2>
<p>语法分析这一章节实在是知识点过于琐碎, 难度过高,
其中部分内容仅是囫囵扫过, 待日后再回来学习吧.</p>
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch7 运行时刻环境</title>
    <url>/Course-Compiler-7/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch07
Runtime Environments.</strong></p>
<span id="more"></span>
<h2 id="运行时刻环境">运行时刻环境</h2>
<ul>
<li><strong>运行时刻环境</strong>
<ul>
<li>为数据分配安排存储位置</li>
<li>确定访问变量时使用的机制</li>
<li>过程之间的连接、参数传递</li>
<li>和操作系统、输入输出设备相关的其它接口</li>
</ul></li>
<li><strong>主题</strong>
<ul>
<li>存储管理：栈分配、堆管理、垃圾回收</li>
<li>对变量、数据的访问</li>
</ul></li>
</ul>
<h2 id="存储分配的典型方式">存储分配的典型方式</h2>
<ul>
<li>目标程序的代码放置在代码区</li>
<li>静态区、堆区、栈区分别放置不同类型生命期的数据值</li>
</ul>
<blockquote>
<p><strong>Example:</strong> C++内存模型</p>
<img src="/Course-Compiler-7/pic7-1.png" class="" title="pic7-1">
</blockquote>
<h3 id="静态和动态存储分配">静态和动态存储分配</h3>
<ul>
<li><strong>静态分配</strong>
<ul>
<li>编译器在编译时刻就可以做出存储分配决定，不需要考虑程序运行时刻的情形</li>
<li>全局常量、全局变量</li>
</ul></li>
<li><strong>动态分配</strong>
<ul>
<li><strong>栈式存储</strong>：和过程的调用/返回同步进行分配和回收，值的生命期与过程生命期相同</li>
<li><strong>堆存储</strong>：数据对象可比创建它的过程调用更长寿
<ul>
<li>手工进行回收</li>
<li>垃圾回收机制</li>
</ul></li>
</ul></li>
</ul>
<h3 id="栈式分配">栈式分配</h3>
<ul>
<li>活动树</li>
<li>活动记录</li>
<li>调用代码序列</li>
<li>栈中的变长数据</li>
</ul>
<h4 id="活动树">活动树</h4>
<ul>
<li>过程调用(过程活动)在时间上总是嵌套的
<ul>
<li>后调用的先返回</li>
<li>因此用栈来分配过程活动所需内存空间</li>
</ul></li>
<li><strong>活动树(Activation Tree)</strong>
<ul>
<li>表示程序运行期间的所有过程活动</li>
<li>每个结点对应于一个过程活动</li>
<li>根结点对应于main过程的活动</li>
<li>过程p的某次活动对应的结点的所有子结点
<ul>
<li>表示此次活动所调用的各个过程活动</li>
<li>从左向右，表示调用的先后顺序</li>
</ul></li>
<li>又称为<strong>调用树(Call Tree)</strong></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-7/pic7-2.png" class="" title="pic7-2">
</blockquote>
<h4 id="活动记录">活动记录</h4>
<img src="/Course-Compiler-7/pic7-3.png" class="" title="pic7-3">
<blockquote>
<p><strong>Example: 运行时刻栈</strong></p>
<img src="/Course-Compiler-7/pic7-4.png" class="" title="pic7-4">
</blockquote>
<h5 id="活动记录的布局原则">活动记录的布局原则</h5>
<img src="/Course-Compiler-7/pic7-5.png" class="" title="pic7-5">
<h4 id="调用返回代码序列">调用/返回代码序列</h4>
<ul>
<li><strong>调用代码序列(Calling
Sequence)</strong>为活动记录分配空间，填写记录中的信息</li>
<li><strong>返回代码序列(Return
Sequence)</strong>恢复机器状态，使调用者继续运行</li>
<li>调用代码序列会分割到调用者和被调用者中
<ul>
<li>根据源语言、目标机器和操作系统的限制，可以有不同的分割方案</li>
<li>把代码尽可能放在被调用者中</li>
</ul></li>
</ul>
<h5 id="调用返回代码序列的要求">调用/返回代码序列的要求</h5>
<ul>
<li><strong>数据方面</strong>
<ul>
<li>能够把参数正确地传递给被调用者</li>
<li>能够把返回值传递给调用者</li>
</ul></li>
<li><strong>控制方面</strong>
<ul>
<li>能够正确转到被调用过程的代码开始位置</li>
<li>能够正确转回调用者的调用位置(的下一条指令)</li>
</ul></li>
<li>调用代码序列与活动记录的布局相关(见<a
href="#活动记录的布局原则"><strong>[活动记录的布局原则]</strong></a>)</li>
</ul>
<h5 id="call-return">Call &amp; Return</h5>
<ul>
<li><strong>Calling Sequence</strong>
<ul>
<li>调用者计算实在参数的值</li>
<li>将返回地址和原<code>top_sp</code>存放到被调用者的活动记录中；调用者增加<code>top_sp</code>的值(越过了调用者的局部数据和临时变量、以及被调用者的参数和机器状态字段)</li>
<li>被调用者保存寄存器值和其它状态字段</li>
<li>被调用者初始化局部数据，开始运行</li>
</ul></li>
<li><strong>Return Sequence</strong>
<ul>
<li>被调用者将返回值放到与参数相邻的位置</li>
<li>被调用者恢复<code>top_sp</code>和其它寄存器，跳转到返回地址</li>
</ul></li>
</ul>
<blockquote>
<p><strong>调用者/被调用者活动记录</strong></p>
<img src="/Course-Compiler-7/pic7-6.png" class="" title="pic7-6">
</blockquote>
<h4 id="栈中的变长数据">栈中的变长数据</h4>
<img src="/Course-Compiler-7/pic7-7.png" class="" title="pic7-7">
<h3 id="栈式运行过程">栈式运行过程</h3>
<h4 id="非局部数据的访问无嵌套过程">非局部数据的访问(无嵌套过程)</h4>
<ul>
<li>C语言中，每个函数能访问的变量
<ul>
<li><strong>函数的局部变量:</strong>
相对地址已知，且存放在当前活动记录内，<code>top_sp</code>指针加上相对地址即可访问</li>
<li><strong>全局变量:</strong> 在静态区，地址在编译时刻可知</li>
</ul></li>
<li>很容易将C语言的函数作为参数进行传递
<ul>
<li>参数中只需包括函数代码的开始地址</li>
<li>在函数中访问非局部变量的模式很简单，不需要考虑过程是如何激活的</li>
</ul></li>
</ul>
<h4 id="非局部数据的访问有嵌套过程">非局部数据的访问(有嵌套过程)</h4>
<ul>
<li>PASCAL中，如果过程A的声明中包含了过程B的声明，那么B可以使用在A中声明的变量</li>
<li>当B的代码运行时，如果它使用的是A中的变量，必须通过<strong>访问链</strong>访问</li>
</ul>
<img src="/Course-Compiler-7/pic7-8.png" class="" title="pic7-8">
<h5 id="嵌套深度">嵌套深度</h5>
<img src="/Course-Compiler-7/pic7-9.png" class="" title="pic7-9">
<h4 id="访问链">访问链</h4>
<ul>
<li><strong>访问链(Access Link)</strong>被用于访问非局部的数据
<ul>
<li>如果过程p在声明时(直接)嵌套在过程q中，那么p活动记录中的访问链指向上层最近的q的活动记录</li>
<li>从栈顶活动记录开始，访问链形成了一个链路，嵌套深度沿着链路逐一递减</li>
</ul></li>
<li>设深度为<span class="math inline">\(n_p\)</span>的过程<span
class="math inline">\(p\)</span>访问变量<span
class="math inline">\(x\)</span>，而变量<span
class="math inline">\(x\)</span>在深度为<span
class="math inline">\(n_q\)</span>的过程<span
class="math inline">\(q\)</span>中声明
<ul>
<li><span class="math inline">\(n_p – n_q\)</span>在编译时刻已知:
从当前活动记录出发, 沿访问链前进<span
class="math inline">\(n_p–n_q\)</span>次找到活动记录</li>
<li><span
class="math inline">\(x\)</span>相对于这个活动记录的偏移量在编译时刻已知</li>
</ul></li>
</ul>
<h5 id="访问链的维护">访问链的维护</h5>
<img src="/Course-Compiler-7/pic7-10.png" class="" title="pic7-10">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-7/pic7-11.png" class="" title="pic7-11">
</blockquote>
<h6 id="过程指针型参数">过程指针型参数</h6>
<img src="/Course-Compiler-7/pic7-12.png" class="" title="pic7-12">
<h4 id="显示表">显示表</h4>
<ul>
<li>用访问链访问数据，访问开销与嵌套深度差有关
<ul>
<li>使用显示表可以提高效率，访问开销为常量</li>
</ul></li>
<li><strong>显示表(display):</strong> 为每个嵌套深度保留一个指针
<ul>
<li>指针<code>d[i]</code>指向栈中最近的、嵌套深度为<code>i</code>的活动记录</li>
<li>如果过程<code>p</code>访问嵌套深度为<code>i</code>的过程<code>q</code>中声明的变量<code>x</code>，那么<code>d[i]</code>直接指向相应的活动记录(<code>i</code>在编译时刻已知)</li>
</ul></li>
<li><strong>显示表的维护</strong>
<ul>
<li>调用过程<code>p</code>时，在<code>p</code>的活动记录中保存<code>d[n_p]</code>的值，并将<code>d[n_p]</code>设置为当前活动记录(即<code>p</code>)</li>
<li>从<code>p</code>返回时，恢复<code>d[n_p]</code>的值</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-7/pic7-13.png" class="" title="pic7-13">
</blockquote>
<h4 id="非局部变量的作用域">非局部变量的作用域</h4>
<ul>
<li><strong>静态作用域(Static Scoping)</strong>
<ul>
<li>又称词法作用域(Lexical Scoping)</li>
<li>根据函数声明时的位置寻找变量定义(静态时决定)</li>
<li>优点：程序行为易于推理</li>
</ul></li>
<li><strong>动态作用域(Dynamic Scoping)</strong>
<ul>
<li>根据函数运行时的上下文寻找变量定义(动态时决定)</li>
<li>优点：易于实现</li>
</ul></li>
</ul>
<h4 id="闭包">闭包</h4>
<img src="/Course-Compiler-7/pic7-14.png" class="" title="pic7-14">
<h3 id="堆管理">堆管理</h3>
<ul>
<li><strong>堆空间</strong>
<ul>
<li>用于存放生命周期不确定、或生存到被明确删除为止的数据对象</li>
<li>例如：<code>new</code>生成的对象可以生存到被<code>delete</code>为止，<code>malloc</code>申请的空间生存到被<code>free</code>为止</li>
</ul></li>
<li><strong>存储管理器(Memory Manager)</strong>
<ul>
<li>分配/回收堆区空间的子系统</li>
<li>根据语言而定
<ul>
<li>C/C++需要手动回收空间</li>
<li>Java可以自动回收空间(垃圾收集)</li>
</ul></li>
</ul></li>
</ul>
<h4 id="存储管理器">存储管理器</h4>
<ul>
<li>基本功能
<ul>
<li><strong>分配:</strong> 为内存请求分配一段连续、适当大小的堆空间
<ul>
<li>首先从空闲的堆空间分配</li>
<li>如果不行则从操作系统中获取内存、增加堆空间</li>
</ul></li>
<li><strong>回收:</strong>
把被回收的空间返回空闲空间缓冲池，以满足其它内存需求</li>
</ul></li>
<li>评价存储管理器的特性
<ul>
<li><strong>空间效率:</strong> 使程序需要的堆空间最小，即减小碎片</li>
<li><strong>程序效率:</strong> 运用内存系统的层次，使程序运行更快</li>
<li><strong>低开销:</strong> 使分配/收回内存的操作尽可能高效</li>
</ul></li>
</ul>
<blockquote>
<p><strong>计算机存储层次结构(Memory Hierarchy)</strong></p>
<img src="/Course-Compiler-7/pic7-15.png" class="" title="pic7-15">
</blockquote>
<h4 id="程序局部性">程序局部性</h4>
<ul>
<li>程序具有高度的局部性(locality)
<ul>
<li><strong>时间局部性:</strong>
一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问</li>
<li><strong>空间局部性:</strong>
被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问</li>
</ul></li>
<li>90%的时间用来执行10%的代码</li>
<li>局部性这一特性恰好可以充分利用计算机的存储层次结构</li>
</ul>
<h4 id="堆空间的碎片问题">堆空间的碎片问题</h4>
<ul>
<li>随着程序分配/回收内存，堆区逐渐被割裂成为若干空闲存储块(窗口)和已用存储块的交错</li>
<li>分配一块内存时，通常是把一个窗口的一部分分配出去，其余部分成为更小的块</li>
<li>回收时，被释放的存储块被放回缓冲池；通常要把连续的窗口接合成为更大的窗口</li>
</ul>
<img src="/Course-Compiler-7/pic7-16.png" class="" title="pic7-16">
<h4 id="堆空间分配方法">堆空间分配方法</h4>
<ul>
<li><strong>Best-fit</strong>
<ul>
<li>总是将请求的内存分配在满足请求的最小的窗口中</li>
<li>好处：可以将大的窗口保留下来，应对更大的请求</li>
<li>坏处：慢 + 碎片</li>
</ul></li>
<li><strong>First-fit</strong>
<ul>
<li>总是将对象放置在第一个能够容纳请求的窗口中</li>
<li>放置对象时花费时间较少，但是总体性能较差(破坏性)</li>
<li>通常具有较好的<strong>数据局部性</strong>:
同一时间段内生成的对象经常被分配在连续的空间内</li>
</ul></li>
</ul>
<h5 id="使用容器的堆管理方法">使用容器的堆管理方法</h5>
<ul>
<li>设定不同大小的块规格，相同的块放入同一容器</li>
<li>较小的(较常用的) 尺寸设置较多的容器</li>
<li>GNU的C编译器gcc中使用的存储管理器Lea
<ul>
<li><strong>空闲块的大小</strong>
<ul>
<li>16, 24, 32, 40, ... , 512: 容器大小为8字节整数倍</li>
<li>大于512的按对数划分：每个容器大小是前一容器的两倍</li>
<li>荒野块(wilderness chunk):可以扩展的内存块</li>
</ul></li>
<li><strong>分配方法</strong>
<ul>
<li>小尺寸的请求，直接在相应容器中找</li>
<li>大尺寸的请求，在适当的容器中寻找适当的空闲块</li>
<li>可能需要分割内存块，可能需要从荒野块中分割</li>
</ul></li>
</ul></li>
</ul>
<h5 id="管理和接合空闲空间">管理和接合空闲空间</h5>
<ul>
<li>当回收一个块时，可以把这个块和相邻的块接合起来，构成更大的块</li>
<li>支持相邻块接合的数据结构
<ul>
<li><strong>边界标记:</strong>
在每个存储块的两端，分别设置一个<code>free/used</code>位，并在相邻的位置上存放字节总数</li>
<li>双重链接的空闲块列表：列表的指针存放在空闲块中、用双向指针的方式记录了有哪些空闲块</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-7/pic7-17.png" class="" title="pic7-17">
</blockquote>
<h4 id="处理手工存储管理">处理手工存储管理</h4>
<ul>
<li><strong>内存泄露(memory-leak):</strong>
未能删除不可能再被引用的数据</li>
<li><strong>悬空指针引用(dangling-pointer-dereference):</strong>
引用已被删除的数据</li>
<li><strong>访问非法地址:</strong> 空指针访问/数组越界访问</li>
</ul>
<h3 id="垃圾回收">垃圾回收</h3>
<ul>
<li><strong>垃圾</strong>
<ul>
<li>广义：不需要再被引用的数据</li>
<li>狭义：不能被引用(不可达)的数据</li>
</ul></li>
<li><strong>垃圾回收</strong>
<ul>
<li>自动回收不可达数据的机制，解除了程序员的负担</li>
<li>使用的语言：Lisp、Java、C#、ML、Python、Prolog、Smalltalk</li>
</ul></li>
</ul>
<h4 id="垃圾回收器的设计目标">垃圾回收器的设计目标</h4>
<ul>
<li>基本要求(静态或动态确定数据的类型)
<ul>
<li>语言必须<strong>类型安全(typesafe):</strong>
保证回收器能够知道数据元素是否为一个指向某内存块的指针</li>
<li>类型不安全(unsafe)的语言: C/C++</li>
</ul></li>
<li>性能目标:
<ul>
<li><strong>总体运行时间:</strong> 不显著增加应用程序的总运行时间</li>
<li><strong>停顿时间:</strong>
当垃圾回收机制启动时，可能引起应用程序的停顿，这个停顿应该比较短</li>
<li><strong>空间使用:</strong> 最大限度地利用可用内存</li>
<li><strong>程序局部性:</strong> 改善空间局部性和时间局部性</li>
</ul></li>
</ul>
<h4 id="可达性">可达性</h4>
<ul>
<li><strong>可达性</strong>就是指一个存储块可以被程序访问到</li>
<li><strong>根集:</strong> 不需要指针解引用就可以直接访问的数据
<ul>
<li>Java：静态成员、栈中变量</li>
</ul></li>
<li><strong>可达性</strong>
<ul>
<li>根集的成员都是可达的</li>
<li>对于任意一个对象，如果指向它的一个指针被保存在可达对象的某字段或数组元素中，那么这个对象也是可达的</li>
</ul></li>
<li><strong>性质</strong>
<ul>
<li>一旦一个对象变得不可达，它就不会再变成可达的</li>
</ul></li>
</ul>
<h5 id="改变可达对象集合的操作">改变可达对象集合的操作</h5>
<ul>
<li><strong>对象分配:</strong> 返回一个指向新存储块的引用</li>
<li><strong>参数传递/返回值:</strong>
对象引用从实参传递到形参，从返回值传递给调用者</li>
<li><strong>引用赋值 u = v :</strong>
v的引用被复制到u中，u中原有引用丢失；使u原来指向的对象变得不可达，并递归使更多对象变得不可达</li>
<li><strong>过程返回:</strong>
活动记录出栈，局部变量消失，根集变小，使一些对象变得不可达</li>
</ul>
<h3 id="垃圾回收方法">垃圾回收方法</h3>
<ul>
<li>引用计数垃圾回收(关注不可达)
<ul>
<li>跟踪相关操作，捕获对象变得不可达的时刻，回收对象占用的空间</li>
</ul></li>
<li>传递地跟踪所有的引用(关注可达)
<ul>
<li>在需要时，标记出所有可达对象，回收其它对象</li>
</ul></li>
</ul>
<h4 id="基于引用计数的垃圾回收器">基于引用计数的垃圾回收器</h4>
<ul>
<li>每个对象有一个用于存放引用计数的字段，并按如下方式维护
<ul>
<li><strong>对象分配:</strong> 引用计数设为1</li>
<li><strong>参数传递:</strong> 引用计数加1</li>
<li><strong>引用赋值:</strong>
<code>u = v</code>，u指向的对象引用减1，v指向的对象引用加1</li>
<li><strong>过程返回:</strong> 局部变量指向对象的引用计数减1</li>
</ul></li>
<li>如果一个对象的引用计数为0，在删除对象之前，此对象中各个指针所指对象的引用计数减1</li>
<li>开销较大，但不会引起停顿，也能及时回收垃圾</li>
</ul>
<blockquote>
<p><strong>Example: 引用计数</strong></p>
<img src="/Course-Compiler-7/pic7-18.png" class="" title="pic7-18">
</blockquote>
<blockquote>
<p><strong>Example: 循环垃圾</strong></p>
<img src="/Course-Compiler-7/pic7-19.png" class="" title="pic7-19">
</blockquote>
<h4 id="基于跟踪的垃圾回收">基于跟踪的垃圾回收</h4>
<p>不在垃圾产生时回收，而是周期性地运行</p>
<ul>
<li>标记-清扫式垃圾回收</li>
<li>标记-拷贝式垃圾回收</li>
<li>标记-整理式垃圾回收</li>
<li>分代式垃圾回收</li>
</ul>
<blockquote>
<p><strong>存储块抽象分类</strong></p>
<img src="/Course-Compiler-7/pic7-30.png" class="" title="pic7-30">
</blockquote>
<h5 id="标记-清扫式垃圾回收">标记-清扫式垃圾回收</h5>
<img src="/Course-Compiler-7/pic7-20.png" class="" title="pic7-20">
<img src="/Course-Compiler-7/pic7-21.png" class="" title="pic7-21">
<img src="/Course-Compiler-7/pic7-22.png" class="" title="pic7-22">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-7/pic7-28.png" class="" title="pic7-28">
</blockquote>
<h5 id="标记-复制式垃圾回收">标记-复制式垃圾回收</h5>
<img src="/Course-Compiler-7/pic7-23.png" class="" title="pic7-23">
<img src="/Course-Compiler-7/pic7-24.png" class="" title="pic7-24">
<h5 id="标记-整理式垃圾回收">标记-整理式垃圾回收</h5>
<img src="/Course-Compiler-7/pic7-25.png" class="" title="pic7-25">
<img src="/Course-Compiler-7/pic7-26.png" class="" title="pic7-26">
<h5 id="垃圾回收算法比较">垃圾回收算法比较</h5>
<ul>
<li><strong>标记-清扫式垃圾回收</strong>
<ul>
<li>回收效率不高，易造成碎片</li>
</ul></li>
<li><strong>标记-复制式垃圾回收</strong>
<ul>
<li>将可达对象复制到预留半区，只需遍历可达对象</li>
<li>管理区域内大部分对象为垃圾对象时效率高(只需移动少量可达对象)，反之则效率低</li>
</ul></li>
<li><strong>标记-整理式垃圾回收</strong>
<ul>
<li>将可达对象移动到堆区的一端，需遍历整个区域</li>
<li>管理区域内大部分对象为可达对象时效率高(经过之前的整理、大部分对象已经到位)，反之则效率低</li>
</ul></li>
</ul>
<h5 id="分代式垃圾回收">分代式垃圾回收</h5>
<img src="/Course-Compiler-7/pic7-27.png" class="" title="pic7-27">
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch9 机器无关优化</title>
    <url>/Course-Compiler-9/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch09
Machine-Free Optimization.</strong></p>
<span id="more"></span>
<blockquote>
<p><strong>Tips:</strong></p>
<p>强烈建议修习李樾和谭添老师开设的《静态分析》课程.
该部分的理论知识更贴近于静态分析的内容, 因此本笔记会略去相关内容.</p>
<p><strong>课程链接</strong> <a
href="https://tai-e.pascal-lab.net/lectures.html"
class="uri">https://tai-e.pascal-lab.net/lectures.html</a></p>
</blockquote>
<h2 id="引言">引言</h2>
<ul>
<li>代码优化或者代码改进
<ul>
<li>在目标代码中消除不必要的指令</li>
<li>把一个指令序列替换为一个完成相同功能的更快的指令序列</li>
</ul></li>
<li>全局优化
<ul>
<li>具体的优化实现基于数据流分析技术</li>
<li>用以收集程序相关信息的算法</li>
</ul></li>
</ul>
<h3 id="优化的主要来源">优化的主要来源</h3>
<ul>
<li>编译器只能通过一些相对低层的语义等价转换来优化代码
<ul>
<li><strong>冗余运算的原因</strong>
<ul>
<li>源程序中的冗余</li>
<li>高级程序设计语言编程的副产品，如<code>A[i][j].f = 0; A[i][j].k = 1;</code></li>
</ul></li>
<li><strong>语义不变的优化</strong>
<ul>
<li>公共子表达式消除</li>
<li>复制传播</li>
<li>死代码消除</li>
<li>常量折叠</li>
</ul></li>
</ul></li>
</ul>
<h2 id="基本优化技术">基本优化技术</h2>
<h3 id="控制流图">控制流图</h3>
<ul>
<li><strong>控制流图(Control Flow Graph)</strong>
<ul>
<li>表示程序控制流的有向图(简称流图)</li>
<li>流图的结点是基本块</li>
<li>流图的边指明了哪些基本块可以跟在一个基本块之后运行
<ul>
<li>若基本块<code>Bi</code>最后一条指令执行后紧跟着执行的指令可能为基本块<code>Bj</code>，则图上有一条边<code>Bi -&gt; Bj</code></li>
</ul></li>
<li>图上的路径表示程序执行的路径，可作为优化与分析的基础
<ul>
<li>它给出了程序的控制流</li>
<li>可以根据流图了解到一个值是否会被使用等信息</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Exmaple:</strong></p>
<img src="/Course-Compiler-9/pic9-1.png" class="" title="pic9-1">
</blockquote>
<h3 id="全局公共子表达式">全局公共子表达式</h3>
<ul>
<li><strong>公共子表达式(Common Subexpression)</strong>
<ul>
<li>在某次出现之前必然已被计算过</li>
<li>E的运算分量在该次计算之后没有被改变</li>
</ul></li>
<li>如果上次公共子表达式E值赋给了x，且x值没有被修改过，那么我们可使用x，而无需计算E</li>
</ul>
<blockquote>
<p><strong>Example</strong></p>
<img src="/Course-Compiler-9/pic9-2.png" class="" title="pic9-2">
</blockquote>
<h3 id="复制传播">复制传播</h3>
<img src="/Course-Compiler-9/pic9-3.png" class="" title="pic9-3">
<blockquote>
<p><strong>Example</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = t3</span><br><span class="line">a[t4] = x</span><br></pre></td></tr></table></figure>
<p>可以被优化为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = t3</span><br><span class="line">a[t4] = t3</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="死代码消除">死代码消除</h3>
<img src="/Course-Compiler-9/pic9-4.png" class="" title="pic9-4">
<h3 id="代码移动">代码移动</h3>
<ul>
<li>循环中的代码会被执行很多次
<ul>
<li><strong>循环不变表达式:</strong>
循环的同一次运行的不同迭代中，表达式的值不变</li>
</ul></li>
<li>把循环不变表达式移动到循环入口之前计算可以提高效率
<ul>
<li><strong>循环入口:</strong> 进入循环的跳转都以这个入口为目标</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong>
<code>while (i &lt;= limit – 2)&#123;...&#125;</code></p>
<p>如果<code>limit</code>在循环体内不会改变,
则可在循环外计算<code>limit - 2</code></p>
<p>可以优化为<code>t = limit - 2; while(i &lt;= t)&#123;...&#125;</code></p>
</blockquote>
<h3 id="归纳变量和强度消减">归纳变量和强度消减</h3>
<img src="/Course-Compiler-9/pic9-5.png" class="" title="pic9-5">
<h2 id="数据流分析">数据流分析</h2>
<p>本处略, 参见静态分析中的数据流分析</p>
<p><a href="https://cs.nju.edu.cn/tiantan/software-analysis/DFA-AP.pdf"
class="uri">https://cs.nju.edu.cn/tiantan/software-analysis/DFA-AP.pdf</a></p>
<p><a href="https://cs.nju.edu.cn/tiantan/software-analysis/DFA-FD.pdf"
class="uri">https://cs.nju.edu.cn/tiantan/software-analysis/DFA-FD.pdf</a></p>
<h2 id="部分冗余消除">部分冗余消除</h2>
<h3 id="懒惰代码移动">懒惰代码移动</h3>
<ul>
<li><strong>目标</strong>
<ul>
<li>所有不复制代码就可消除的冗余计算都被消除</li>
<li>优化后的代码不会执行原程序中不执行的任何计算</li>
<li>表达式的计算应该<strong>尽量靠后</strong>，以利于寄存器的分配</li>
</ul></li>
<li><strong>冗余消除</strong>
<ul>
<li>完全冗余</li>
<li>部分冗余：在流图中放置表达式<code>x + y</code>的拷贝，使得某处的<code>x + y</code>成为完全冗余，从而删除</li>
</ul></li>
<li><strong>基本步骤</strong>
<ol type="1">
<li>找出各程序点上预期执行的所有表达式</li>
<li>在表达式被预期执行但是不可用的程序点上，放置表达式的计算</li>
<li>把表达式尽量后延到某个程序点，在到达这个点的所有路径上，这个表达式在这个程序点之前被预期执行，但是还没有使用这个值</li>
<li>消除只使用一次的临时变量</li>
</ol></li>
</ul>
<h4 id="预期执行表达式">预期执行表达式</h4>
<img src="/Course-Compiler-9/pic9-6.png" class="" title="pic9-6">
<img src="/Course-Compiler-9/pic9-7.png" class="" title="pic9-7">
<h4 id="可用表达式">可用表达式</h4>
<ul>
<li>和前面的可用表达式类似，但假设代码已经被复制到了预期执行点上</li>
<li>表达式在基本块的出口处<strong>可用(available)</strong>的条件
<ul>
<li>在基本块的入口处可用，或在基本块的入口处的预期执行表达式中</li>
<li>且没有被这个基本块杀死</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Exmaple:</strong></p>
<img src="/Course-Compiler-9/pic9-8.png" class="" title="pic9-8">
</blockquote>
<h4 id="可后延表达式">可后延表达式</h4>
<img src="/Course-Compiler-9/pic9-9.png" class="" title="pic9-9">
<blockquote>
<p><strong>Tips:</strong></p>
<p>粗略地说，一个表达式将被放置在边界上，即一个表达式从可后延变成不可后延的地方</p>
</blockquote>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-9/pic9-10.png" class="" title="pic9-10">
</blockquote>
<h4 id="被使用的表达式">被使用的表达式</h4>
<ul>
<li>确定一个被引入的临时变量是否在它所在基本块之外的其它地方<strong>被使用(used)</strong>
<ul>
<li>对表达式的活跃性分析</li>
<li>如果从程序点p出发的一条路径在表达式被重新求值之前使用了该表达式，那么该表达式在点p上被使用</li>
</ul></li>
</ul>
<img src="/Course-Compiler-9/pic9-11.png" class="" title="pic9-11">
<h2 id="流图中的循环">流图中的循环</h2>
<ul>
<li>循环的重要性
<ul>
<li>程序的大部分执行时间都花在循环上</li>
<li>也是数据流分析需要经过若干次迭代的原因</li>
</ul></li>
</ul>
<h3 id="支配结点">支配结点</h3>
<img src="/Course-Compiler-9/pic9-12.png" class="" title="pic9-12">
<h4 id="支配结点树">支配结点树</h4>
<ul>
<li><strong>支配结点树(Dominator Tree)</strong>可以表示支配关系
<ul>
<li>根结点：入口结点</li>
<li>每个结点d支配且只支配树中的后代结点</li>
</ul></li>
<li><strong>直接支配结点(Immediate Dominator)</strong>
<ul>
<li>从入口结点到达<code>n</code>的任何路径(不含<code>n</code>)中，它是路径中最后一个支配<code>n</code>的结点</li>
<li><code>n</code>的直接支配结点<code>m</code>具有如下性质：如果<code>d != n</code>且<code>d dom n</code>，那么<code>d dom m</code></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example: 支配节点树</strong></p>
<img src="/Course-Compiler-9/pic9-13.png" class="" title="pic9-13">
</blockquote>
<h4 id="寻找支配结点算法">寻找支配结点算法</h4>
<img src="/Course-Compiler-9/pic9-14.png" class="" title="pic9-14">
<img src="/Course-Compiler-9/pic9-15.png" class="" title="pic9-15">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-9/pic9-16.png" class="" title="pic9-16">
</blockquote>
<h3 id="深度优先生成树">深度优先生成树</h3>
<ul>
<li><strong>深度优先搜索(Depth-First Search)</strong>
<ul>
<li>搜索过程从入口结点开始，并首先访问离入口结点最远的结点</li>
</ul></li>
<li><strong>深度优先生成树</strong>
<ul>
<li>一个深度优先过程中的搜索路线形成了一个<strong>深度优先生成树(Depth-First
Spanning Tree, DFST)</strong></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-9/pic9-17.png" class="" title="pic9-17">
</blockquote>
<h4 id="深度优先排序">深度优先排序</h4>
<ul>
<li><strong>前序遍历</strong>
<ul>
<li>先访问一个结点，然后从左到右递归地访问该结点的子结点</li>
</ul></li>
<li><strong>后序遍历</strong>
<ul>
<li>首先递归地从左到右访问一个结点的子结点，然后访问该结点</li>
</ul></li>
<li><strong>深度优先排序(Depth-First Ordering)</strong>
<ul>
<li>首先访问一个结点，然后访问该结点的最右子结点，再访问这个子结点左边的子结点，依次类推(与后序遍历的顺序相反)</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-9/pic9-18.png" class="" title="pic9-18">
<p>此处的遍历顺序是对于右边的深度优先生成树来说的</p>
</blockquote>
<h4 id="深度优先排序算法">深度优先排序算法</h4>
<img src="/Course-Compiler-9/pic9-19.png" class="" title="pic9-19">
<h4 id="流图中边的分类">流图中边的分类</h4>
<img src="/Course-Compiler-9/pic9-20.png" class="" title="pic9-20">
<h4 id="回边和可归约性">回边和可归约性</h4>
<img src="/Course-Compiler-9/pic9-21.png" class="" title="pic9-21">
<img src="/Course-Compiler-9/pic9-22.png" class="" title="pic9-22">
<h4 id="流图的深度">流图的深度</h4>
<img src="/Course-Compiler-9/pic9-23.png" class="" title="pic9-23">
<h2 id="自然循环">自然循环</h2>
<ul>
<li>自然循环的性质
<ul>
<li>有一个唯一的入口结点，即<strong>循环头(header)</strong>，这个结点支配循环中的所有结点</li>
<li>必然存在进入循环头的回边</li>
</ul></li>
<li><strong>自然循环(Natural Loop)</strong>的定义
<ul>
<li>给定回边<code>n -&gt; d</code>的自然循环是<code>d</code>，加上不经过<code>d</code>就能够到达<code>n</code>的结点的集合</li>
<li><code>d</code>是这个循环的头</li>
</ul></li>
</ul>
<h3 id="自然循环构造算法">自然循环构造算法</h3>
<img src="/Course-Compiler-9/pic9-24.png" class="" title="pic9-24">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-9/pic9-25.png" class="" title="pic9-25">
</blockquote>
<h3 id="自然循环的性质">自然循环的性质</h3>
<img src="/Course-Compiler-9/pic9-26.png" class="" title="pic9-26">
<h3 id="循环头上头preheader">循环头上头(Preheader)</h3>
<ul>
<li>每个自然循环都有一个循环头header</li>
<li>一些循环相关的优化(如循环不变量移动)需要在循环头之前插入代码</li>
<li>常见做法是在循环头之前插入一个基本块(称为preheader)，用于存放相关的代码</li>
</ul>
<img src="/Course-Compiler-9/pic9-27.png" class="" title="pic9-27">
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>课程笔记-NJU编译原理 Ch8 代码生成</title>
    <url>/Course-Compiler-8/</url>
    <content><![CDATA[<p><strong>NJU-CourseNote: Principles and Techniques of Compilers - Ch08
Code Generation.</strong></p>
<span id="more"></span>
<h2 id="代码生成器的位置">代码生成器的位置</h2>
<ul>
<li>根据中间表示(IR)生成代码</li>
<li>代码生成器之前可能有一个优化组件</li>
<li>代码生成器的三个任务
<ul>
<li><strong>指令选择:</strong> 选择适当的指令实现IR语句</li>
<li><strong>寄存器分配和指派:</strong> 把哪个值放在哪个寄存器中</li>
<li><strong>指令排序:</strong> 按照什么顺序安排指令执行</li>
</ul></li>
</ul>
<img src="/Course-Compiler-8/pic8-1.png" class="" title="pic8-1">
<h2 id="代码生成要解决的问题">代码生成要解决的问题</h2>
<ul>
<li><strong>正确性:</strong> 正确的机器指令</li>
<li>易于实现、测试和维护</li>
<li><strong>输入IR的选择</strong>
<ul>
<li>四元式、三元式、字节代码、堆栈机代码、后缀表示、抽象语法树、DAG图...</li>
</ul></li>
<li>输出
<ul>
<li>RISC(目标机)、CISC(寻址方式)</li>
<li>可重定向代码、汇编语言</li>
</ul></li>
</ul>
<h3 id="目标机模型">目标机模型</h3>
<h4 id="三地址机器模型">三地址机器模型</h4>
<ul>
<li>与三地址码的关键区别: <strong>寄存器</strong>
<ul>
<li>位于CPU内部，用于存放数据的小型高速存储区域</li>
<li>几乎所有CPU计算都需要寄存器参与(存放参数/结果)</li>
<li>几乎所有参与计算的程序数据都位于内存中(使用外存数据也须先读入内存)</li>
<li>机器码需要频繁地在寄存器与内存之间搬运数据</li>
</ul></li>
</ul>
<h4 id="指令">指令</h4>
<ul>
<li><strong>加载:</strong> <code>LD dst, addr</code>,
把地址addr中的内容加载到dst所指的寄存器</li>
<li><strong>保存:</strong> <code>ST x, r</code>,
把寄存器r中的内容保存到x中</li>
<li><strong>计算:</strong> <code>&lt;OP&gt; dst, src1, src2</code>,
把src1和src2中的值运算后将结果存放到dst中</li>
<li><strong>无条件跳转:</strong> <code>BR L</code>,
控制流转向标号L的指令</li>
<li><strong>条件跳转:</strong> <code>B&lt;cond&gt; r, L</code>,
对r中的值进行测试，如果为真则转向L</li>
</ul>
<h3 id="寻址模式">寻址模式</h3>
<ul>
<li><strong>变量x:</strong> 指向分配x的内存位置</li>
<li><strong>a(r):</strong> 地址是a的左值加上寄存器r中的值
<ul>
<li><code>a + r</code></li>
</ul></li>
<li><strong>constant(r):</strong> 寄存器r中内容加上前面的常数即其地址
<ul>
<li><code>constant + r</code></li>
</ul></li>
<li><strong>*r:</strong> 寄存器r的内容所表示的位置上存放的内容位置
<ul>
<li><code>解引用r</code></li>
</ul></li>
<li>*<strong>constant(r):</strong>
寄存器r中内容加上常量所代表的位置上的内容所表示的位置
<ul>
<li><code>解引用(constant + r)</code></li>
</ul></li>
<li><strong>常量#constant</strong></li>
</ul>
<blockquote>
<p><strong>Example: 指令翻译</strong></p>
<img src="/Course-Compiler-8/pic8-2.png" class="" title="pic8-2">
<img src="/Course-Compiler-8/pic8-3.png" class="" title="pic8-3">
<img src="/Course-Compiler-8/pic8-4.png" class="" title="pic8-4">
</blockquote>
<h3 id="程序及指令的代价">程序及指令的代价</h3>
<ul>
<li>不同的目的有不同的度量
<ul>
<li>最短编译时间、运行时间、目标程序大小、能耗</li>
</ul></li>
<li>不可判定一个目标程序是否最优</li>
<li>假设每个指令有固定的代价，设定为1加上运算分量寻址模式的代价
<ul>
<li><code>LD R0, R1</code>：代价为1</li>
<li><code>LD R0, M</code>：代价是2</li>
<li><code>LD R1, *100(R2)</code>：代价为2</li>
</ul></li>
</ul>
<h3 id="目标代码中的地址">目标代码中的地址</h3>
<ul>
<li>如何为过程调用和返回生成代码?
<ul>
<li>静态分配(活动记录)</li>
<li>栈式分配(活动记录)</li>
</ul></li>
<li>如何将IR中的名字(过程名或变量名)转换成为目标代码中的地址?
<ul>
<li>不同区域中的名字采用不同的寻址方式</li>
</ul></li>
</ul>
<h3 id="活动记录的静态分配">活动记录的静态分配</h3>
<ul>
<li>每个过程静态地分配一个数据区域，其开始位置用<strong>staticArea</strong>表示</li>
<li><strong>call callee实现</strong>
<ul>
<li><code>ST callee.staticArea, #here + 20  //存放返回地址</code></li>
<li><code>BR callee.codeArea</code></li>
</ul></li>
<li><strong>callee中的语句return</strong>
<ul>
<li><code>BR *callee.staticArea</code></li>
</ul></li>
</ul>
<img src="/Course-Compiler-8/pic8-5.png" class="" title="pic8-5">
<h3 id="活动记录的栈式分配">活动记录的栈式分配</h3>
<ul>
<li>寄存器SP指向栈顶</li>
<li>第一个过程(main)初始化栈区</li>
<li><strong>过程调用指令序列</strong>
<ul>
<li><code>ADD SP, SP, #caller.recordSize //增大栈指针</code></li>
<li><code>ST 0(SP), #here + 16 //保存返回地址</code></li>
<li><code>BR callee.codeArea //转移到被调用者</code></li>
</ul></li>
<li><strong>返回指令序列</strong>
<ul>
<li><code>BR *0(SP) //被调用者执行，返回调用者</code></li>
<li><code>SUB SP, SP, #caller.recordSize //调用者减小栈指针</code></li>
</ul></li>
</ul>
<img src="/Course-Compiler-8/pic8-6.png" class="" title="pic8-6">
<h3 id="名字的运行时刻地址">名字的运行时刻地址</h3>
<ul>
<li>在三地址语句中使用名字(实际上是指向符号表条目) 来引用变量</li>
</ul>
<blockquote>
<p><strong>Example:</strong> <code>x = 0</code></p>
<p>如果x分配在静态区域，且静态区开始位置为static</p>
<ul>
<li><code>static[12] = 0  LD 112, #0  // static = 100</code></li>
</ul>
<p>如果x分配在栈区，且相对地址为12，则</p>
<ul>
<li><code>LD 12(SP), #0</code></li>
</ul>
</blockquote>
<h2 id="代码生成器">代码生成器</h2>
<ul>
<li>根据三地址指令序列生成机器指令
<ul>
<li>假设每个三地址指令只有一个对应的机器指令</li>
<li>有一组寄存器用于计算基本块内部的值</li>
</ul></li>
<li>主要的目标是减少加载(LD) 和保存(ST)
指令，即最大限度地利用寄存器</li>
<li><strong>寄存器的使用方法</strong>
<ul>
<li>执行运算时，运算分量必须放在寄存器中</li>
<li>存放临时变量</li>
<li>存放全局的值</li>
<li>进行运行时刻管理(比如栈顶指针)</li>
</ul></li>
</ul>
<h3 id="基本思想-数据结构">基本思想 &amp; 数据结构</h3>
<ul>
<li>依次考虑各三地址指令，尽可能把值<strong>保留在寄存器中</strong>，以减少<strong>寄存器/内存</strong>之间的数据交换</li>
<li>为一个三地址指令生成机器指令时
<ul>
<li>只有当运算分量不在寄存器中时，才从内存载入</li>
<li>尽量保证只有当寄存器中值不被使用(称之为不活跃)时，才覆盖掉</li>
</ul></li>
<li><strong>数据结构(编译期)</strong>
<ul>
<li><strong>寄存器描述符:</strong>
跟踪各个寄存器都存放了哪些变量的当前值
<ul>
<li><span class="math inline">\(R_1 \rightarrow \{x\}, R_2 \rightarrow
\{a, b\}\)</span></li>
</ul></li>
<li><strong>地址描述符:</strong>
各个变量的当前值存放在哪些位置(包括内存位置和寄存器) 上
<ul>
<li><span class="math inline">\(x \rightarrow \{R_1\}, a \rightarrow
\{a, R_2\}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="代码生成算法">代码生成算法</h3>
<ul>
<li><strong>重要子函数: getReg(I)</strong>
<ul>
<li>根据寄存器描述符和地址描述符等数据流信息，为三地址指令I选择最佳的寄存器</li>
<li>得到的机器指令的质量依赖于<code>getReg</code>函数选取寄存器的算法</li>
</ul></li>
<li>代码生成算法逐个处理三地址指令</li>
<li><strong>运算语句:</strong> <code>x = y + z</code>
<ul>
<li><code>getReg(x = y + z)</code>为<code>x, y, z</code>选择寄存器<code>Rx, Ry, Rz</code></li>
<li>检查<code>Ry</code>的寄存器描述符，如果<code>y</code>不在<code>Ry</code>中则生成指令
<ul>
<li><code>LD Ry, y' // y'表示存放y值的当前位置</code></li>
<li>类似地确定是否生成<code>LD Rz, z'</code></li>
<li>生成指令<code>ADD Rx, Ry, Rz</code></li>
</ul></li>
</ul></li>
<li><strong>复制语句:</strong> <code>x = y</code>
<ul>
<li><code>getReg(x = y)</code>为<code>x</code>和<code>y</code>选择相同的寄存器(运行后值相同)</li>
<li>如果<code>y</code>不在<code>Ry</code>中，则生成指令<code>LD Ry, y</code></li>
</ul></li>
<li><strong>基本块的收尾</strong>
<ul>
<li>如果变量<code>x</code>活跃，且不在内存中，则生成指令<code>ST x, Rx</code></li>
</ul></li>
<li><strong>代码生成同时更新寄存器和地址描述符</strong>
<ul>
<li>1 处理指令时生成的<code>LD R, x</code>
<ul>
<li><code>R</code>的寄存器描述符：只包含<code>x</code></li>
<li><code>x</code>的地址描述符：<code>R</code>作为新位置加入到<code>x</code>的位置集合中</li>
<li>从任何不同于<code>x</code>的变量的地址描述符中删除<code>R</code></li>
</ul></li>
<li>2 生成的<code>ST x, R</code>
<ul>
<li><code>x</code>的地址描述符：包含自己的内存位置(新增)</li>
</ul></li>
<li>3 <code>ADD Rx, Ry, Rz</code>
<ul>
<li><code>Rx</code>的寄存器描述符：只包含<code>x</code></li>
<li><code>x</code>的地址描述符：只包含<code>Rx</code>(不包含<code>x</code>的内存位置)</li>
<li>从任何不同于<code>x</code>的变量的地址描述符中删除<code>Rx</code></li>
</ul></li>
<li>4 处理<code>x = y</code>时
<ul>
<li>如果生成<code>LD Ry, y</code>，按照规则1处理</li>
<li>把<code>x</code>加入到<code>Ry</code>的寄存器描述符中(即<code>Ry</code>同时存放了<code>x</code>和<code>y</code>的当前值)</li>
<li><code>x</code>的地址描述符：只包含<code>Ry</code>(不包含<code>x</code>的内存位置)</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example: 代码生成示例</strong></p>
<p>a, b, c, d在line5后仍活跃; u, v, w是临时变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t = a - b</span><br><span class="line">u = a - c</span><br><span class="line">v = t + u</span><br><span class="line">a = d</span><br><span class="line">d = v + u</span><br></pre></td></tr></table></figure>
<img src="/Course-Compiler-8/pic8-7.png" class="" title="pic8-7">
<img src="/Course-Compiler-8/pic8-8.png" class="" title="pic8-8">
</blockquote>
<h4 id="getreg函数">getReg函数</h4>
<ul>
<li>目标：减少LD/ST指令</li>
<li>任务：为运算分量和结果分配寄存器</li>
<li>为<code>x = y op z</code>的运算分量<code>y</code>和<code>z</code>分配寄存器
<ul>
<li>如果<code>y</code>已经在某个寄存器中，不需要进行处理，选择这个寄存器作为<code>Ry</code></li>
<li>如果<code>y</code>不在寄存器中，且有空闲寄存器，选择一个空闲寄存器作为<code>Ry</code></li>
<li>如果不在寄存器中, 需要选择一个非空闲寄存器存放值</li>
<li>替换非空闲寄存器<code>R</code>时,
存在变量<code>v</code>的值在<code>R</code>中
<ul>
<li>如果<code>v</code>的地址描述符表明可在别的地方找到<code>v</code>
-&gt; DONE</li>
<li><code>v</code>就是<code>x</code>(即结果)，且<code>x</code>不是运算分量<code>z</code>-&gt;
DONE</li>
<li>如果<code>v</code>在此之后不会被使用(不活跃) -&gt; DONE</li>
<li><strong>溢出操作(spill):</strong>
生成保存指令<code>ST v,R</code>并修改<code>v</code>的地址描述符
<ul>
<li>如果<code>R</code>中存放了多个变量的值，那么需要生成多条ST指令</li>
</ul></li>
</ul></li>
</ul></li>
<li>为<code>x = y op z</code>的结果<code>x</code>选择寄存器<code>Rx</code>
<ul>
<li>方法基本上和<code>y</code>, <code>z</code>相同,但是
<ul>
<li>只存放<code>x</code>值的寄存器总是可接受的</li>
<li>如果<code>y/z</code>在指令之后不再使用，且<code>Ry/z</code>仅仅保存了<code>y/z</code>的值，那么<code>Ry/z</code>同时也可以作为<code>Rx</code></li>
</ul></li>
</ul></li>
<li>处理<code>x = y</code>时
<ul>
<li>先选择<code>Ry</code></li>
<li>然后让<code>Rx = Ry</code></li>
</ul></li>
</ul>
<h3 id="确定活跃变量">确定活跃变量</h3>
<p>逆向分析代码执行路径, 确定变量生存周期</p>
<blockquote>
<p><strong>Tips: 静态分析</strong></p>
<p>推荐学习<a
href="https://tai-e.pascal-lab.net/lectures.html"><strong>Tai-e|静态分析</strong></a>中的<strong>活跃变量分析</strong>章节(DataFlow
Analysis)</p>
</blockquote>
<ul>
<li><strong>变量值的使用</strong>
<ul>
<li>三地址语句<code>i</code>向变量<code>x</code>赋值，如果另一个语句<code>j</code>的运算分量为<code>x</code>，且从<code>i</code>开始有一条路径到达<code>j</code>，且路径上没有对<code>x</code>赋值，那么<code>j</code>就使用了<code>i</code>处计算得到的<code>x</code>的值</li>
<li>则称变量<code>x</code>在语句<code>i</code>之后<strong>活跃(live)</strong>
<ul>
<li>程序执行完语句<code>i</code>时，<code>x</code>中存放的值将被后面的语句使用</li>
<li>不活跃是指变量的值不会被使用，而不是变量不会被使用</li>
</ul></li>
<li>如果<code>x</code>在<code>i</code>处不活跃，且<code>x</code>占用了一个寄存器，可以把这个寄存器用于其它目的</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Additional: 直观上的活跃变量</strong></p>
<img src="/Course-Compiler-8/pic8-9.png" class="" title="pic8-9">
</blockquote>
<h4 id="流图-基本块">流图 &amp; 基本块</h4>
<ul>
<li>中间代码的<strong>流图(Flow Graph)</strong>表示法
<ul>
<li>中间代码划分成为<strong>基本块(Basic Block)</strong>
<ul>
<li>控制流只能从基本块的第一条指令进入</li>
<li>除基本块的最后一条指令外，控制流不会跳转/停机</li>
</ul></li>
<li>流图的结点是基本块，流图的边指明了哪些基本块可以跟在一个基本块之后运行</li>
</ul></li>
<li>流图可以作为优化的基础
<ul>
<li>它指出了基本块之间的<strong>控制流(Control Flow)</strong></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Additional: 直观上的BB</strong></p>
<img src="/Course-Compiler-8/pic8-10.png" class="" title="pic8-10">
</blockquote>
<h5 id="划分基本块算法">划分基本块算法</h5>
<ul>
<li>输入：三地址指令序列</li>
<li>输出：基本块的列表</li>
<li>算法:
<ul>
<li>确定首指令leader(基本块的第一个指令)
<ul>
<li>第一个三地址指令</li>
<li>任意一个(条件或无条件)转移指令的目标指令</li>
<li>紧跟在一个(条件或无条件) 转移指令之后的指令</li>
</ul></li>
<li>确定基本块
<ul>
<li>每个首指令对应于一个基本块：从首指令开始到下一个首指令</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example: BB</strong></p>
<img src="/Course-Compiler-8/pic8-11.png" class="" title="pic8-11">
</blockquote>
<h5 id="活跃变量确定算法">活跃变量确定算法</h5>
<ul>
<li>输入: 基本块B，开始时B中的所有非临时变量都是活跃的</li>
<li>输出: 各个语句i上变量的活跃性、后续使用信息</li>
<li>算法:
<ul>
<li>从B的最后一个语句开始<strong>反向扫描</strong></li>
<li>对于每个语句<code>i：x = y + z</code>
<ul>
<li>令语句<code>i</code>和<code>x</code>, <code>y</code>,
<code>z</code>的当前活跃性信息/使用信息关联</li>
<li>设置<code>x</code>为"不活跃"和"无后续使用"</li>
<li>设置<code>y</code>和<code>z</code>为"活跃",
并指明它们的下一次使用设置为语句<code>i</code></li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example</strong></p>
<img src="/Course-Compiler-8/pic8-12.png" class="" title="pic8-12">
</blockquote>
<h5 id="流图的构建">流图的构建</h5>
<ul>
<li>流图的结点是基本块
<ul>
<li>两个结点B和C之间有一条有向边iff基本块C的第一个指令可能在B的最后一个指令之后执行</li>
</ul></li>
<li>存在边的原因
<ul>
<li>B的结尾指令是一条跳转到C的开头的条件/无条件语句</li>
<li>C紧跟在B之后，且B的结尾不是无条件跳转语句</li>
<li>称B是C的<strong>前驱(predecessor)</strong>,
C是B的<strong>后继(successor)</strong></li>
</ul></li>
<li><strong>入口(entry)/出口(exit)</strong>
<ul>
<li>不和任何中间指令对应</li>
<li>入口到第一条指令有一条边</li>
<li>任何可能最后执行的基本块到出口有一条边</li>
</ul></li>
</ul>
<h2 id="生成代码优化">生成代码优化</h2>
<h3 id="基本块的优化">基本块的优化</h3>
<ul>
<li>针对基本块的优化可以有很好的效果(局部优化)</li>
<li>许多局部优化技术需要先将基本块内的指令转化为<strong>有向无环图(Directed
Acyclic Graph, DAG)</strong></li>
<li>DAG可反映变量及其值对其他变量的依赖关系
<ul>
<li>结点表示变量的值</li>
<li>边表示计算值形成的依赖关系</li>
</ul></li>
</ul>
<h4 id="dag图的构建">DAG图的构建</h4>
<ul>
<li>每个变量都有一个对应的DAG结点表示其初始值</li>
<li>每个语句s有一个相关的结点N, 代表此计算得到的值
<ul>
<li>N的子结点对应于(得到其运算分量当前值的) 其它语句</li>
<li>N的标号是s中的运算符, 同时还有一组变量被关联到N,
表示s是最新对这些变量进行定值的语句</li>
</ul></li>
<li><strong>算法:</strong>
<ul>
<li>为基本块中出现的每个变量建立结点(表示初始值)，各变量和相应结点关联</li>
<li>顺序扫描各三地址指令，进行如下处理
<ul>
<li>指令<code>x = y op z</code>
<ul>
<li>为该指令建立结点N，标号为op，令x和N关联</li>
<li>N的子结点为y、z当前关联的结点</li>
</ul></li>
<li>指令<code>x = y</code>
<ul>
<li>假设y关联到N，那么x现在也关联到N</li>
</ul></li>
</ul></li>
<li>扫描结束后，对所有在出口处活跃的变量x，将x所关联的结点设置为输出结点</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example: DAG</strong></p>
<img src="/Course-Compiler-8/pic8-13.png" class="" title="pic8-13">
</blockquote>
<h4 id="dag的作用">DAG的作用</h4>
<ul>
<li>DAG图描述了基本块运行时各变量的值(和初始值)之间的关系</li>
<li>以DAG为基础，对代码进行转换
<ul>
<li>寻找局部公共子表达式</li>
<li>消除死代码</li>
<li>代数恒等式的使用</li>
<li>数组引用的表示</li>
<li>指针赋值和过程调用</li>
</ul></li>
</ul>
<h5 id="局部公共子表达式">局部公共子表达式</h5>
<img src="/Course-Compiler-8/pic8-14.png" class="" title="pic8-14">
<h5 id="消除死代码">消除死代码</h5>
<img src="/Course-Compiler-8/pic8-15.png" class="" title="pic8-15">
<h5 id="代数恒等式优化">代数恒等式优化</h5>
<img src="/Course-Compiler-8/pic8-16.png" class="" title="pic8-16">
<h5 id="数组引用">数组引用</h5>
<img src="/Course-Compiler-8/pic8-17.png" class="" title="pic8-17">
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-8/pic8-18.png" class="" title="pic8-18">
</blockquote>
<h5 id="指针赋值过程调用">指针赋值/过程调用</h5>
<img src="/Course-Compiler-8/pic8-19.png" class="" title="pic8-19">
<h3 id="基本块重组">基本块重组</h3>
<ul>
<li><strong>重组的方法</strong>
<ul>
<li>每个结点构造一个三地址语句，计算对应的值</li>
<li>结果应该尽量赋给一个活跃的变量</li>
<li>如果结点有多个关联的变量，则需要用复制语句进行赋值</li>
</ul></li>
<li><strong>重组的规则(求值顺序)</strong>
<ul>
<li>指令顺序必须遵守DAG中结点的顺序</li>
<li>对数组赋值(write)要跟在原来之前的赋值/求值之后</li>
<li>对数组求值(read)要跟在原来之前的赋值指令之后</li>
<li>对变量的使用必须跟在所有原来在它之前的过程调用和指针间接赋值之后</li>
<li>任何过程调用或指针间接赋值必须跟在原来在它之前的变量求值之后</li>
<li><strong>如果两个指令之间相互影响，它们的顺序就不该改变</strong></li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-8/pic8-20.png" class="" title="pic8-20">
</blockquote>
<h3 id="窥孔优化">窥孔优化</h3>
<ul>
<li><strong>窥孔优化(peephole optimization):</strong>
使用一个滑动窗口(窥孔)来检查目标指令，在窥孔内实现优化
<ul>
<li>冗余指令消除</li>
<li>控制流优化</li>
<li>代数化简</li>
<li>机器特有指令的使用</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Tips:</strong></p>
<p>滑动窗口(窥孔)并无准确定义,
可理解为只需关注少量相关指令即可完成的优化</p>
</blockquote>
<h3 id="冗余指令消除">冗余指令消除</h3>
<ul>
<li>多余的LD/ST指令
<ul>
<li><code>LD R0, a</code></li>
<li><code>ST a, R0 //可删除</code></li>
</ul></li>
<li>级联跳转代码
<ul>
<li><code>if debug == 1 goto L1; goto L2;  L1: ...;  L2: ...;</code>
<ul>
<li>如果已知<code>debug</code>一定是0,
那么替换成为<code>goto L2</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="控制流优化">控制流优化</h3>
<img src="/Course-Compiler-8/pic8-21.png" class="" title="pic8-21">
<h3 id="代数化简和机器特有指令">代数化简和机器特有指令</h3>
<ul>
<li>应用代数恒等式
<ul>
<li>消除<code>x = x + 0</code>, <code>x = x * 1</code>, ...</li>
<li>用<code>x * x</code>替换<code>x ^ 2</code></li>
</ul></li>
<li>使用机器特有指令
<ul>
<li>INC, DEC, ...</li>
</ul></li>
</ul>
<h3 id="树重写指令选择">树重写指令选择</h3>
<ul>
<li>在某些机器上，同一个三地址指令可以使用多种机器指令实现，有时多个三地址指令可以使用一个机器指令实现</li>
<li><strong>指令选择</strong>
<ul>
<li>为实现中间表示形式中出现的运算符选择适当的机器指令</li>
<li>用树来表示中间代码，按照特定的规则不断覆盖这棵树并生成机器指令</li>
</ul></li>
</ul>
<blockquote>
<p><strong>Example:</strong></p>
<img src="/Course-Compiler-8/pic8-22.png" class="" title="pic8-22">
</blockquote>
<h4 id="目标指令选择">目标指令选择</h4>
<img src="/Course-Compiler-8/pic8-23.png" class="" title="pic8-23">
<h4 id="重写规则">重写规则</h4>
<img src="/Course-Compiler-8/pic8-24.png" class="" title="pic8-24">
<img src="/Course-Compiler-8/pic8-25.png" class="" title="pic8-25">
<blockquote>
<p><strong>Example: 规则覆写</strong></p>
<img src="/Course-Compiler-8/pic8-26.png" class="" title="pic8-26">
</blockquote>
<h4 id="树翻译方案的工作模式">树翻译方案的工作模式</h4>
<ul>
<li>给定一颗输入树，树重写规则中的模板被用来匹配输入树的子树</li>
<li>如果找到一个匹配的模板，那么输入树中匹配的子树将被替换为相应规则中的替换结点，并执行相应的动作，这可能是生成相应的机器指令序列</li>
<li>不断匹配，直到这颗树被规约成单个结点，或找不到匹配的模板为止</li>
<li>在此过程中生成的机器指令代码序列就是树翻译方案作用于给定输入树而得到的输出</li>
</ul>
<h4 id="通过扫描进行模式匹配">通过扫描进行模式匹配</h4>
<img src="/Course-Compiler-8/pic8-27.png" class="" title="pic8-27">
]]></content>
      <categories>
        <category>课程笔记-编译原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A1-Live Variable Analysis</title>
    <url>/LabRecord-SPA-A1/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-1 Live Variable
Analysis &amp; IterativeSolver.</strong></p>
<span id="more"></span>
<h2 id="实验信息">实验信息</h2>
<p>NJU软件分析, 实际上是静态分析(Static Program Analysis),
是由李樾和谭添老师开设的面向本科生和研究生的一门课程,
因为是本研共修选修课, 因此本课程内容较为基础,
比较适合对静态分析感兴趣的初学者快速入门. 课程网站<a
href="https://tai-e.pascal-lab.net/lectures.html"><strong>[Static
Program Analysis]</strong></a>, 配套课程<a
href="https://www.bilibili.com/video/BV1b7411K7P4"><strong>[Bilibili|南京大学《软件分析》]</strong></a>.</p>
<p>本课程实验(Assignments)基于Tai-e教学版框架,
框架代码的获取和实验环境配置见课程网站, 笔者在约一年前曾自学过本课程,
现今跟随2024Fall课程进度再次学习,
由于上次学习中受到了多位前辈留下的实验记录帮助,
遂于此记录笔者对各个实验的理解和记录. 限于笔者个人能力水平,
恐难完整覆盖实验中的所有要点, 记录内容仅供参考, 如能帮助到您,
乃笔者荣幸.</p>
<p><del>鉴于 <strong>学术诚信(Academic Integrity)</strong> 要求,
笔者暂且 <strong><em>不</em></strong> 公开源代码.</del></p>
<p>已公开参考源代码, 请<strong>遵循学术诚信</strong>.</p>
<p><a
href="https://github.com/La-Pluma/NJU-Static-Analysis-Tai-e"><strong>LaPuluma|StaticAnalysis</strong></a></p>
<h2 id="食用指南">食用指南</h2>
<p>本试验记录 <strong><em>不会</em></strong>
从零开始讨论完成实验的知识点, 框架理解和注意事项.
食用前请确保观看并理解了课程的P1-4内容, 尤其是对活跃变量分析(Live
Variable Analysis)的算法和原理的基本掌握; 完整阅读过<a
href="https://tai-e.pascal-lab.net/pa1.html"><strong>实验指南</strong></a>和框架代码后,
再来参考本实验记录, 效果最佳.</p>
<h2 id="任务目标">任务目标</h2>
<p>基于已有框架为java实现一个<strong>活跃变量分析</strong>,
使用<strong>迭代求解器(Iterative Solver)</strong>.</p>
<p>具体来说, 实现Your
Task中涉及的三份文件中的6个<code>TODO API</code>.</p>
<p>涉及的主要算法如下图所示:</p>
<img src="/LabRecord-SPA-A1/pic1.png" class="" title="pic1">
<p>作为第一个实验, 总体难度不高, 关键在于熟悉Tai-e框架,
还望读者耐心阅读框架代码. 不妨善用Github
Copilot或者ChatGPT帮助理解框架代码.</p>
<h2 id="livevariableanalysis">LiveVariableAnalysis</h2>
<p>活跃变量分析算法中需要用到的具体方法, 实验指南中已有较为详细的说明,
笔者在此不再赘述.</p>
<img src="/LabRecord-SPA-A1/pic2.png" class="" title="pic2">
<p>关于实现该部分所需的<code>API</code>,
请阅读<code>Class SetFact</code>源码.</p>
<p>笔者在此补充一些本实验所需java语法性质或语法糖.</p>
<h3 id="class-optional">Class Optional</h3>
<p>Java 8引入的性质, 详细信息可查询文档或教程, 笔者在此给出其一<a
href="https://www.runoob.com/java/java8-optional-class.html"><strong>[菜鸟教程|Java
Optional]</strong></a>.</p>
<p>与之类似的还有<code>java.util.List</code>,
学习java语法来获得<code>Optional</code>和<code>List</code>中的内容.</p>
<p>使用示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> stmt.getDef().orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="instanceof操作符">instanceof操作符</h3>
<p>java中用于判断类型的操作符, 详细信息可参考<a
href="https://www.baeldung.com/java-instanceof"><strong>[Baeldung|Java
instanceof Operator]</strong></a>.</p>
<p>使用示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(def <span class="keyword">instanceof</span> Var)</span><br></pre></td></tr></table></figure>
<p>需要注意的是, 如指南所示</p>
<img src="/LabRecord-SPA-A1/pic3.png" class="" title="pic3">
<p><code>Exp</code>下的<code>LValue</code>
<code>RValue</code>包括多种类型,
我们只需要关注<code>Var</code>类型的使用.</p>
<blockquote>
<p><strong>Tips:</strong> 为什么不需要考虑别的类型?</p>
<p><code>LValue</code>只需要关注<code>Var</code>, 这是手册告诉我们的.
<code>RValue</code>尽管有多种类型,
但可以通过<code>getUses()</code>方法将Exp中涉及的变量等信息全部获取,
此时右式是<code>UnaryExp</code>or<code>BinaryExp</code>对我们来说都不重要了,
只需要将<code>getUses()</code>中的<code>Var</code>筛选出来处理即可.</p>
</blockquote>
<blockquote>
<p><strong>Additional:</strong> <code>getUses()</code>究竟返回什么?</p>
<p>笔者在此引用<a
href="https://github.com/RicoloveFeng">RicoloveFeng</a>在<a
href="https://github.com/RicoloveFeng/SPA-Freestyle-Guidance">SPA-Freestyle-Guidance</a>中的解释</p>
<p>你可能想知道 <code>getUses()</code> 除了 <code>x = y</code>
这条语句之外还返回些什么东西.我们举点例子吧:</p>
<ul>
<li><p><code>x = y op z</code>: <code>[y, z, y op z]</code></p></li>
<li><p><code>x = m(n)</code>:
<code>[mClass, n, invokevirtual mClass.m(n)]</code></p></li>
</ul>
</blockquote>
<h3 id="java引用机制">java引用机制</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//in = out.copy();</span></span><br><span class="line">        in.set(out);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管两行代码"看起来"是一致的,
但注释掉的代码只会改变形参<code>in</code>的取值,
不会改变实际的<code>Fact in</code>. 详细原理可以参考<a
href="https://zhuanlan.zhihu.com/p/453857961"><strong>[知乎|java引用详解]</strong></a>.</p>
<h2 id="solver-iterativesolver">Solver &amp; IterativeSolver</h2>
<p>本部分对应具体的算法流程.</p>
<p>实际上指南写的已足够详细,
包括如何从<code>cfg</code>中获取信息的方法和两处<code>TODO</code>对应的具体部分,
使得即便对框架不甚理解, 仍然能完成该部分.</p>
<p>唯一需要阅读代码知道的是可以通过<code>analysis.xx</code>的方式调用我们在上一节中实现的<code>API</code>.</p>
<p><code>Solver</code>的<code>Init</code>需要注意的是由于我们<code>analysis.meetInto()</code>与算法中不完全相同,
在初始化阶段我们同样要对<code>out Fact</code>进行赋空初始化.</p>
<p><code>IterativeSovlver</code>部分是算法的循环部分,
由于我们的分析器<code>BB</code>是<code>stmt</code>,
因此不需要考虑Block内部的执行顺序,
直接使用<code>analysis.transferNode</code>即可.</p>
<p>另外, 上课时遍历迭代顺序取的是较优结果, 我们不需要过多考虑性能问题,
因此以任意节点顺序迭代仍然可以得到结果, 这大大降低了代码实现的复杂性,
只需要使用简单的<code>for(Node node : cfg)</code>即可.</p>
<p>笔者同样补充一些可能对本实验理解有帮助的细节部分.</p>
<h3 id="dataflowresult">DataflowResult</h3>
<p>其本质是两个<code>Nodes</code>对应的<code>inFacts</code>
<code>outFacts</code>的集合, 通过给定的API获取和设置其中的值,
其中<code>inFacts</code>和<code>outFacts</code>不过是<code>set</code>的封装,
在抽象层面上意义和课程中的那个代表变量的二进制串相同.</p>
<h3
id="cfgnode-cfg-中的-node具体指什么"><code>CFG&lt;Node&gt; cfg</code>
中的 <code>Node</code>具体指什么?</h3>
<p>在本次实验中, <code>Node node</code>指的是<code>stmt</code>,
从指南中可以推测出这点. 通过阅读源代码, 也可以得知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiveVariableAnalysis</span> <span class="keyword">extends</span></span><br><span class="line">        <span class="title class_">AbstractDataflowAnalysis</span>&lt;Stmt, SetFact&lt;Var&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>所以我们可以直接使用以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Node node : cfg)&#123;</span><br><span class="line">    ...</span><br><span class="line">    analysis.transferNode(node, in, out);</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>总的来说这次实验的难点在于框架代码的理解,
笔者在记录中提及了部分关键定义和代码理解, 只要耐心阅读框架代码,
相信一定会AC.</p>
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A4-CHA &amp; Inter Constant Propagation</title>
    <url>/LabRecord-SPA-A4/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-4 Class Hierarchy
Analysis &amp; Interprocedural Constant Propagation.</strong></p>
<span id="more"></span>
<h2 id="实验信息食用指南">实验信息&amp;食用指南</h2>
<p>见本博客A1-A3.</p>
<blockquote>
<p><strong>手册的手册不能替代手册, 看不懂的话请回去看手册. ——</strong>
<a
href="https://github.com/RicoloveFeng"><strong>RicoloveFeng|SPA-Freestyle-Guidance</strong></a></p>
</blockquote>
<h2 id="实验目标">实验目标</h2>
<p>基于<strong>Tai-e</strong> 框架实现 <strong>CHA</strong> &amp;
<strong>Inter Constprop</strong>.</p>
<p><del>真的还有必要在记录里补充这个吗</del></p>
<h2 id="实验简析">实验简析</h2>
<p>其实没什么好说的, 课程 &amp; ppt &amp; 指南已经讲的比较明确了,
笔者在此补充一些手册写的不明确或是略去的部分.</p>
<p><strong>不过本次实验涉及不少新东西,
烦请耐心阅读相关代码API.</strong></p>
<h2 id="preparation">Preparation</h2>
<p>从Assignment2中将<code>ConstPropogation.java</code>
copy到本次实验目录对应位置.</p>
<p><strong>需要注意的是,
A2中不完全正确的实现可能会影响本次实验的本地测试.</strong></p>
<h2 id="chabuilder">CHABuilder</h2>
<p>这部分tt老师贴心的在ppt中给好了算法框架,
对应本次的框架代码复刻即可.</p>
<p>需要注意的是, 只有在完成了该部分后,
<strong>Tai-e</strong>框架才能正确构建<code>ICFG</code>,
否则使用<code>Assignment</code>分析的结果只会为空.</p>
<p>推荐完成顺序 <code>dispatch</code> -&gt; <code>resolve</code> -&gt;
<code>buildCallGraph</code></p>
<h3 id="dispatch">dispatch()</h3>
<p>可以选择递归或者循环完成该部分.</p>
<ul>
<li><p><code>dispatch()</code>可能会失败, 此时可以返回<code>null</code>,
但要确保<code>resolve()</code>中可以正确处理这一情况.</p>
<blockquote>
<p><strong>Additional:</strong> 为什么可能会失败?</p>
<p><code>resolve()</code>中,
假设我们要处理一个<code>Interface</code>或者<code>Abstract</code>类型声明的类方法,
首先我们需要<code>dispatch</code>这个声明类本身,
易见此时应当得到<code>null</code>(接口中的方法和抽象方法无法被实例化)</p>
</blockquote></li>
<li><p><code>dispatch()</code>得到的<code>JMethod</code>如果是<code>Abstract</code>,
同样需要返回<code>null</code>.</p>
<blockquote>
<p><strong>Tips:</strong> 由于OOP的机制,
当<code>JMethod</code>是<code>Abstract</code>时,
不需要继续<code>dispatch</code>了.
如果对此感到困惑可以去查阅相关的OOP资料.</p>
</blockquote></li>
</ul>
<h3 id="resolve">resolve()</h3>
<ul>
<li><p>遍历的方式自选, 笔者采用较好实现的BFS.</p></li>
<li><p>尽管课上将<code>Interface</code>归入了<strong>Virtual
Invoke</strong>, 但按照代码框架,
这部分单独作为一个需要处理的<code>CallKind</code>.
不过处理起来也并非难事,
因为处理方式和<code>VIRTUAL</code>没有实质性区别.</p></li>
<li><p>需要注意的是,
框架中处理<strong>Interface</strong>和<strong>Class</strong>分别有专门的API方法,
具体使用什么API, 可以阅读<code>ClassHierarachy</code>,
<code>CHABuilder</code>中也提供了访问<code>ClassHierarachy</code>的成员<code>private ClassHierarchy hierarchy</code>.</p></li>
<li><p><code>STATIC</code>方法的获取在框架中没有专门的API,
但可以使用<code>dispatch()</code>获取,
因此<code>STATIC</code>和<code>SPRECIAL</code>也可以一起处理.</p></li>
</ul>
<h3 id="buildcallgraph">buildCallGraph()</h3>
<p>实现和ppt中的算法没有区别.</p>
<ul>
<li><p>判断是否可达在框架中集成到了<code>Class CallGraph</code>的<code>addReachableMethod()</code>方法中了,
可以阅读API注释获取更详细的信息.</p></li>
<li><p>得到<code>callSite</code>,
<code>callKind</code>的方法也可以通过<code>Class CallGraph</code>获取.<del>(我看看是谁不想去读API注释)</del></p></li>
</ul>
<h2 id="intersovler">InterSovler</h2>
<p>由于框架代码在<code>InterSovler</code>这一部分进行了较大幅度的重构,
因此笔者推荐先完成该部分使得对<code>InterConstantPropopagation</code>有一个自顶向下的认识.</p>
<p>同手册所说, 该部分比起A2的<code>worklistSovler</code>没有太大的区别,
跟着手册做即可.</p>
<p><strong>注意:</strong>
该部分实例化的<code>private final InterDataflowAnalysis&lt;Node, Fact&gt; analysis</code>继承自<code>Class AbstractInterDataflowAnalysis</code>,
该部分的源码阅读是必不可少的.<del>(这里不读在完成InterConstantPropopagation的时候也要读)</del></p>
<h3 id="initialize">initialize()</h3>
<ul>
<li>除去icfg的入口方法使用<code>BoundaryInit</code>外,
其余节点均使用<code>NormalInit</code>.
可以通过<code>icfg.entryMethods()</code>方法获取入口方法.</li>
</ul>
<blockquote>
<p><strong>Tips:</strong>
需要注意的是<code>icfg.entryMethods()</code>返回的是<code>Stream</code>类型,
遍历该类型可以使用<code>forEach</code>.
更多关于<code>forEach</code>的信息可以查阅java的文档.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">icfg.entryMethods().forEach(method -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Confusion:</strong> 笔者在此比较困惑为何可能会出现多个入口,
虽然在网络上查询得知java中可能不止一个<code>main()</code>方法,
但不知如何在tai-e框架中复现,
以及本次实验中的"多个入口"是否对应该特性.</p>
</blockquote>
<h3 id="dosolve">dosolve()</h3>
<p>与A2相比,
只需要修改处理<code>pred Node</code>部分为<code>pred Edge</code>,
可以通过<code>getInEdgesOf()</code>方法获得<code>pred Edge</code>信息,
与<code>analysis.transferNode()</code>对应,
可通过<code>analysis.transferEdge()</code>来处理<code>pred Edge</code>.</p>
<h2 id="interconstantpropopagation">InterConstantPropopagation</h2>
<p>部分API在框架中已经给出了实现, 在该部分只需要实现6个API即可.</p>
<p><strong>善用A2中完成部分进行本次实验,
过程间常量传播并不影响计算常量的逻辑.</strong></p>
<h3 id="transfercallnode-transfernoncallnode">transferCallNode() &amp;
transferNonCallNode()</h3>
<p>含义同方法名,
如果这个<code>Node</code>(即<code>Stmt</code>)是<code>Invoke</code>,
就称该<code>Node</code>为<code>CallNode</code>,
否则为<code>NonCallNode</code>.</p>
<ul>
<li>需要注意的是,
过程间处理的大部分操作都在<code>Edge</code>上而非<code>Node</code>上,
因此我们在<code>transferCallNode()</code>中并不会进行 add/kill def
的操作. 这一点与指南上的图片逻辑相同.</li>
</ul>
<img src="/LabRecord-SPA-A4/pic4-1.png" class="" title="pic4-1">
<blockquote>
<p>如图片所示,
<code>Node 2</code>在经过<code>transferCallNode()</code>后并没有把<code>b</code>添加进<code>outFact</code>.</p>
<p>尽管我们可以在这里处理, <del>但这样有可能会让你过不去oj</del>,
但这样会造成逻辑上的混乱, 所有的<strong>interprocedural</strong>
操作都在<code>Edge</code>上进行在逻辑上是一致的.
接下来对四种<code>transferEdge</code>的处理中会解释这一点.</p>
</blockquote>
<ul>
<li>所以对于非call Node,
可以直接使用过程内分析的<code>transferNode()</code>方法, 对于call Node,
<code>transferCallNode()</code>只需要把<code>inFact</code> 赋值给
<code>outFact</code>即可.</li>
</ul>
<h3 id="transferedge">transfer**Edge</h3>
<p>在完成该部分前, 要先知道该部分会在什么地方使用,
通过阅读<code>Class AbstractInterDataflowAnalysis</code>的源码API,
可以发现四种<code>transfer**Edge</code>
统一为了一个方法<code>transferEdge()</code>.(如果阅读的足够仔细,
会发现两个<code>NodeTransfer</code>的方法也被统一为了<code>transferNode()</code>)</p>
<p><strong>注意:</strong> 如手册所言, 由于java的引用机制,
不应当对第二个参数<code>CPFact out</code>做任何修改.
返回值也不应是第二个参数本身,
需要深拷贝一个<code>out</code>或者<code>new CPFact()</code>.</p>
<h4 id="transfernormaledge">transferNormalEdge()</h4>
<p>对于普通节点, 不需要对<code>OutFact</code>中的内容做修改,
直接传给<code>Edge</code>的<code>target</code>即可.</p>
<blockquote>
<p>对应上文图片中的<strong>黑色实线</strong>.</p>
</blockquote>
<h4 id="transfercalltoreturnedge">transferCallToReturnEdge()</h4>
<p>在这里要处理<strong>def kill</strong>工作, 根据框架代码,
这里的<code>Stmt</code>一定是<code>Invoke</code>,
请阅读源码API获取使用信息.</p>
<ul>
<li><code>Invoke</code>继承自<code>DefinitionStmt</code>,
如何获取<code>def</code>在之前的实验中已有涉及.</li>
</ul>
<blockquote>
<p>对应上文图片中的<strong>黑色虚线</strong>.</p>
</blockquote>
<h4 id="transfercalledge">transferCallEdge()</h4>
<p>负责传参中的<code>Var</code>转换.</p>
<ul>
<li><p>对于<code>Invoke invoke</code>,
可以通过<code>invoke.getInvokeExp().getArgs()</code>获取传入<strong>实参</strong>的信息.</p></li>
<li><p>对于<code>JMethod callee</code>,
可以通过<code>callee.getIR().getParams()</code>获取调用方法的<strong>形参</strong>信息.</p></li>
<li><p>在tai-e框架中, 保证上述形参与实参列表顺序是一一对应的.
可以根据这一特性维护传参的转换过程.</p></li>
</ul>
<blockquote>
<p>对应上文图片中的<strong>蓝色虚线</strong>.</p>
</blockquote>
<h4 id="transferreturnedge">transferReturnEdge()</h4>
<p>负责将调用方法的返回值传回<code>callSite</code>.</p>
<ul>
<li><code>Class ReturnEdge</code>的<code>getReturnVars()</code>的API说明讲明了为什么可能有多个返回值,
需要注意的是, 如果有多个返回值,
需要使用<code>cp.meetValue()</code>.</li>
</ul>
<blockquote>
<p>对应上文图片中的<strong>红色虚线</strong>.</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>过程间常量传播的思想还是比较巧妙的, 值得细心品味.</p>
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A2-Constant Propagation</title>
    <url>/LabRecord-SPA-A2/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-2 Constant
Propagation &amp; WorlistSolver.</strong></p>
<span id="more"></span>
<h2 id="实验信息与食用指南">实验信息与食用指南</h2>
<p>请翻阅<a
href="https://la-pluma.github.io/LabRecord-SPA-A1"><strong>[NJU静态分析|A1-Live
Variable Analysis]</strong></a>.</p>
<p>在此进行一点补充, 笔者的这份实验记录更像是Free
Style版的<strong>FAQ</strong>. 因此请 <strong><em>确保</em></strong>
在理解了<strong>理论知识</strong>, <strong>实验指南</strong> 和
<strong>框架代码</strong> 后再参考本记录, 与A1相同, 本记录
<strong><em>不提供</em></strong> 源代码(<del>或者说暂时没有</del>).</p>
<p><del>如果您对本实验记录中的内容感到困惑,
可能是因为笔者能力不足或您未能理解实验指南和框架代码,
同时本试验记录难以涵盖所有的坑, 还望海涵.</del></p>
<h2 id="实验目标">实验目标</h2>
<p>基于<strong>Tai-e</strong>框架实现<strong>常量传播算法</strong>和<strong>worklist求解器</strong>.</p>
<p>大致的框架代码如下:</p>
<img src="/LabRecord-SPA-A2/pic1.png" class="" title="pic1">
<p>注意常量传播算法是<strong>Forward &amp; Must analysis</strong>.</p>
<h2 id="部分重要框架代码带读">部分重要框架代码带读</h2>
<p><del>我知道你们有些人肯定是不看框架代码的,
除非不得不用或者报错的时候.</del></p>
<h3 id="ir-irbuilder">IR &amp; IRBuilder</h3>
<p>Tai-e框架中的<code>IR</code>与课上教授的IR稍有不同, 以A2
test中的<strong>Assign.java</strong>为例,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   From A2 test/Assign.java   */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assign</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">        x = <span class="number">4</span>;</span><br><span class="line">        y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过tai-e框架的分析后会得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> &lt;init&gt;()&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L1</span>] invokespecial %<span class="built_in">this</span>.&lt;java.lang.Object: <span class="keyword">void</span> &lt;init&gt;()&gt;(); &#123;&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L1</span>] <span class="keyword">return</span>; &#123;&#125;</span><br><span class="line"></span><br><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span>&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;   &#123;x=<span class="number">1</span>&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] x = <span class="number">2</span>;   &#123;x=<span class="number">2</span>&#125;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] x = <span class="number">3</span>;   &#123;x=<span class="number">3</span>&#125;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">4</span>;   &#123;x=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L8</span>] y = x;   &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] <span class="keyword">return</span>;  &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结合<strong>IR</strong> &amp; <strong>IRBuilder</strong>(可翻阅<a
href="https://tai-e.pascal-lab.net/docs/index.html"><strong>[官方手册]</strong></a>),</p>
<img src="/LabRecord-SPA-A2/pic2.png" class="" title="pic2">
<p><del>IR我懒得贴了</del></p>
<p><code>IR</code>的基本单元是<strong>method</strong>
(请意识到java是oop语言),
<code>IRBuilder</code>提供了分析单个方法的API<code>buildIR(JMethod method)</code>和分析整个<code>class hierarchy</code>(不明白,
等到A4就明白了, 笑)中的所有方法的API<code>buildAll()</code></p>
<p>结合<code>Stmt</code> <code>Exp</code> 和 <code>CFG</code>,
我们可以得到这样的一个示意图(由于笔者未阅读全部的源码实现,
可能会有所出入, 但大致如此).</p>
<img src="/LabRecord-SPA-A2/pic3.png" class="" title="pic3">
<blockquote>
<p><strong>Tips:</strong>
严格来说<code>CFG</code>并不存储<code>Node</code>(本实验中指<code>Stmt</code>,
见A1试验记录说明), 只存储<code>Stmt</code>的关联信息,
但为了方便图示遂如此展示. 至于为何左值和右值都是<code>Exp</code>,
请翻阅A1官方实验指南中对<code>Exp</code>的图示表示部分.</p>
</blockquote>
<h3 id="definitionstmt">DefinitionStmt</h3>
<p>尽管理论上不需要这个类也可以完成实验(<code>Stmt</code>中的顶层方法足以实现),
但既然框架提供了这么好用的API, 方便我们写出更优雅的代码,
为什么不用呢?</p>
<img src="/LabRecord-SPA-A2/pic4.png" class="" title="pic4">
<p><code>DefinitionStmt</code>为我们提供了两个非常好用的API,
<code>getLValue()</code>和<code>getRValue</code>可以直接获取到左右式的<code>Exp</code>(希望你还记得<code>LValue</code>&amp;<code>RValue</code>
extends <code>Exp</code>),
而不需要像<code>Stmt</code>中的<code>getDef()</code> &amp;
<code>getUses()</code>
做较为繁琐的判断和筛选(如果对<code>getUses()</code>感到困惑,
也还请翻阅A1实验记录, 里面有解释和参考来源).</p>
<p>需要注意的是,
<code>getLValue()</code>可能会返回<code>null</code>.</p>
<h2 id="constantpropagation">ConstantPropagation</h2>
<p>与活跃变量分析类似, 我们需要完成5个API的功能.</p>
<h3 id="newboundaryfact-newinitialfact">newBoundaryFact() &amp;
newInitialFact()</h3>
<p>需要注意的是, 本次存储分析结果的数据结构是<code>CPFact</code>,
与A1相同, 在完成本次实验代码之前需要了解相关API的用法.</p>
<p>既然是<strong>Must Analysis</strong>, 我们需要将初值赋为空,
但需要注意的是, 我们的<strong>Analysis</strong>仅分析语句,
在进入第一条语句之前, 是否有什么东西需要初始化?</p>
<p>这个问题就对应了指南中为什么<code>BoundaryInit</code> 要通过
<code>getIR().getParas()</code>获取参数并赋值<code>NAC</code>的提示.</p>
<p>在对<code>IR</code>的解释中我们提到过,
<code>IR</code>的基本分析单元是<strong>method</strong>, 即函数,
函数就可能有传入的参数, 这些参数易见<strong>不是Constant</strong>,
因此要赋值为<code>NAC</code></p>
<blockquote>
<p><strong>Tips:</strong> 如果是Constant干嘛还要传参, 即便真的这么做了,
我们的分析也可以满足<strong>safe-approximation</strong>.</p>
</blockquote>
<p>这部分是在方法体(函数语句)执行前就完成的初始化,
因此我们需要赋值给<code>Entry</code>的<code>outFact</code>.</p>
<h3 id="meetvalue-meetinto">meetValue() &amp; meetInto()</h3>
<p><code>meetValue()</code>的完成没有任何难点,
只需要照抄ppt中的规则即可.</p>
<img src="/LabRecord-SPA-A2/pic5.png" class="" title="pic5">
<p>同样的,
完成这部分代码需要阅读<code>Class Value</code>的源码API和注释.</p>
<p>关于<code>meetInto()</code>,
如果没有阅读<code>CPFact</code>中的<code>update()</code>方法注释,
就不知道可以写出如此优雅的代码来合并<code>Var</code>的<code>Value</code>值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">target.update(<span class="keyword">var</span>, meetValue(fact.get(<span class="keyword">var</span>), target.get(<span class="keyword">var</span>)));</span><br></pre></td></tr></table></figure>
<img src="/LabRecord-SPA-A2/pic6.png" class="" title="pic6">
<h3 id="transfernode-evaluate">transferNode() &amp; evaluate()</h3>
<p>毫无疑问, 这是本次实验中最难最核心的一部分, 细节非常多, 当被卡hidden
test的时候, 大概率寄在这里.</p>
<p>笔者建议在<code>transferNode()</code>中处理<code>Stmt</code>的左值def部分,
在<code>evaluate()</code>中处理右值exp部分. 这是比较符合功能分离的写法,
当然, 也可以选择在
<code>transferNode()</code>中处理<code>Var</code>和<code>IntLiteral</code>,
<code>evaluate()</code>只负责处理<code>BinaryExp</code>的计算值.
笔者在此按第一种写法进行说明.</p>
<h4 id="transfernode">transferNode()</h4>
<p>这个函数中你需要依次做(次流程可能存在可以优化的部分,
不必完全照做):</p>
<ul>
<li><p>保存<code>outFact</code>原值,
将<code>inFact</code>赋值给<code>outFact</code>.</p></li>
<li><p>判断<code>Node</code>(<code>Stmt</code>)是否为<code>DefinitionStmt</code></p></li>
<li><p>判断是否拥有<strong>合法</strong>左值,
包括<code>def</code>的类型<code>Var</code>和<code>Var</code>中的<code>ValueType</code>是否为<code>Int</code>,
如果不是, 本次实验中可以认为是<code>nop</code>空操作.
不需要为这个<code>Stmt</code>做任何分析, 直接将<code>inFact</code>
copy给 <code>outFact</code>即可.</p>
<blockquote>
<p><strong>Tips:</strong> IDEA教给我一个很有意思的语法糖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> DefinitionStmt def_stmt)&#123;</span><br><span class="line">    <span class="type">LValue</span> <span class="variable">def</span> <span class="operator">=</span> def_stmt.getLValue();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个用法可以避开繁琐的类型转化, 在判断类型时便做了类型转化.</p>
</blockquote></li>
<li><p>计算<code>Stmt</code>的右值(通过<code>evaluate()</code>获得),
并更新<code>outFact</code>中的相应<code>Var def</code>(笔者在此并未使用<code>update</code>方法的返回值,
或许可从此处入手优化效率, 但笔者不能保证其正确性)</p></li>
<li><p>比较<code>outFact</code>是否更新返回布尔值.</p></li>
</ul>
<h4 id="evaluate">evaluate()</h4>
<p>为了完成这个方法, 代码的大致框架应该是这个样子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Value <span class="title function_">evaluate</span><span class="params">(Exp exp, CPFact in)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> Var)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*Value*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> IntLiteral)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/*Value*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exp <span class="keyword">instanceof</span> BinaryExp binary_exp)&#123;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">left</span> <span class="operator">=</span> ...;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">right</span> <span class="operator">=</span> ...;</span><br><span class="line">        <span class="comment">// Operand may not Int or may not Constant</span></span><br><span class="line">        <span class="comment">// you&#x27;d better do it first</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*left HoldInt &amp;&amp; right HoldInt*/</span>)&#123;</span><br><span class="line">            <span class="comment">//you can get Condition Info form ppt</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*left is Constant &amp;&amp; right is constant*/</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (binary_exp <span class="keyword">instanceof</span> ArithmeticExp arithmetic_exp)&#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="comment">//also should attention to DIV 0 return Undef</span></span><br><span class="line">                        <span class="keyword">case</span> ADD: ...</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binary_exp <span class="keyword">instanceof</span> BitwiseExp bitwise_exp)&#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="keyword">case</span> AND: ...</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(...)</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*left is NAC || right is NAC*/</span>)&#123;</span><br><span class="line">                <span class="comment">//you should do DIV &amp; REM for 0 judgement there</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*other condition*/</span>)&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*other condition*/</span>)&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for over-approximation</span></span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//such as x = o.f()</span></span><br><span class="line">    <span class="comment">//for over-approximation</span></span><br><span class="line">    <span class="keyword">return</span> Value.getNAC(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中二元表达式计算规则见ppt所示,</p>
<img src="/LabRecord-SPA-A2/pic7.png" class="" title="pic7">
<p>笔者在此给出一些细节和边界条件,
也可以通过阅读上述代码框架获得细节提示:</p>
<ul>
<li><p><code>exp</code>中的操作数可能不是<code>IntType</code>,
所以你需要做一个<code>canHoldInt()</code>判断,
非法<code>exp</code>为了安全性应赋值为<code>NAC</code></p></li>
<li><p>实验指南中提到, 对于<code>/</code>和<code>%</code>的除零错误,
应当给出<code>Undef</code>,
<strong>即使</strong>被除数是<code>NAC</code>.</p></li>
</ul>
<h2 id="sovler-worklistsolver">Sovler &amp; WorkListSolver</h2>
<h3 id="sovler-init">Sovler Init</h3>
<p>照着算法流程前三行写便是,
但这里要提到框架代码的"<strong>robustness</strong>".</p>
<p>尽管从分析流程上来看, 我们不应该分析<code>Node Entry</code>,
但是框架代码允许我们这样做.
这时框架代码会认为<code>Node Entry</code>是一条<code>nop Stmt</code>,
不会做constant update,
因此只要在<code>Init</code>部分对<code>Entry</code>的<code>inFact</code>和<code>outFact</code>都赋上初值,
就不需要在worklist中考虑<code>Entry</code>的处理了.</p>
<h3 id="worklistsolver-dosolveforward">WorkListSolver
doSolveForward</h3>
<p><strong>worklist</strong>是一种非常简单的算法,
笔者在此不对算法实现过多赘述.
注意在实现worklist的时候可以使用java自带的容器<code>Queue</code> &amp;
<code>ArrayList</code>.</p>
<p>关于<strong>worklist</strong>的初始化问题,
需要注意的是应当为其加入所有的<code>Node</code>,
如果只加入<code>Entry</code>的后继, 会产生问题, 笔者在此给出一个例子.
(感谢课程群中<a
href="https://github.com/rijuyuezhu"><strong>日居月诸</strong></a>大佬和另一位不知道github链接的大佬构造的反例)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;Assign: <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span>&gt; (constprop) --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] nop;     &#123;&#125;</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;   &#123;x=<span class="number">1</span>&#125;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] x = <span class="number">2</span>;   &#123;x=<span class="number">2</span>&#125;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] x = <span class="number">3</span>;   &#123;x=<span class="number">3</span>&#125;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">4</span>;   &#123;x=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L8</span>] y = x;   &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] <span class="keyword">return</span>;  &#123;x=<span class="number">4</span>, y=<span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中,
<code>Entry outFact</code>初始化为<code>&#123;&#125;</code>(没有参数),
然而<code>Stmt0</code> 的 <code>outFact</code>
同样初始化为<code>&#123;&#125;</code>,
如果只添加<code>Entry</code>的后继<code>&#123;Stmt0&#125;</code>,
会导致worklist在分析完<code>Stmt0</code>后错误终止.</p>
<h2 id="总结">总结</h2>
<p>本次实验应该是所有Assignment中代码量最多的一次, 细节也是让人头皮发麻,
还望能静下心来看代码和debug, 祝早日AC!</p>
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A3-DeadCode Detection</title>
    <url>/LabRecord-SPA-A3/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-3 Dead-Code
Detection.</strong></p>
<span id="more"></span>
<p>2024.11.7已更新</p>
<h2 id="实验信息食用指南">实验信息&amp;食用指南</h2>
<p>见本博客A1 &amp; A2</p>
<p><strong>Tips:</strong> 实验指南和框架代码仍然是最一手最正确的资料,
对于实验指南中已涉及的信息, 本记录不会过多赘述.</p>
<h2 id="实验目标">实验目标</h2>
<p>基于<strong>Tai-e</strong> 框架实现一个 <strong>死代码检测</strong>
算法.</p>
<h2 id="实验简析">实验简析</h2>
<p>实验指南没有给出实现的框架,
因此至此已有完成本次知识的全部基础知识(活跃变量分析 &amp;
常量传播算法).</p>
<p>故本次实验主要考察对A1, A2的实验理解,
有遗忘或有不清楚的读者还望移步至官方教学视频复习后再完成本次实验.</p>
<ul>
<li><p>死代码检测是一个<strong>Must Analysis</strong> ,
允许漏报而不允许错报.</p></li>
<li><p>由分支不可达的特性, 采用<strong>Forward Analysis</strong>
比较符合死代码检测的特性.</p></li>
<li><p>为了走一遍<strong>CFG</strong> 便得到结果,
我们可以将全部<code>Stmt</code>加入<code>DeadCodeSet</code>中,
将不是死代码的<code>Stmt</code>删去. 留下的便是死代码.</p></li>
<li><p>此处笔者采用<strong>BFS</strong>算法进行<strong>CFG</strong>遍历,
使用<code>Set Traveled</code>避免环路影响.</p></li>
</ul>
<h3 id="伪代码框架">伪代码框架</h3>
<p>死代码检测的大致框架伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">liveVarsResult &lt;- LiveVarsAnalysis(IR)</span><br><span class="line">constantResult &lt;- ConstantAnalysis(IR)</span><br><span class="line">DeadcodeSet &lt;- all stmt in IR</span><br><span class="line">TraveledSet &lt;- empty</span><br><span class="line">BFSlist &lt;- entry</span><br><span class="line"><span class="title function_">while</span><span class="params">(BFSlist is not empty)</span>&#123;</span><br><span class="line">    pickup a stmt from BFSlist</span><br><span class="line">    TraveledSet &lt;- stmt</span><br><span class="line">    <span class="comment">//handle jump Stmt</span></span><br><span class="line">    <span class="keyword">if</span> (stmt is <span class="keyword">if</span> or <span class="keyword">switch</span>)&#123;</span><br><span class="line">        DeadcodeSet remove stmt</span><br><span class="line">        <span class="comment">// ConditionExp is Constant may cause Unreachable DeadCode</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">if</span>/<span class="keyword">switch</span> ConditionExp is Constant by ConstantResult)&#123;</span><br><span class="line">            BFSlist &lt;- Target Stmt of Constant ConditionExp Path</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            BFS &lt;- succ of stmt not in Travaled</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//handle Assign Deadcode</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stmt is AssignStmt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stmt is not DeadAssign by LiveVarsResult || stmt has SideEffect)&#123;</span><br><span class="line">            DeadcodeSet remove stmt</span><br><span class="line">        &#125;</span><br><span class="line">        BFSlist &lt;- succ of stmt not in Travaled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//normal Stmt</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        DeadCodeSet remove stmt</span><br><span class="line">        BFSlist &lt;- succ of stmt not in Travaled</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p><strong><em>更新:</em></strong></p>
<blockquote>
<p><strong>Compare:</strong> <code>ir.getStmts()</code> &amp;
<code>cfg.getNodes()</code></p>
<p>笔者一开始未意识到这个问题, <strong>IR</strong>
中是不包含<code>Entry</code>和<code>Exit</code>的. 换句话说,
<code>Entry</code>和<code>Exit</code>是由<strong>CFG</strong> 生成的.
因此, 在初始化时,
需要使用<code>ir.getStmts()</code>而不是<code>cfg.getNodes()</code>,
否则在面对<strong>Infinity Loop</strong> 时,
<code>Exit</code>节点会错误的被当作<code>Dead Code</code>.</p>
</blockquote>
<hr />
<h2 id="cfg生成细节">CFG生成细节</h2>
<p>完成本实验最重要的部分莫过于<strong>CFG</strong> 的结构,
实验指南没有为我们提供所有的实现细节,
而且<code>CFGBuilder</code>部分的代码对我们来说是不公开的.
那我们该如何获取关于<strong>CFG</strong> 的细节?</p>
<h3 id="框架代码提供的接口">框架代码提供的接口</h3>
<p>好在<strong>tai-e</strong>框架为我们提供了<code>Class Assignment</code>来<a
href="https://tai-e.pascal-lab.net/intro/selfmade-testcases.html"><strong>分析自测样例</strong></a>,
输出<code>*.dot</code>文件到<code>./output/</code>目录下, 可以使用<a
href="https://graphviz.org/download/"><strong>[Graphviz]</strong></a>可视化<code>*.dot</code>文件.
使用细节见上述链接中的官方文档.</p>
<p>笔者所使用的<strong>IDE</strong> 为<strong>JetBrian IDEA 2023.1.4
Community</strong>版本, <code>Class Assignment</code>运行配置如下.</p>
<img src="/LabRecord-SPA-A3/pic1.png" class="" title="pic1">
<p>在终端中进入工作目录(此处为<code>output/</code>)执行以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dot -Tpng ClassMethod.dot -o ClassMethod.png</span></span><br></pre></td></tr></table></figure>
<p>然后我们就可以得到<code>*.dot</code>文件的可视化<strong>CFG</strong>
结果.</p>
<h3
id="根据自测样例推测cfg的生成逻辑">根据自测样例推测CFG的生成逻辑</h3>
<p>经过前两次的实验, 普通节点和跳转的关联顺序在<strong>CFG</strong>
中是简单的,
<code>for</code>和<code>while</code>的循环结构在<strong>tai-e</strong>中转化为简单的<code>goto stmt</code>.
因此此处笔者着重说明<code>If</code>和<code>Switch</code>在<strong>Tai-e</strong>
框架中的处理方式.</p>
<h4 id="控制流不可达代码">控制流不可达代码</h4>
<p>源代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControlFlowUnreachable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">        dead(); <span class="comment">// unreachable</span></span><br><span class="line">        x = <span class="number">3</span>; <span class="comment">// unreachable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dead</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码对应IR如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;ControlFlowUnreachable: <span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] <span class="keyword">return</span> x;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L6</span>] invokestatic &lt;ControlFlowUnreachable: <span class="keyword">void</span> <span class="title function_">dead</span><span class="params">()</span>&gt;();</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><strong>CFG</strong> 可视结果如下:</p>
<img src="/LabRecord-SPA-A3/pic2.png" class="" title="pic2">
<blockquote>
<p>不难发现,
控制流不可达代码在可视化图中的表示是独立于<strong>Entry</strong>到<strong>Exit</strong>
路径的子图</p>
</blockquote>
<h4 id="if-stmt">If Stmt</h4>
<p>我们先来看看最基础的情况:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableIfBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            z = <span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            z = <span class="number">200</span>; <span class="comment">// unreachable branch</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;UnreachableIfBranch: <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">10</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] y = <span class="number">1</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L7</span>] <span class="keyword">if</span> (x &gt; y) <span class="keyword">goto</span> <span class="number">4</span>;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">7</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] z = <span class="number">100</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">9</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L10</span>] z = <span class="number">200</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L12</span>] <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure>
<img src="/LabRecord-SPA-A3/pic3.png" class="" title="pic3">
<blockquote>
<p>可以从可视化<strong>CFG</strong> 中获取不少信息.</p>
<ul>
<li><code>[line]:if(ConditionExp) goto [line]</code>
是<code>if stmt</code>结构的入口(图中为<code>2: if(x &gt; y) goto 4</code>),
<strong>tai-e</strong>框架会为<code>if stmt</code>结构提供一个统一的<code>nop</code>出口(图中为<code>9: nop</code>).</li>
<li><code>if</code>结构会根据<code>ConditionExp</code>的<strong>T/F</strong>取值生成<code>Edge</code>,
分为<code>IF_FALSE</code>和<code>IF_TRUE</code>,
<code>Edge Target</code>分别为<strong>T/F</strong> 的代码块.
可以观测到框架会为<strong>T/F</strong>的代码块添加一个<code>nop stmt</code>作为代码块的起始(图中为<code>4: nop</code>和<code>7: nop</code>).</li>
</ul>
</blockquote>
<hr />
<p>如果我们不显式指定<code>else</code>结构:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableIfBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            z = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;UnreachableIfBranch: <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">10</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] y = <span class="number">1</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L7</span>] <span class="keyword">if</span> (x &gt; y) <span class="keyword">goto</span> <span class="number">4</span>;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">6</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] z = <span class="number">100</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L8</span>] nop;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L13</span>] <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure>
<img src="/LabRecord-SPA-A3/pic4.png" class="" title="pic4">
<blockquote>
<ul>
<li>可以看到<code>if</code>结构的<code>IF_FALSE</code>对应的代码块消失,
<code>IF_FALSE</code>直接跳转到<code>if</code>结构的结束<code>nop</code>语句.(图中为<code>6: nop</code>)</li>
</ul>
<blockquote>
<p><strong>Tips:</strong></p>
<p>如果显式写出<code>else</code>但<code>else</code>为空体,
<strong>tai-e</strong>框架会生成一条<code>nop</code>语句对应该<code>else</code>空体,
感兴趣的读者可以自行测试, 笔者在此不再赘述.</p>
<p>通过阅读框架代码中的<code>Class If extends JumpStmt</code>和<code>Class JumpStmt</code>可以知晓,
<code>If</code>将<code>JumpStmt</code>的成员变量<code>target</code>和对应方法(如<code>getTarget()</code>)和<code>If</code>结构中的<code>IF_TRUE</code>对应起来,
因此此时的<code>Edge IF_FALSE</code>其实等价于<code>FALL_THROUGH</code>,
<code>IF_FALSE</code>的<code>target</code>是一条指向真正<strong>False代码块</strong>的<code>goto stmt</code>.
通过阅读框架代码, 便不难理解为何<strong>CFG</strong>
要这样处理<code>IF</code>结构.</p>
</blockquote>
</blockquote>
<hr />
<p><code>if-else</code>的嵌套等价于普通的<code>if-else</code>的组合.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableIfBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            z = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; y) &#123;</span><br><span class="line">            z = <span class="number">200</span>; <span class="comment">// unreachable branch</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            z = <span class="number">300</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;UnreachableIfBranch: <span class="type">int</span> <span class="title function_">branch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">10</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] y = <span class="number">1</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L7</span>] <span class="keyword">if</span> (x &gt; y) <span class="keyword">goto</span> <span class="number">4</span>;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">7</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L8</span>] z = <span class="number">100</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">16</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L10</span>] <span class="keyword">if</span> (x &lt; y) <span class="keyword">goto</span> <span class="number">10</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">13</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L11</span>] z = <span class="number">200</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">15</span>;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L14</span>] z = <span class="number">300</span>;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L14</span>] nop;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L14</span>] nop;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L16</span>] <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure>
<img src="/LabRecord-SPA-A3/pic5.png" class="" title="pic5">
<h4 id="switch-stmt">Switch Stmt</h4>
<p>与<code>If</code>一样, 我们先来看看一般情况:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableSwitchBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                z = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                z = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                z = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                z = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;UnreachableSwitchBranch: <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] %intconst0 = <span class="number">3</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L5</span>] y = x &lt;&lt; %intconst0;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L9</span>] z = <span class="number">2</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L12</span>] z = <span class="number">4</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L13</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L13</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L15</span>] z = <span class="number">8</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L16</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L16</span>] nop;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L18</span>] z = <span class="number">0</span>;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L19</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">20</span>;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">18</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">19</span><span class="meta">@L7</span>] lookupswitch (y) &#123;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">4</span>-&gt;<span class="number">7</span>, <span class="number">8</span>-&gt;<span class="number">10</span>, <span class="keyword">default</span>-&gt;<span class="number">13</span>&#125;;</span><br><span class="line">[<span class="number">20</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">21</span><span class="meta">@L7</span>] <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<img src="/LabRecord-SPA-A3/pic6.png" class="" title="pic6">
<blockquote>
<ul>
<li>与<code>If</code>一致,
<code>[line]: [method]switch([var]) &#123;[branch]&#125;</code>是<code>Switch</code>结构的起点(图中为<code>19: lookupswitch(y) &#123;2-&gt;4, 4-&gt;7, 8-&gt;10, default-&gt;13&#125;</code>).
同样会生成一条<code>nop stmt</code>表示<code>Switch</code>结构的出口.</li>
<li>经过笔者的多次测试,
<strong>tai-e</strong>框架的<code>Switch</code>语句处理有些的微妙的奇怪之处.
与<code>If</code>不同,
<code>Switch</code>语句的入口在<code>line num</code>上位于<code>Switch</code>结构的最后部分,
到达该入口需要经过两条<code>nop stmt</code>,
并且会在<code>CASE</code>和<code>DEFAULT</code>代码块之外添加一个到<code>Switch</code>结构出口的<code>goto stmt</code>.
然而由于<code>DEFAULT</code>一定存在(下文会解释),
因此这条<code>goto</code>语句一定为死代码,
不存在一条从<code>Entry</code>到该语句的路径.</li>
</ul>
<blockquote>
<p><strong>Tips:</strong> 笔者认为这是一个非常奇怪的处理,
猜测可能跟Soot生成的字节码有关(<strong>Tai-e</strong>框架基于Soot搭建)
<strong>该猜想未证实</strong>.</p>
</blockquote>
<ul>
<li>笔者推测<code>CASE</code>和<code>DEFAULT</code>代码块中的第一条<code>nop</code>语句来源是<code>case 2:</code>和<code>default:</code>,
即<strong>Tai-e</strong>框架选择保留了原来的控制信息语句(控制信息在<strong>CFG</strong>中体现为<code>Edge</code>),
但将其替换成了<code>nop</code>语句(该推测在不显示指定<code>default</code>时得到部分证实).</li>
</ul>
</blockquote>
<hr />
<p>不显式指定<code>default</code>时:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableSwitchBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                z = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                z = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                z = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;UnreachableSwitchBranch: <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] %intconst0 = <span class="number">3</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L5</span>] y = x &lt;&lt; %intconst0;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">14</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L9</span>] z = <span class="number">2</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L12</span>] z = <span class="number">4</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L13</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L13</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L15</span>] z = <span class="number">8</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L16</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">17</span>;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L7</span>] lookupswitch (y) &#123;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">4</span>-&gt;<span class="number">7</span>, <span class="number">8</span>-&gt;<span class="number">10</span>, <span class="keyword">default</span>-&gt;<span class="number">17</span>&#125;;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">18</span><span class="meta">@L7</span>] <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<img src="/LabRecord-SPA-A3/pic7.png" class="" title="pic7">
<blockquote>
<ul>
<li>可以观测到<strong>CFG</strong>
会添加未被显式写出的<code>default</code>,
但不生成<code>default</code>指向的代码块(如果显示写出<code>default</code>但为空体,
会保留<code>nop</code>和<code>goto</code>跳转, 笔者在此不再赘述,
感兴趣的读者可以自行测试),
而是直接指向<code>Switch</code>结构的出口.</li>
</ul>
</blockquote>
<h4 id="case-break">case &amp; break</h4>
<p>了解java语法性质的读者应该理解笔者在本小结的标题.</p>
<p>我们来看看如下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 1&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 2&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Selected other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与预期不同, 这段代码的输出如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java Main</span></span><br><span class="line">Selected 2</span><br><span class="line">Selected 3</span><br><span class="line">Selected other</span><br></pre></td></tr></table></figure>
<p>当<code>switch</code>匹配2成功时, 如果不加<code>break</code>,
会顺次匹配在<code>case 2:</code>之后的所有<code>case</code>.
这称为<code>case</code>的<strong>穿透性</strong>.</p>
<hr />
<p>我们来看看<strong>CFG</strong>是如何处理这种情况的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnreachableSwitchBranch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                z = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// unreachable case</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                z = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// unreachable case</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                z = <span class="number">8</span>;</span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                z = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// unreachable case</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------------------- &lt;UnreachableSwitchBranch: <span class="keyword">void</span> <span class="title function_">lookupSwitch</span><span class="params">()</span>&gt; --------------------</span><br><span class="line">[<span class="number">0</span><span class="meta">@L4</span>] x = <span class="number">1</span>;</span><br><span class="line">[<span class="number">1</span><span class="meta">@L5</span>] %intconst0 = <span class="number">3</span>;</span><br><span class="line">[<span class="number">2</span><span class="meta">@L5</span>] y = x &lt;&lt; %intconst0;</span><br><span class="line">[<span class="number">3</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">16</span>;</span><br><span class="line">[<span class="number">4</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">5</span><span class="meta">@L9</span>] z = <span class="number">2</span>;</span><br><span class="line">[<span class="number">6</span><span class="meta">@L10</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">7</span><span class="meta">@L10</span>] nop;</span><br><span class="line">[<span class="number">8</span><span class="meta">@L12</span>] z = <span class="number">4</span>;</span><br><span class="line">[<span class="number">9</span><span class="meta">@L13</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">10</span><span class="meta">@L13</span>] nop;</span><br><span class="line">[<span class="number">11</span><span class="meta">@L15</span>] z = <span class="number">8</span>;</span><br><span class="line">[<span class="number">12</span><span class="meta">@L15</span>] nop;</span><br><span class="line">[<span class="number">13</span><span class="meta">@L18</span>] z = <span class="number">0</span>;</span><br><span class="line">[<span class="number">14</span><span class="meta">@L19</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">15</span><span class="meta">@L7</span>] <span class="keyword">goto</span> <span class="number">19</span>;</span><br><span class="line">[<span class="number">16</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">17</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">18</span><span class="meta">@L7</span>] lookupswitch (y) &#123;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">4</span>-&gt;<span class="number">7</span>, <span class="number">8</span>-&gt;<span class="number">10</span>, <span class="keyword">default</span>-&gt;<span class="number">12</span>&#125;;</span><br><span class="line">[<span class="number">19</span><span class="meta">@L7</span>] nop;</span><br><span class="line">[<span class="number">20</span><span class="meta">@L7</span>] <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<img src="/LabRecord-SPA-A3/pic8.png" class="" title="pic8">
<blockquote>
<ul>
<li>这是一个符合预期的处理, 也是一个非常自然而然的想法.</li>
</ul>
</blockquote>
<h2 id="deadcodedetection">DeadCodeDetection</h2>
<p>本次实验只需要完成<code>Class DeadCodeDetection</code>中的<code>analysis()</code>方法.</p>
<h3 id="准备工作">准备工作</h3>
<p>将A1,
A2中完成的<strong>活跃变量分析</strong>和<strong>常量传播</strong>代码copy到本次实验A3的工作目录中.
需要注意的是,
本次活跃变量分析部分不使用<code>IteratorSovler</code>而是使用<code>BackwardWorklist</code>,
此部分代码需要额外完成.</p>
<blockquote>
<p><strong>Tips:</strong>
不要过多的依赖诸如<strong>ChatGPT</strong>或<strong>Copilot</strong>的书写代码功能,
其生成的代码很可能存在潜在的不易发现的bug(<del>你猜我为什么会加这个Tips</del>).
实际上, <code>JetBrain IDEA</code>的成员变量和方法补全功能已经足够好使,
使用<strong>Copilot</strong>的代码补全反而可能造成一些不必要的麻烦.</p>
</blockquote>
<h3 id="控制流不可达代码实现细节">控制流不可达代码实现细节</h3>
<p>实验指南已写明该部分的具体原理, 此处涉及一些实现细节.</p>
<ul>
<li>通过恰当的维护<code>BFSlist</code>可以仅遍历可达代码(主要处理<code>If</code>和<code>Switch</code>),
因此初始化所有的<code>Stmt</code>为<code>DeadCode</code>,
遍历到即排除其为死代码是一个不错的选择.</li>
<li>无论使用<strong>BFS</strong>还是<strong>DFS</strong>,
都要处理环路引起的<strong>Infinity Loop</strong>,
一个简单的方法是创建一个<code>Traveled Set</code>保证每个<code>Stmt</code>仅会被遍历到一次(同样的,
对于<code>BFSList</code>维护也可以通过类似的技巧提升效率).</li>
<li>遍历一次就能得到结果依托于<strong>不需要处理由删除死代码产生的死代码</strong>(例子可见实验指南).</li>
<li>关于图的遍历方式,
笔者在此推荐使用<code>CFG</code>的顶层方法<code>getSuccOf()</code>和<code>getOutEdge()</code>,
而不是<code>If Stmt</code>和<code>Switch Stmt</code>中的方法.
这两个跳转语句的实现因为继承自<code>JumpStmt</code>所以细节上可能与想象中有所差异,
如果一定要使用,
还请小心谨慎的阅读<code>API</code>注释以获取详细信息.</li>
<li>关于<code>ConditionExp</code>的处理,
可以复用A2中实现的<code>evaluate()</code>方法.</li>
</ul>
<h3 id="无用赋值代码实现细节">无用赋值代码实现细节</h3>
<p>同上, 原理部分请参见实验指南.</p>
<ul>
<li>继承<code>AssignStmt</code>的子类有足足十几个,
可以从lib反编译或者科研版代码中获取相关细节, 关于<strong>副作用(Side
Effect)</strong>在框架代码中已给出<code>API</code>,
解释了哪些派生类可能引起副作用.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true if given RValue has no side effect, otherwise false.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasNoSideEffect</span><span class="params">(RValue rvalue)</span> &#123;</span><br><span class="line">    <span class="comment">// new expression modifies the heap</span></span><br><span class="line">    <span class="keyword">if</span> (rvalue <span class="keyword">instanceof</span> NewExp ||</span><br><span class="line">            <span class="comment">// cast may trigger ClassCastException</span></span><br><span class="line">            rvalue <span class="keyword">instanceof</span> CastExp ||</span><br><span class="line">            <span class="comment">// static field access may trigger class initialization</span></span><br><span class="line">            <span class="comment">// instance field access may trigger NPE</span></span><br><span class="line">            rvalue <span class="keyword">instanceof</span> FieldAccess ||</span><br><span class="line">            <span class="comment">// array access may trigger NPE(None Pointer Exception)</span></span><br><span class="line">            rvalue <span class="keyword">instanceof</span> ArrayAccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rvalue <span class="keyword">instanceof</span> ArithmeticExp) &#123;</span><br><span class="line">        ArithmeticExp.<span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> ((ArithmeticExp) rvalue).getOperator();</span><br><span class="line">        <span class="comment">// may trigger DivideByZeroException</span></span><br><span class="line">        <span class="keyword">return</span> op != ArithmeticExp.Op.DIV &amp;&amp; op != ArithmeticExp.Op.REM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>小心, 不要忘记判断<code>lValue</code>是否为<code>Var</code>,
与之前相同, 我们只需要处理<code>Var</code>类型的语句.</li>
</ul>
<h2 id="总结">总结</h2>
<p>本次实验难度某种意义上低于A1, 是一个比较简单的实验,
旨在考察对分析结果的应用能力. 祝早日AC!</p>
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A5-Context Insensitive Pointer Analysis</title>
    <url>/LabRecord-SPA-A5/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-5 Context
Insensitive Pointer Analysis.</strong></p>
<span id="more"></span>
<blockquote>
<p>这些规则与你在课上所学到的规则非常相似
<strong>（甚至更简单）</strong>. ——A5实验指南</p>
</blockquote>
<p>对......对吗？</p>
<h2 id="实验目标">实验目标</h2>
<p>基于<strong>tai-e</strong>框架实现非上下文敏感的指针分析.</p>
<h2 id="preparation">Preparation</h2>
<p><strong>Hint:</strong> A5和A6不再像之前的实验般友好,
没有理解上课时所讲算法,
实验指南或框架代码的人会被这两次实验狠狠地拷打.(笔者已感到有些汗流浃背了)</p>
<h2 id="算法理论">算法理论</h2>
<h3 id="算法伪代码">算法伪代码</h3>
<img src="/LabRecord-SPA-A5/pic1-1.png" class="" title="pic1-1">
<img src="/LabRecord-SPA-A5/pic1-2.png" class="" title="pic1-2">
<h3 id="规则形式化表述">规则形式化表述</h3>
<h4 id="分析语句类型">分析语句类型</h4>
<img src="/LabRecord-SPA-A5/pic1-3.png" class="" title="pic1-3">
<h4 id="符号体系">符号体系</h4>
<img src="/LabRecord-SPA-A5/pic1-4.png" class="" title="pic1-4">
<h4 id="对象传递规则">对象传递规则</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">Kind</th>
<th style="text-align: center;">Stmt</th>
<th style="text-align: center;">Rule</th>
<th style="text-align: center;">PFG Edge</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">New</td>
<td style="text-align: center;"><code>i : x = new T()</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{}{o_i
\in pt(x)}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\text{N/A}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Assign</td>
<td style="text-align: center;"><code>x = y</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{o_i
\in pt(y)}{o_i \in pt(x)}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(x \leftarrow
y\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Field Store</td>
<td style="text-align: center;"><code>x.f = y</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{o_i
\in pt(x),\ o_j \in pt(y)}{o_j \in pt(o_i.f)}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(y \leftarrow
o_i.f\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Field Load</td>
<td style="text-align: center;"><code>y = x.f</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{o_i
\in pt(x),\ o_j \in pt(o_i.f)}{o_j \in pt(y)}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(y \leftarrow
o_i.f\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Static Store</td>
<td style="text-align: center;"><code>T.f = y</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{o_i
\in pt(y)}{o_i \in pt(T.f)}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T.f
\leftarrow y\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Static Load</td>
<td style="text-align: center;"><code>y = T.f</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{o_i
\in pt(T.f)}{o_i \in pt(y)}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(y \leftarrow
T.f\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Array Store</td>
<td style="text-align: center;"><code>x[i] = y</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{o_u
\in pt(x),\ i_v \in pt(y)}{o_v \in pt(o_u[*])}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(o_u[*]
\leftarrow y\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Array Load</td>
<td style="text-align: center;"><code>y = x[i]</code></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{o_u
\in pt(x),\ o_v \in pt(o_u[*])}{o_v \in pt(y)}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(y \leftarrow
o_u[*]\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Call</td>
<td
style="text-align: center;"><code>l : r = x.k(a1, ..., an)</code></td>
<td style="text-align: center;"><span
class="math inline">\(\dfrac{\begin{array}{c} o_i \in pt(x),\ m =
Dispatch(o_i,\ k),\\ o_u \in pt(aj),\ i \leq j \leq n,\\ o_v \in
pt(m_{ret})\end{array}}{\begin{array}{c} o_i \in pt(m_{this}),\\ o_u \in
pt(m_{pj}),\ 1 \leq j \leq n,\\ o_v \in pt(r)\end{array}}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{array}{c}a1 \rightarrow m_{p1} \\ ... \\ an
\rightarrow m_{pn} \\ r \leftarrow m_{ret}\end{array}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Static Call</td>
<td style="text-align: center;"><code>r = T.k(a1, ..., an)</code></td>
<td style="text-align: center;"><span
class="math inline">\(\dfrac{\begin{array}{c} o_u \in pt(aj),\ i \leq j
\leq n,\\ o_v \in pt(m_{ret}) \end{array}}{\begin{array}{c} o_u \in
pt(m_{pj}),\ 1 \leq j \leq n,\\ o_v \in pt(r) \end{array}}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{array}{c} a1 \rightarrow m_{p1} \\ ... \\
an \rightarrow m_{pn} \\ r \leftarrow m_{ret} \end{array}\)</span></td>
</tr>
</tbody>
</table>
<h2 id="部分框架代码带读">部分框架代码带读</h2>
<p>该部分是为分析实际伪代码的书写,
因为课程上的算法和框架中的实现不完全一致, 主要体现在 <strong>Stmt in
Method</strong> 这一部分. 笔者就部分关键框架代码进行讲解.</p>
<h3 id="概览">概览</h3>
<p><code>graph.callgraph</code>,
<code>ir</code>包中的大部分文件在先前的实验中已经了解,
如有遗忘或模糊可以参考先前的实验指南或自行阅读相关框架代码.</p>
<p><strong>着重注意</strong>
<code>Stmt</code>的层次结构和<code>Stmt</code>中包含的信息类型的继承关系(如<code>Var</code>,
<code>LValue</code>等),
以及<code>JMethod</code>和<code>IR</code>相关信息,
较为重要的是在A4中如何获取形参和实参.</p>
<p>新的文件主要集中在<code>pta</code>包中, 笔者在此着重介绍该部分.</p>
<h3 id="pointer-pointstoset">Pointer &amp; PointsToSet</h3>
<p>指针分析中最重要的两个类型, 前者是在指针流图中的节点,
后者存储指向信息.</p>
<p>在框架代码中,
每个<code>Pointer</code>包含一个<code>PointsToSet</code>实例,
包含该指针指向的对象信息.</p>
<p>通过阅读<code>pointsToSet</code>源码,
不难看出是由基本的<code>Set</code>实例化得到,
支持<code>Set</code>的常规基本操作.</p>
<h4 id="varptr-instancefield-staticfield-arrayindex">VarPtr &amp;
InstanceField &amp; StaticField &amp; ArrayIndex</h4>
<p>代表了四种指针类型, 均继承自<code>Pointer</code>.</p>
<p>与<code>Pointer</code>相比没有太大的不同,
仅根据类型不同添加了如何获取指针信息的API.</p>
<h3 id="pointerflowgraph">PointerFlowGraph</h3>
<p>本次实验中最重要的类之一, 存储了指针分析过程中的指针流信息.</p>
<p>其实现运用了多个<code>Map</code>, 其提供的API包括两类:</p>
<ul>
<li><p>图结构的<code>addEdge()</code>和<code>getSuccOf()</code>,
这两个API可以修改和遍历<strong>PFG</strong>.</p></li>
<li><p>图信息的四种<code>get</code>方法,
由于<code>JMethod</code>,<code>IR</code>以及<code>Obj</code>与<code>Pointer</code>并不是直接关联,
该类方法提供了一个获取对应类型指针的API. &gt; <strong>Tips:</strong>
举个例子, 对于<code>Stmt</code>类型的Assign语句<code>x = y</code>,
可以解析得到<code>Var</code>类型的<code>x</code>和<code>y</code>,
通过<code>getVarPtr()</code>方法就可以得到<code>Var</code>类型的<code>x</code>,<code>y</code>在<strong>PFG</strong>中对应的指针.</p></li>
</ul>
<h3 id="cipta-ciptaresult-resultprocessor">CIPTA &amp; CIPTAResult &amp;
ResultProcessor</h3>
<p>这些类与实现的核心逻辑联系不大,
这三个类负责处理指针分析算法的前后工作, 提供了初始化,
执行指针分析和解析指针分析结果的API. 更具体的信息可以阅读框架代码.</p>
<h3 id="heapmodel-obj">HeapModel &amp; Obj</h3>
<p>该部分对应了指针分析原理中的<strong>堆抽象</strong>部分.</p>
<p>内部涉及的API比较简单, 且大多数不需要关注, 需要注意的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapModel</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the abstract object for given new statement.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Obj <span class="title function_">getObj</span><span class="params">(New allocSite)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法提供了获取<code>Stmt New</code>语句创建的对象的API.</p>
<blockquote>
<p><strong>Tips:</strong> 指针分析中最特殊的语句便是<code>New</code>,
只有<code>New</code>语句可以创建对象,
指针流图中所有的对象均是由<code>New</code>方法创建出来的.
因此只有<code>New</code>语句需要通过与<strong>抽象堆</strong>交互获取对象,
其余语句获取对象均由<strong>PFG</strong>中传递得到.</p>
</blockquote>
<h3 id="stmt-package">Stmt Package</h3>
<p>本次实验所涉及的<code>Stmt</code>类型继承关系为<code>Stmt-&gt;AbstractStmt-&gt;DefinitionStmt-&gt;AssignStmt-&gt;(FieldStmt)</code></p>
<p>其中大部分API在之前的实验中已经熟悉了.
以下介绍一些本实验中可能涉及的细节.</p>
<h4 id="fieldstmt">FieldStmt</h4>
<p>该类提供了<code>getFieldAccess()</code>和<code>getFieldRef()</code>,
其中后者比较重要,
可以通过<code>fieldStmt.getFieldRef().resolve()</code>获得<code>JField field</code>.(实验指南中已指出)</p>
<h4 id="accept-可选">accept() *可选</h4>
<p>详见<a href="#stmtvisitor-可选"><strong>StmtVisitor</strong></a></p>
<h3 id="worklist">WorkList</h3>
<p>对应算法伪代码中的WorkList.
(笔者较为疑惑为何其内部节点称为<code>Entry</code>)</p>
<h3 id="callgraph-abstractcallgraph-defaultcallgraph">CallGraph &amp;
AbstractCallGraph &amp; DefaultCallGraph</h3>
<p>CallGraph在实验A4中已经接触过了, 笔者在此不再赘述.</p>
<h3 id="stmtvisitor-可选">StmtVisitor *可选</h3>
<p>访问者模式不是完成本实验必要的部分, 如果不打算使用访问者模式,
可以跳过这一部分.</p>
<p><code>Solver</code>中的<code>class StmtProcessor</code>继承自该类,
用以实现<strong>访问者设计模式</strong>.
内部重载了多个<code>visit()</code>方法, 用以访问不同的类型.</p>
<p>需要注意的是, 访问者模式需要被访问的类支持这一设计,
具体表现为其包含<code>accept()</code>方法.</p>
<p>访问者用以优雅地替代大量<code>instanceof</code>的判断,
由<strong>访问类</strong>(本次实验中为<code>class StmtProcessor</code>)的函数重载巧妙地避开大量的类型判定.</p>
<p>笔者在此以<code>New</code>,<code>Copy</code>和<code>StmtProcessor</code>为例具体说明.</p>
<p>在本次实验中, <code>addReachable()</code>需要遍历新方法中的所有语句,
对不同语句做不同处理.</p>
<img src="/LabRecord-SPA-A5/pic1-5.png" class="" title="pic1-5">
<p>显然这些处理从封装的角度看不应当嵌入到<code>New</code>和<code>Assign</code>类的内部,
而是应当放在外部进行处理, 那么如果不使用访问者模式,
写出来的代码大概是长这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> New newStmt)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> Assign assignStmt)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的代码一点也不优雅, 充斥着大量的冗余判断.
访问者模式可以很好的解决这个问题.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">New</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">accept</span><span class="params">(StmtVisitor&lt;T&gt; visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处略去Assign</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StmtVisitor</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">visit</span><span class="params">(New stmt)</span>;</span><br><span class="line">    T <span class="title function_">visit</span><span class="params">(Assign stmt)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StmtProcessor</span> <span class="keyword">implements</span> <span class="title class_">StmtVisitor</span>&lt;Void&gt;&#123;</span><br><span class="line">    Void <span class="title function_">visit</span><span class="params">(New stmt)</span>&#123;</span><br><span class="line">        <span class="comment">//handle new stmt</span></span><br><span class="line">    &#125;</span><br><span class="line">    Void <span class="title function_">visit</span><span class="params">(Assign stmt)</span>&#123;</span><br><span class="line">        <span class="comment">//handle assign stmt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时将遍历<code>Stmt</code>的代码改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">    stmt.accept(stmtProcessor); <span class="comment">// 已经实例化过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑应该是不难理解的,
在<code>instanceof</code>实现的遍历中, 就好像是一个提供多种服务的公司,
挨个询问客户购买的是什么服务然后提供服务(在这里简单假设每家只购买了一种服务).而访问者模式中,
客户向公司发送"请求",
公司从多个服务中选择正确的为客户进行服务(函数重载).</p>
<p>在访问者模式中,
<code>New</code>和<code>Assign</code>通过<code>accept()</code>方法向<code>StmtProcessor</code>提供了自己的类型,
并在该方法中调用来自<code>StmtProcessor</code>的处理方法<code>visit()</code>.
从面向对象设计角度来看, 是一种优于前者的设计模式.</p>
<h2 id="框架代码中的算法">框架代码中的算法</h2>
<h3 id="s-s_m">S &amp; S_m</h3>
<blockquote>
<p>这里部分参考了<a
href="https://github.com/RicoloveFeng"><strong>RicoloveFeng|SPA-Freestyle-Guidance</strong></a>中的内容.</p>
</blockquote>
<p>这里是与课上讲述的算法区别最大的地方.
阅读<code>Sovler</code>中的代码, 发现该部分是不存在对应关系的.</p>
<p>重读定义<code>Var</code>的文件,
会发现一些之前没有用到的函数在本次实验中利用了起来,
如<code>addLoadField()</code>, <code>getLoadFields()</code>.</p>
<p>这些方法就是"隐式"维护S和S_m的API(说<strong>隐式</strong>是因为对于完成实验来说,
该部分不需要详细了解).</p>
<p>这部分实现了S和S_m的"自动"维护, 即通过生成<strong>IR</strong>,
和<code>CallGraph</code>中的<code>addMethod()</code>进行维护.
具体的细节可以阅读源码.</p>
<p>对于完成本次实验来说, 只需要知道不需要处理有关S和S_m的工作了,
在需要获取相关信息时,
直接通过<code>Var</code>中的<code>getXXX()</code>获取即可.</p>
<h3 id="基于框架代码的算法伪代码">基于框架代码的算法伪代码</h3>
<p><strong>Tips:</strong> 该部分的代码不会严格遵循框架代码中的API,
仅作示例.</p>
<p><strong>推荐完成顺序:</strong>
优先实现顶层方法<code>analysis()</code></p>
<h4 id="analysis">analysis()</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">analysis</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 所有的初始化工作框架代码中已经完成, 包括添加Entry Method</span></span><br><span class="line">    <span class="comment">// 这里只需要处理while WorkList NOT Empty即可</span></span><br><span class="line">    <span class="keyword">while</span>(WorkList.isNotEmpty())&#123;</span><br><span class="line">        &lt;n, pts&gt; = WorkList.poll() <span class="comment">// &lt;Pointer, PointsToSet&gt;</span></span><br><span class="line">        delta_pts = propagate(n, pts)</span><br><span class="line">        <span class="keyword">if</span>(n <span class="keyword">instanceof</span> VarPtr x)&#123;</span><br><span class="line">            foreach oi in delta_pts <span class="keyword">do</span>&#123;</span><br><span class="line">                foreach x.getStoreFields() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// x.f = y</span></span><br><span class="line">                    addEdge(y, oi.f)</span><br><span class="line">                foreach x.getLoadFields() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// y = x.f</span></span><br><span class="line">                    addEdge(oi.f, y)</span><br><span class="line">                foreach x.getStoreArrays() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// x[i] = y</span></span><br><span class="line">                    addEdge(y, oi[*])</span><br><span class="line">                foreach x.getLoadArrays() <span class="keyword">do</span></span><br><span class="line">                    <span class="comment">// y = x[i]</span></span><br><span class="line">                    addEdge(oi[*], y)</span><br><span class="line"></span><br><span class="line">                processCall(x, oi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该部分的逻辑比较简单, 照着算法写就行,
获取跟<code>Var x</code>相关的<code>Stmt</code>的方法在<a
href="#s--s_m"><strong>S &amp; S_m</strong></a>部分已经讲过,
此处不再赘述.</p>
<p>不要忘记依手册在此处完成对Array的处理.</p>
<h4 id="addpfgedge">addPFGEdge()</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addPFGEdge</span><span class="params">(Pointer source, Pointer target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointerFlowGraph.addEdge(source, target))&#123;</span><br><span class="line">        <span class="comment">// form API: true mean not include</span></span><br><span class="line">        <span class="keyword">if</span> (source.getPointsToSet().isNotEmpty())&#123;</span><br><span class="line">            WorkList.add(&lt;target, source_pts&gt;) <span class="comment">// &lt;Pointer, PointsToSet&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是照着算法写即可.</p>
<h4 id="propagate">propagate()</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PointsToSet <span class="title function_">propagate</span><span class="params">(Pointer pointer, PointsToSet pointsToSet)</span>&#123;</span><br><span class="line">    delta_pts = pointsToSet - pointer.getPointsToSet();</span><br><span class="line"></span><br><span class="line">    pointer_pts += delta_pts;</span><br><span class="line"></span><br><span class="line">    foreach pointerpointerFlowGraph.getSuccsOf(pointer) <span class="keyword">do</span></span><br><span class="line">        <span class="comment">//succ of pointer node</span></span><br><span class="line">        WorkList.add(&lt;succ, delta_pts&gt;) <span class="comment">// &lt;Pointer, PointsToSet&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="processcall">processCall</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">processCall</span><span class="params">(Var <span class="keyword">var</span>, Obj recv)</span> &#123;</span><br><span class="line">    foreach <span class="keyword">var</span>.<span class="keyword">var</span>.getInvokes() <span class="keyword">do</span></span><br><span class="line">        <span class="comment">// [invoke] l: r = x.k(a1,..., an)</span></span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">method</span> <span class="operator">=</span> resolveCallee(recv, invoke)</span><br><span class="line">        <span class="keyword">if</span>(method thisVar is not empty)&#123;</span><br><span class="line">            <span class="comment">//means is not Static</span></span><br><span class="line">            <span class="comment">//also can use !invoke.isStatic()</span></span><br><span class="line">            workList.add(&lt;method_this, recv&gt;);</span><br><span class="line">            <span class="keyword">if</span>(callGraph.addEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>(callKind, invoke, method)))&#123;</span><br><span class="line">                <span class="comment">//transfer paramters &amp; return Var</span></span><br><span class="line">                foreach paramters : addEdge();</span><br><span class="line">                returnVar : addEdge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一些细节需要注意:</p>
<ul>
<li>如何处理<code>JMethod</code>在A4中已经接触过了,
可以通过<code>method.getIR().getThis()</code>获取该方法的this Var,
然后再通过<strong>PFG</strong>就能获取this Pointer了. 如果还有印象的话,
A4中通过<code>CallGraphs.getCallKind()</code>来获取<code>CallKind</code>,
在本次实验沿用该方法即可.</li>
<li>在这里不处理Static Call, 通过判断是否存在this指针,
<code>isStatic()</code>方法都可以判断(尽管从实际上分析,
此处不应该也不可能出现Static Call)</li>
<li>之后的处理参数和返回值同A4,
同样需要注意返回值是否被丢弃或有复数个返回值.</li>
</ul>
<h4 id="addreachable">addReachable()</h4>
<p>如果不使用访问者模式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addReachable</span><span class="params">(JMethod method)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callGraph.addReachableMethod(method))&#123;</span><br><span class="line">        <span class="comment">//form API : true means not include</span></span><br><span class="line">        <span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> New)&#123;</span><br><span class="line">                WorkList.add(stmt_def, obj)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> Assign)&#123;</span><br><span class="line">                addEdge(right, left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> StoreField &amp;&amp; isStatic)&#123;</span><br><span class="line">                addEdge(right, left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> LoadField &amp;&amp; isStatic)&#123;</span><br><span class="line">                addEdge(right, left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt <span class="keyword">instanceof</span> Invoke &amp;&amp; isStatic)&#123;</span><br><span class="line">                <span class="comment">//same as processCall</span></span><br><span class="line">                <span class="comment">//except do not need to add &lt;this, obj&gt; to workList</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用访问者模式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addReachable</span><span class="params">(JMethod method)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callGraph.addReachableMethod(method))&#123;</span><br><span class="line">        <span class="keyword">for</span>(Stmt stmt : method.getIR().getStmts())&#123;</span><br><span class="line">            stmt.accept(stmtProcessor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑同不使用访问模式的<code>instanceof</code>成立后执行的方法.
将这些方法写进<code>StmtProcessor</code>中的<code>visit()</code>即可.</p>
<blockquote>
<p><strong>Tips:</strong> 为什么要在这里处理静态方法和字段?</p>
<p>在回答这个问题之前,
不妨思考一下为什么非静态指针要在<code>analysis()</code>中如此处理.
因为不论是字段还是方法, 都需要"resolve"到一个确定的结果时,
才能进行分析和对象传递. 而静态方法和静态字段的对象是唯一确定的,
在遍历到一个新方法时只需要处理一次.</p>
</blockquote>
<ul>
<li>框架代码中的<code>CallGraph</code>包含了<code>RM</code>,
阅读相关API以获取详细信息.</li>
<li>如何根据<code>Stmt</code>信息获取指针<code>Pointer</code>的方法在上文框架代码分析中已经指出.
如果该方法在后期完成, 此时应当已经知道如何获取所需参数和类型.</li>
<li>需要注意的是在此仍然需要通过<code>resolveCallee()</code>方法获得静态方法,
参数设置为<code>recv = null</code>即可.</li>
</ul>
<h2 id="总结">总结</h2>
<p>指针分析还是相当硬核的, 尽管实验框架已经化简了其中部分内容,
这仍然是一个较困难的实验.</p>
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A6-Context Sensitive Pointer Analysis</title>
    <url>/LabRecord-SPA-A6/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-6 Context Sensitive
Pointer Analysis.</strong></p>
<span id="more"></span>
<p>笔者写该实验写了一个下午之后注意力涣散了😇(†升天†)</p>
<blockquote>
<p><strong>Tips:</strong> 本次实验的指南中存在省略,
因此Debug过程可能会包含一些困难.</p>
</blockquote>
<h2 id="实验目标">实验目标</h2>
<p>基于<strong>tai-e</strong>框架实现上下文敏感的指针分析.</p>
<h2 id="preparation">Preparation</h2>
<ul>
<li><p><strong>确保</strong>理解了CI和CS的指针分析理论部分知识,
笔者不负责讲解课程中已经讲述过的理论知识.</p></li>
<li><p><strong>确保</strong>理解了实验指南中的注意事项和框架中新增以及修改的源码,
否则在阅读本实验记录可能会遇到"共识"缺失的问题.</p></li>
</ul>
<h2 id="理论部分">理论部分</h2>
<p>总体来说, 上下文敏感指针分析算法和理论与上下文非敏感指针分析区别不大,
大体框架是一致的. 笔者不再像A5中整理, 不同的部分会在下文需要时给出.</p>
<h2 id="框架代码">框架代码</h2>
<p>比起A5的框架代码变动并不大, 笔者在此简要解释一些要点.</p>
<img src="/LabRecord-SPA-A6/pic1-1.png" class="" title="pic1-1">
<ul>
<li><p>手册中该部分提及了上下文敏感指针分析中最重要的部分之一,
<code>CSElement</code>和<code>Pointer</code>是本次实验主要操作的对象.</p></li>
<li><p>在正式写实验之前请思考这两者间的不同,
如有混淆可能会影响实验的完成.(明晰两者的区别才知道该去哪里找API,
该调用什么方法, 毕竟ppt上的算法是类型"模糊"的)</p></li>
<li><p>与A5相同, <code>Pointer</code>与<code>Obj</code>相对独立,
但请注意这里的<code>CSElement</code>与<code>Element</code>同样相对独立,
<code>Element</code>与<code>Context</code>组合形成了<code>CSElement</code>,
因此许多API需要先取出<code>Context</code>或<code>Element</code>才能使用.
具体如何取出请参阅框架代码.</p></li>
<li><p><code>PointsToSets</code>的实例化需要调用<code>PointsToSetsFactory</code>,
这点与A5不尽相同.</p></li>
<li><p>上下文敏感指针信息不再通过<code>PointerFlowGraph</code>获取而是<code>CSManager</code>.</p></li>
<li><p><code>Solver</code>中提供了<code>private final ContextSelector contextSelector</code>来获取算法中的<code>select()</code>方法,
该部分的实现对应实验指南的<strong>Task2</strong>.
对于<strong>Task1</strong>, 只需要知道可以调用其中的方法获取<span
class="math inline">\(c^t\)</span>上下文即可.</p></li>
</ul>
<h2 id="task1-实现上下文敏感指针分析">Task1 实现上下文敏感指针分析</h2>
<p>与A5相同, 推荐先完成顶层方法<code>analysis()</code>.</p>
<blockquote>
<p><strong>Tips:</strong>
在写代码时<strong>一定一定</strong>要注意上下文, 变量命名时要有区分度,
否则<strong>DEBUG</strong>时会充满痛苦.</p>
</blockquote>
<p><strong>重要:</strong> 虽然<code>Stmt</code>中不包含上下文信息,
但框架代码中提供了丰富的API来根据<code>Stmt</code>的信息获取上下文信息.
同时可以确定的已知的相同上下文可以直接拿过来使用.
框架代码和算法原理确保了上述两点都是正确的.</p>
<h3 id="analysis">analysis()</h3>
<ul>
<li>逻辑上与上下文非敏感一致,
区别在于需要做例如<code>Var</code>与<code>CSVar</code>的转化,
传入<code>addPFGEdge()</code>的参数需要附上上下文,
可通过<code>csManager.getXXX()</code>获取.</li>
<li>别忘了处理<strong>Array Store/Load</strong>,
以及判断<code>Field</code>是否为静态字段.</li>
</ul>
<h3 id="addpfgedge">addPFGEdge()</h3>
<ul>
<li>该函数内不涉及对上下文的关注,
与A5中的<code>addPFGEdge()</code>字符级一致,
可以直接<code>Crtl + C/V</code>.</li>
</ul>
<h3 id="propagate">propagate()</h3>
<ul>
<li>同样不关注上下文信息, 逻辑一致,
但不同的是<code>PointsToSet</code>的实例化,
需要通过<code>PointsToSetFactory</code>完成.</li>
</ul>
<h3 id="processcall">processCall()</h3>
<ul>
<li>注意该过程涉及三个不同的上下文: <code>CSVar recv</code>的上下文<span
class="math inline">\(c\)</span>,
<code>CSObj recvObj</code>的上下文<span
class="math inline">\(c&#39;\)</span>,
和通过<code>select</code>选择出的上下文<span
class="math inline">\(c^t\)</span>.
在使用上下文时请确保使用的是正确的上下文.</li>
<li>上下文<span
class="math inline">\(c^t\)</span>的获取可通过<code>contextSelector.selectContext()</code>方法获取.</li>
<li>Callee的<code>thisVar</code>以及参数和返回值的获取在A4,
A5中已经指出, 如有遗忘请进行复习.</li>
<li><code>callGraph.addEdge()</code>中需要新建<code>Edge</code>,
其中参数<code>CallKind</code>可以通过<code>CallGraphs.getCallKind()</code>获取(通过A4了解).
需要注意的是,
<code>CallGraphs</code>类虽然在本次实验中并未显式放在<code>src\</code>目录下,
但仍然可以使用.</li>
<li>其余要点在A4和A5中已经提到过, 在此不再赘述.</li>
</ul>
<h3 id="addreachable">addReachable()</h3>
<ul>
<li><p>使用访问者模式时代码依旧简洁,
但是需要注意的是此次使用<code>StmtProcessor</code>类时需要为每个方法实例化一个<code>StmtProcessor</code>.</p>
<blockquote>
<p><strong>Tips:</strong> 原因比较直接, 为了区分上下文信息.
本次实验中处理语句需要用到<code>CSMethod</code>的上下文信息.</p>
</blockquote></li>
</ul>
<h4 id="class-stmtprocessor">Class StmtProcessor</h4>
<p>实现访问者模式的类, 在完成该部分时存在一些注意事项.</p>
<ul>
<li><p><code>Copy</code>,
<code>Static StoreField</code>和<code>Static LoadField</code>与A5几乎没有区别,
注意传入的参数转换为带上下文的即可.</p></li>
<li><p>算法伪代码中对<code>New</code>的处理和实际代码略有出入,
主要体现在上下文<span class="math inline">\(c\)</span>上.
<code>Obj</code>的上下文要通过<code>contextSelector.selectHeapContext()</code>获取.</p>
<blockquote>
<p>笔者在此简要的解释一下.</p>
<img src="/LabRecord-SPA-A6/pic1-2.png" class="" title="pic1-2">
<p>算法中将<span class="math inline">\(x\)</span>和<span
class="math inline">\(o_i\)</span>的上下文均描述成<span
class="math inline">\(c\)</span>, 这其实表明<span
class="math inline">\(x\)</span>和<span
class="math inline">\(o_i\)</span>的上下文来源相同, 而不代表这两个<span
class="math inline">\(c\)</span>是一致的,
主要原因是限制两者的<code>k</code>不一定相同.为了区分, 令其为<span
class="math inline">\(c_x\)</span>和<span
class="math inline">\(c_o\)</span>, 笔者通过一个例子说明原因.</p>
<p>假设使用<strong>CallSite敏感</strong>策略, <code>k = 2</code>,
令堆上下文为<code>k - 1 = 1</code>.
那么传入的<code>c:method</code>的上下文为<code>[3, 9]</code>,
在该Method中有<code>15: y = new T()</code>, 对于<code>y</code>,
其上下文为<code>[3, 9]</code>, 但对于<code>o15</code>,
其上下文为<code>[9]</code>.
即二者上下文均来自<code>c:method</code>的上下文<span
class="math inline">\(c\)</span>, 但由于层数不同,
上下文也可能是不同的.</p>
</blockquote></li>
<li><p>对于<strong>静态</strong><code>Stmt Invoke</code>的处理,
最好调用<code>Context selectContext(CSCallSite, JMethod)</code>而不是<code>Context selectContext(CSCallSite, CSObj, JMethod)</code>,
这是更符合框架代码API的描述的用法. 当然,
也可以选择在Task2中的后者加入静态调用的处理,
这样就可以在<code>Solver</code>中统一使用同一个方法.</p></li>
</ul>
<h2 id="task2-实现常见的上下文敏感策略">Task2
实现常见的上下文敏感策略</h2>
<img src="/LabRecord-SPA-A6/pic1-3.png" class="" title="pic1-3">
<ul>
<li><p>注意手册上的要求和明确根据<strong>哪个参数</strong>获取上下文即可.
该部分并不难实现.</p></li>
<li><p>另外需要注意的是框架中将四个参数合并为三个,
<code>CSCallSite</code>中包含了<code>Context</code>和<code>Invoke</code>两个参数.</p></li>
<li><p>注意手册中对静态方法的处理要求,
<strong>CallSite</strong>和<strong>Object</strong>,
<strong>Type</strong>的要求并不一致.</p></li>
<li><p>对于<code>selectContext()</code>处理方法调用的上下文,
需要根据参数新生成一层;
但对于<code>selectHeapContext()</code>处理堆的上下文,
则直接根据参数截取即可.</p></li>
</ul>
<h3 id="callselector-_2callselector">_1CallSelector &amp;
_2CallSelector</h3>
<p>对于<strong>CallSite敏感</strong>策略,
上下文自然在参数<code>CSCallSite callSite</code>中获取.</p>
<p>如果<code>k = 2</code>,
枚举<code>Context</code>的层数选择最后一个和新上下文组合即可.</p>
<h3 id="objselector-_2objselector">_1ObjSelector &amp;
_2ObjSelector</h3>
<p>对于<strong>Object敏感</strong>策略,
上下文需要在<code>CSObj recv</code>中获取.</p>
<h3 id="typeselector-_2typeselector">_1TypeSelector &amp;
_2TypeSelector</h3>
<p>对于<strong>Type敏感</strong>策略,
上下文也需要在<code>CSObj recv</code>中获取.
(想一想<code>Type</code>上下文选取是如何来的)</p>
<p>根据<strong>Type敏感</strong>的定义,
可以在框架代码中找到一个对应的API: <code>Obj.getContainerType()</code>.
通过该方法获取<code>Type</code>即可.</p>
<h2 id="总结">总结</h2>
<p>如果理解了CI指针分析, 本次CS指针分析实验的原理和逻辑就不难理解,
但细节处理上比A5要麻烦很多, 还请小心仔细.</p>
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A8-Taint Analysis</title>
    <url>/LabRecord-SPA-A8/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-8 Taint
Analysis.</strong></p>
<span id="more"></span>
<h2 id="实验目标">实验目标</h2>
<p>基于<strong>tai-e</strong>框架实现污点分析.</p>
<h2 id="preparation">Preparation</h2>
<p>将A6的代码复制到此处.</p>
<p><strong>注意:</strong>
A8的<code>Solver</code>中额外加入了污点分析所需的字段,
因此不能直接替换A8的<code>Solver</code>.</p>
<h2 id="部分框架代码带读">部分框架代码带读</h2>
<p>在上过课程和阅读了实验指南后, 对于怎么做这个实验会有一个大概的思路,
那么不妨先阅读一下框架代码, 看看Tai-e提供了什么样的工具和API.</p>
<h3 id="source-sink">Source &amp; Sink</h3>
<p>分别代表了污点分析中的Source和Sink语句,
结构为<code>Source&lt;JMethod, Type&gt;</code>和<code>Sink&lt;JMethod, index&gt;</code>.</p>
<blockquote>
<p><strong>Tips:</strong>
<code>record</code>的用法在之前的实验已经接触过了, 简单来说,
可以通过<code>source.method()</code>获取其中的<code>JMethod method</code>信息.</p>
</blockquote>
<h3 id="tainttransfer">TaintTransfer</h3>
<p>对应污点传播的类, 即实验指南中的:</p>
<img src="/LabRecord-SPA-A8/pic1-1.png" class="" title="pic1-1">
<p>具体规则实验指南和框架代码已足够清晰.</p>
<h3 id="taintmanager">TaintManager</h3>
<p>实验框架中用来管理污点对象的类(或许命名为<code>TaintObjManager</code>更合适).</p>
<p>类内采用简单的Map实现<code>&lt;(Invoke, Type), TaintObj&gt;</code>的查找.</p>
<p><strong>注意: 笔者为了方便表述,
使用<code>TaintObj</code>表示污点对象,
该类在框架代码中并不存在.</strong></p>
<p>其中包含三个方法:</p>
<ul>
<li><p><code>Obj makeTaint(Invoke source, Type type)</code>返回一个污点对象实例.</p>
<blockquote>
<p><strong>Tips:</strong> 注意到污点对象也是<code>obj</code>,
即<code>taintObj</code>可以使用<code>obj</code>的方法进行操作.</p>
</blockquote></li>
<li><p><code>boolean isTaint(Obj obj)</code>判断一个<code>Obj</code>是否为<code>TaintObj</code>.</p></li>
<li><p><code>Invoke getSourceCall(Obj obj)</code>返回该对象实例化对应的<code>Invoke</code>.</p></li>
</ul>
<h3 id="taintflow">TaintFlow</h3>
<p>表示<code>Source -&gt; Sink</code>的污染流,
也即污点分析的结果(TT老师在本次课程中一嘴带过的可以追踪的<code>Source -&gt; Sink</code>).</p>
<h3 id="taintconfig">TaintConfig</h3>
<p><del>碎碎念:
不是为什么要把管理污点分析所需的数据结构和设置污点分析的配置两个功能都塞进来啊喂!!!
阅读类名谁能知道会把数据结构放在这里啊喂!!!</del></p>
<p>存储污点分析所需的信息, 可以通过<code>getSources()</code>,
<code>getSinks()</code>, <code>getTransfers()</code>获取,
注意返回的类型是<code>Set</code>,
请使用<code>Set</code>的API对其进行操作.</p>
<p>可以看出,
TaintSources和TaintSinks以及TaintTransfers的规则在该类中已经配置 完成,
可以在实验中<strong>直接使用</strong>.</p>
<blockquote>
<p><strong>Tips</strong> 其余部分都是有关配置污点分析的工具,
本次实验不需要过多了解, 读者若有兴趣可以自行阅读框架代码.</p>
</blockquote>
<h3 id="taintanalysis">TaintAnalysis</h3>
<blockquote>
<p><strong>Tips:</strong>
实验指南解释了为何是<code>TaintAnalysiss</code>,
笔者在此使用更容易理解的表述.</p>
</blockquote>
<p>本次实验主要的逻辑实现部分,
<code>Solver</code>可以根据其中的<code>taintAnalysis</code>字段调用<code>TaintAnalysis</code>中的API,
从代码规范角度, 处理污点分析的代码应当在此处完成,
<code>Solver</code>中仅调用API.</p>
<p>先看看该类具有哪些字段:</p>
<ul>
<li><code>TaintManager manager</code></li>
<li><code>TaintConfig config</code></li>
<li><code>Solver solver</code></li>
<li><code>CSManager csManager</code></li>
<li><code>Context emptyContext</code></li>
</ul>
<p>注意到除了污点分析相关组件,
<code>TaintAnalysis</code>也可以和<code>Solver</code>和<code>CSManager</code>通信,
并且给出了一个<code>emptyContext</code>, 以供直接使用.</p>
<p>以上字段均在实例化时被初始化.</p>
<p>接着看看类中的方法:</p>
<ul>
<li><p><code>void onFinish()</code>,
向外部(这里是<code>Solver</code>)给出污点分析结果<code>taintFlows</code>.</p></li>
<li><p><code>Set&lt;TaintFlow&gt; collectTaintFlows()</code>,
该部分等待完成, 用以计算所有的污染流.</p></li>
</ul>
<h3 id="solver">Solver</h3>
<p>到此已经知道所有污点分析相关类了,
现在从顶层<code>Solver</code>中看看污点分析的使用.</p>
<ul>
<li><code>void solve()</code>是指针分析的步骤, 可以看到相比A6,
最后一步设置了污点分析结果. 换句话说,
本次实验中只需要考虑污点分析的实现,
污点分析的前置工作和结果存储框架都已经做好了.</li>
</ul>
<h2 id="算法设计">算法设计</h2>
<h3 id="基本假设">基本假设</h3>
<p>在本次实验的污点分析中, 有几个基本假设:</p>
<ul>
<li><p><code>TaintObj</code>只会由<code>Source</code>产生,
依据<code>TaintTransfer</code>的规则, 最终传播到<code>Sink</code>.
其中<code>Source</code>的语句类型均为<code>Invoke</code>.</p></li>
<li><p>本次实验不考虑<strong>隐式污染</strong>(详见<a
href="https://cs.nju.edu.cn/tiantan/software-analysis/Security.pdf#page=44"><strong>课程ppt</strong></a>),
这大大简化了本次实验分析难度.</p></li>
<li><p><code>TaintObj</code>是以<code>Obj</code>的方式进行封装的,
这意味着<code>TaintObj</code>可以像<code>Obj</code>一样在指针流图<code>PointerFlowGraph</code>中传递.</p>
<blockquote>
<p><strong>Tips: 这意味着什么?</strong></p>
<p>这意味着除了<strong>TaintTransfer</strong>和<strong>Source
Invoke</strong>的传播途径外,
<code>TaintObj</code>的其余传播途径都可以在之前的指针分析实现中完成.(如果感到难以理解可以试试推一下<code>Assign</code>,
<code>Store</code>和<code>Load</code>语句的传播)</p>
</blockquote></li>
<li><p><code>TaintObj</code>的上下文被简单的处理成<code>emptyContext</code>,
即来自同一个<code>Index: Invoke</code>的<code>TaintObj</code>在堆中被抽象为一个对象.</p></li>
<li><p><strong><em>(存疑)</em></strong> Online
Judge上似乎所有的<code>Source</code>相关语句<strong>均是静态方法</strong>,
因此理论上不需要进行<strong>dispatch</strong>也可以通过测试.</p></li>
</ul>
<h3 id="source-sink-tainttransferflow">Source &amp; Sink &amp;
TaintTransferFlow</h3>
<p>三者均是在<code>Invoke</code>上进行操作,
因此需要修的地方有<code>processCall</code>和<code>addReachable</code>.</p>
<ul>
<li><p>对于<code>Source</code>, 只需要按实验指南上的规则处理即可.
但需要注意的是, 只有当<code>Invoke</code>存在返回值时,
才执行<code>Source</code>的处理.</p></li>
<li><p>对于<code>Sink</code>, 可以选择边迭代边处理.
但因为<strong>Pointer Analysis</strong>不依赖于<code>Sink</code>,
也可以在算法跑完后遍历所有的<code>Sink</code>语句的参数的<code>PointsToSet</code>是否包含<code>TaintObj</code>.
也就是说,
这部分代码可以在<code>collectTaintFlows()</code>中统一完成.</p></li>
<li><p>对于<code>TaintTransferFlow</code>,
同样只需要小心的按照指南规则处理即可. 但需要注意的是,
由于污点数据流向目标时可能会有类型转换,
因此需要创建一个新的<code>TaintObj</code>实例赋值给目标的<code>PointsToSet</code>.</p></li>
</ul>
<h3 id="污点数据的广播">污点数据的广播</h3>
<p>污点数据的传播逻辑处理是本次实验相对简单的部分,
困难的是想清楚如何传播污点数据.</p>
<p>想知道答案, 就要先回顾一下指针分析的广播.</p>
<img src="/LabRecord-SPA-A8/pic1-2.png" class="" title="pic1-2">
<p>这个大循环中当<code>n</code>是变量<code>x</code>时,
对相关语句进行广播.</p>
<p>如在A5, A6中,
需要对<code>Array</code>和<code>Filed</code>以及<code>processCall</code>进行广播.</p>
<p>污点分析也是一种指针分析, 那么其理应也在这里广播.</p>
<p><code>from -&gt; to</code>的情况有三种,
<code>from</code>的取值只有<code>Arg</code>和<code>Base</code>两种情况.</p>
<ul>
<li><p><code>Base</code>的广播可以在<code>processCall</code>中进行,
因为二者中变量<code>x</code>都作为<code>Base</code>出现.</p></li>
<li><p><code>Arg</code>的广播没有现成的方法, 那么就考虑与其余情况并列,
若<code>x</code>是某条<code>Invoke</code>的实参时, 则需要广播到此处,
为该<code>Invoke</code>执行<code>TaintTransferFlow</code></p></li>
</ul>
<p>特别的, 因为这样的特性,
你也可以考虑将<code>TaintTransferFlow</code>拆开来写.
这样更符合其广播逻辑.</p>
<h2 id="拾遗">拾遗</h2>
<p>本次实验几乎不涉及新的方法和工具(当然你也可以选择使用一些隐藏API来完成本次实验,
例如对于<strong>Instance Invoke</strong>,
可以通过<code>((InvokeInstanceExp)(invoke.getInvokeExp())).getBase()</code>来获取<code>base</code>信息).</p>
<p><strong>All you need has already in Tai-e.</strong></p>
<h2 id="总结">总结</h2>
<p>完结撒花啦!</p>
<img src="/LabRecord-SPA-A8/pic1-3.png" class="" title="pic1-3">
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU静态分析|A7-Alias-Aware Interprocedural Constant Propagation</title>
    <url>/LabRecord-SPA-A7/</url>
    <content><![CDATA[<p><strong>NJU Static Program Analysis | Assignment-7 Alias-Aware
Interprocedural Constant Propagation.</strong></p>
<span id="more"></span>
<h2 id="实验目标">实验目标</h2>
<p>基于<strong>tai-e</strong>框架实现带别名分析的过程间常量传播.</p>
<h2 id="preparation">Preparation</h2>
<ul>
<li><p>将<code>A2/.../ConstantPropagation</code>复制到<code>A7/.../ConstantPropagation</code></p></li>
<li><p>将<code>A4/.../InterConstantPropagation</code>复制到<code>A7/.../InterConstantPropagation</code></p></li>
<li><p>将<code>A4/.../InterSolver</code>复制到<code>A7/InterSolver</code></p></li>
<li><p>将<code>A6/.../cs/Solver</code>复制到<code>A7/.../cs/Solver</code></p></li>
<li><p>将<code>A6/.../_2ObjSelector</code>复制到<code>A7/.../_2ObjSelector</code></p>
<blockquote>
<p><strong>Tips:</strong>
<code>plan.yml</code>已经配置好了<code>cs: 2-obj</code>,
如果本地测试中想要使用其他策略,
需要将对应<code>Selector</code>复制到本次实验目录,
并配置<code>plan.yml</code>(方法已在A6实验指南中给出)</p>
</blockquote></li>
</ul>
<p><strong><em>注意:</em></strong>
除去指针分析的部分作为结果查询字段指向外,
其余文件都可以是本次实验的更改范围.</p>
<h2 id="review">Review</h2>
<p>由于要设计算法, 不妨先复习一下A2和A4中常量传播算法和应用范围.</p>
<ul>
<li><p>常量传播算法是<strong>Forward &amp; Must Analysis</strong>.
迭代至收敛至"最大"不动点.</p>
<blockquote>
<p><strong>Additional:</strong></p>
<p>迭代算法框架如下:</p>
<img src="/LabRecord-SPA-A7/pic1-1.png" class="" title="pic1-1">
<p>活跃变量分析的迭代示例:</p>
<img src="/LabRecord-SPA-A7/pic1-2.png" class="" title="pic1-2">
</blockquote></li>
<li><p>常量传播算法中对数值的抽象为<code>UNDEF-&gt;CONST-&gt;NAC</code>.</p></li>
<li><p>由于数据流动的"单调性", <strong>Meet</strong>要满足</p>
<blockquote>
<img src="/LabRecord-SPA-A7/pic1-3.png" class="" title="pic1-3">
</blockquote></li>
<li><p>语句处理的<strong>Transfer Function</strong></p>
<blockquote>
<img src="/LabRecord-SPA-A7/pic1-4.png" class="" title="pic1-4">
</blockquote></li>
</ul>
<blockquote>
<p>在A2中,
处理范围仅限于<code>DefinitionStmt</code>中的变量和表达式部分,
对于诸如<strong>字段, 数组</strong>部分采取保守策略,
赋值为<code>NAC</code>; 分析范围仅局限于<strong>过程内分析</strong>,
此时为方法调用的返回值采取保守策略, 赋值为<code>NAC</code>.</p>
<p>在A4中, 同样只处理变量, 但分析范围扩展为过程间分析,
需要完成对方法调用传参, 传返回值, 为了完成过程间的数据流传递,
加入了<strong>Transfer Edge</strong>.</p>
<p>由于方法调用的<strong>动态时确认</strong>,
需要知道在这个调用点<code>callsite</code>,
真正的<code>callee</code>是什么,
因此建立<strong>CallGraph</strong>为<strong>ICFG(inter-procedural
control-flow graph)</strong>
提供调用图信息.(你应该还记得在A4的<code>CHABuilder</code>完成前,
<code>Assignment</code>不会输出任何ICFG信息)</p>
<img src="/LabRecord-SPA-A7/pic1-5.png" class="" title="pic1-5">
</blockquote>
<h2 id="requirement-analysis">Requirement &amp; Analysis</h2>
<p>现在来看看实验要求和手上的工具, 看看如何处理新需求.</p>
<h3 id="常量处理范围">常量处理范围</h3>
<p>在之前的实验中,
忽略了<strong>字段Field</strong>和<strong>数组Array</strong>的分析,
原因在本次实验已经指出, 是<strong>别名Alias</strong>所引起的,
由于多个变量(指针)可以指向同一个对象, 只有当明确指针所指向对象时,
才能为其赋值<strong>常量Constant</strong>.</p>
<p>需要指出的是, 本次实验仍然<strong>只需要处理int类型的变量</strong>.
A2中已经提供了足够好用的<code>canHoldInt()</code>.</p>
<p>另外,
指南上讲述了实验框架中会忽略<strong>静态字段的初始化</strong>的情况,
因其在控制流图中不可达, 不需要对其进行额外的处理.</p>
<h3 id="域分析范围">域分析范围</h3>
<p>A4开始采用了一种精度较低的方法CHA构建<strong>CallGraph</strong>; A5,
A6使用了精度更高的指针分析技术构建<strong>CallGraph</strong>.</p>
<p>本次实验仍然是处理<strong>过程间常量传播</strong>,
由于<strong>CallGraph</strong>更加精确, 分析精度相较于A4也会更进一步.
同时,
在Tai-e框架下完成实验不需要关注<strong>ICFG</strong>如何获得<strong>CG</strong>信息(如有兴趣可自行阅读框架代码).</p>
<h3 id="pointeranalysisresult">PointerAnalysisResult</h3>
<p>框架代码提供了<code>class PointerAnalysisResult</code>用来获取指针分析的结果,
该部分的初始化在<code>InterConstantPropagation</code>中的<code>initial()</code>中完成.</p>
<p>其中包含的API说明都较为清晰, 笔者在此不过多赘述.</p>
<h3 id="别名分析">别名分析</h3>
<p>该部分实验指南已经给出了一个比较简单的实现方法,
<strong>Pointer指向的PointsToSet存在交集,
则认为二者互为别名.</strong></p>
<p>换个说法, <strong>存在两个或两个以上Pointer指向同一个Obj,
则认为二者互为别名.</strong></p>
<p>实验指南中讲述了为什么只需要<code>Pointer</code>而不是<code>CSPointer</code>的原因</p>
<p>笔者在此给出两个简单的算法思路:</p>
<ul>
<li><p>遍历所有的<code>Pointer1</code>与<code>Pointer2</code>,
获取<code>PointsToSet</code>,
如果有交集就加入<code>Multiple Map</code>中,
简单地以<code>&lt;Var, Var&gt;</code>的形式维护alias信息.</p></li>
<li><p>遍历所有的<code>Pointer</code>和对应的<code>PointsToSet</code>,
维护一个<code>&lt;Obj, Var&gt;</code>结构,
对于<code>&lt;Obj, Var1&gt;</code>和<code>&lt;Obj, Var2&gt;</code>,
<code>Var1</code>和<code>Var2</code>互为别名.</p></li>
</ul>
<blockquote>
<p><strong>Tips: 框架代码的做法</strong></p>
<p>如果你有阅读过框架代码或者"意外"跳转到<code>class Maps</code>,
便会发现,
Tai-e框架中已经配置了好了获取基本数据结构的API(被TT深不可测的代码力所折服).
可以通过简单的<code>Maps.newMultiMap()</code>获取实例化数据结构. 当然,
也可以选择自己实例化Map的结构.</p>
<p>不过需要注意的是, 该部分代码<strong>不是显式给出的</strong>,
而是封装在<code>tai-e-assignment.jar</code>中,
可以选择阅读科研版doc或者阅读反编译后的源码(该部分结构简单,
即便无注释也可以理解)</p>
</blockquote>
<h3 id="field处理">Field处理</h3>
<p>在这里会遇到第一个头疼的点: <strong>ConstPropagation是流敏感的,
但PointerAnalysis是流不敏感的.</strong></p>
<p>尽管别名信息不依赖于常量传播, 但对象存储的值来源常量传播. 因此,
需要先理清楚如何处理<code>Load</code>和<code>Store</code>.(<strong>注意:</strong>
笔者以下论述基于InstanceField,
SaticField的处理只会比InstanceField简单)</p>
<blockquote>
<p><strong>Try: 先收集所有的Store再更新给Load?</strong></p>
<p>这是符合流不敏感的思路,
但是在ConstPropagation的流敏感框架中非常难以实现. 在迭代过程中,
Store的<strong>右值</strong>可能会改变,
Store的变化也会引起非Field和Array变量的变化. 所以,
Field和Array的更新也需要采用流敏感框架中的迭代方法.</p>
</blockquote>
<p>现在来分析如何用迭代的方法处理Field.</p>
<ul>
<li><p>对于Load, 因为迭代的缘故, 可以先假设后续的处理会正确的广播到此处,
更新Load的值. 因此只需要简单的传播到def即可.</p></li>
<li><p>对于Store, 假设已经有了一个对应的Load结构,
Store产生了更新该如何广播?
worklist加入<code>Load Stmt</code>迭代即可.</p></li>
<li><p>同时, 需要注意InstanceFiled的特性,
考虑别名信息进行更新即可.</p></li>
</ul>
<h3 id="array处理">Array处理</h3>
<p>Array可以理解成一种特殊的InstanceField, 不过需要注意何时互为别名,
只有在互为别名的情况下才考虑广播.</p>
<h3 id="小结">小结</h3>
<p>至此已经有了一个对完成本次实验的一个基本思路了,
接下来开始考虑一些完成实验的细节.</p>
<h2 id="算法设计">算法设计</h2>
<blockquote>
<p><strong>Tips:</strong> 笔者在此章节不详谈实现上的细节, 该部分在<a
href="#拾遗-tai-e-faq-you-need-to-know">拾遗</a>章节分点给出. 并且,
由于框架代码的特性, 算法的实现可能与思路有所出入.</p>
</blockquote>
<blockquote>
<p><strong>Question: 这次新写的代码和A4冲突吗?</strong></p>
<p>这个问题实际上是在问:
Field和Array的传播是否会影响到过程间常量传播的<strong>EdgeTransfer</strong>.</p>
<p>答案自然是否定的, Field和Array可以理解成一种特殊的Var,
尽管其结果不需要呈现在<code>DataFlowResult</code>中. 可以自然地得出结论:
加入Field和Array并不会改变A4的算法框架.</p>
<p>也即,
本次实验所设计的算法是对<strong>TransferNonCallNode(A2-IntraConstPropagation)</strong>的补全.</p>
</blockquote>
<p>所以, 本次算法的基本框架可以表示为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">transferNonCallNode</span><span class="params">(Stmt stmt, CPFact in, CPFact out)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> LoadField)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> StoreFiled)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> LoadArray)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> StoreArray)&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cp.transferNode(); <span class="comment">//form A2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然,
你也可以选择将这些语句的处理直接整合进<code>ConstantPropagation</code>(前提是A2的实现最好确保是正确的).</p>
<blockquote>
<p><strong>Tips:</strong>
还记得在A5和A6中是如何优雅地处理繁杂的<code>instanceof</code>判断吗? 对,
就是<strong>访问者模式</strong>, 在本次实验中,
仍然可以选择这样的方法实现算法.
所有的<code>Stmt</code>类中都已经内置了<code>accept()</code>API可供访问,
只需要新的访问类继承自<code>StmtVisitor</code>即可.</p>
</blockquote>
<h3
id="field-value的存储和广播"><code>&lt;Field, Value&gt;</code>的存储和广播</h3>
<blockquote>
<p><strong>Tips:</strong> 在Tai-e框架中, 将Array等效抽象成Field,
并不对<strong>Index</strong>做具体的区分(对<code>a[i]</code>和<code>a[j]</code>的store操作视为对同一对象<code>a[...]</code>的store操作).
尽管如此,
index信息也有助于分区<code>a[i]</code>和<code>a[j]</code>是否为别名,
从而决定是否需要广播. 因此, Array的维护会比Field更复杂, 但基本原理一致,
笔者在此章节<strong>不再</strong>赘述Array应如何处理.</p>
</blockquote>
<p>在之前的分析中已经获知了<a href="#别名分析">Alias信息</a>,
该部分算法的实现依赖于别名信息.</p>
<p>笔者在此给出两个算法思路抛砖引玉:</p>
<h4 id="只考虑alias层">只考虑Alias层</h4>
<p>这是个朴实但简单的想法:
所有的<code>y = x.f</code>来自也只来自<code>x.f = z</code>,
这句"废话"意味着什么?</p>
<p><strong>意味着其实根本就不需要考虑<code>x.f</code>或者说<code>oi.f</code>的取值,
如果想知道<code>y</code>可能的value值,
只需要<code>meet</code>所有的<code>z</code>就可以了.</strong></p>
<p>根据这个思路, 有:</p>
<ul>
<li><p>对于<code>LoadField</code>,
找到所有与<code>x.f</code>相关的<code>x'.f = z</code>,
其中<code>x'</code>是<code>x</code>的别名, <strong>meet</strong>
<code>z</code>的<code>value</code>值.
如果<code>y = meet(foreach(z))</code>有更新,
将其后续<code>Node</code>加入<code>workList</code>.</p></li>
<li><p>对于<code>StoreField</code>,
找到所有与<code>x.f</code>相关的<code>y = x'.f</code>,
其中<code>x'</code>是<code>x</code>的别名,
将这些<code>StoreField</code>加入<code>workList</code>.</p></li>
</ul>
<p>这个算法的优点是实现简单, 但缺点是效率低,
展现着独属于暴力的美学魅力.</p>
<p>其关键在于如何维护<code>&lt;Field, Stmt&gt;</code>的结构,
框架代码中有不少细节需要关注.</p>
<h4 id="考虑mapobj-value">考虑<code>Map&lt;Obj, Value&gt;</code></h4>
<p><code>x.f</code>中的<code>x</code>是<code>Pointer</code>,
真正存储Value值的是<code>Obj</code>,
因此可以考虑维护<code>&lt;Var, Obj&gt;</code>和<code>&lt;Obj.field, Value&gt;</code>两个Map,
<code>Load</code>和<code>Store</code>均对Map进行操作.</p>
<p>该思路避免了之前算法中的大量冗余计算(笔者自测跑完本地测试需要近30s),
提高了效率, 但Map的维护较为复杂.</p>
<p>具体处理<code>LoadField</code>和<code>StoreField</code>时,
只需要将信息更新到<code>Map&lt;Obj.field, Value&gt;</code>即可,
广播逻辑与之前相同.</p>
<p>不过需要注意的是, 由于指针分析结果是流不敏感的,
对于<code>Store</code>操作只使用<code>meet</code>而不是<code>kill</code>.</p>
<blockquote>
<p><strong>Question: Store语句应该在何时广播?</strong></p>
<p>答案是当<code>outFact</code>改变的时候广播,
或者具体来说,是<code>x.f = y</code>的<code>y</code>的value值改变时进行广播.</p>
</blockquote>
<h2 id="拾遗-tai-e-faq-you-need-to-know">拾遗: Tai-e FAQ You Need to
Know</h2>
<h3 id="cs-ci-pointer-analysis">CS &amp; CI Pointer Analysis</h3>
<p>CallGraph建立的ICFG是没有上下文的,
这和常量传播不关注上下文的行为一致.
但对<code>Pointer</code>指向信息可以使用带上下文的分析结果以获取更高的精度,
这与ICFG并不冲突.</p>
<h3 id="ir">IR</h3>
<p>IR的使用为本次实验做了大量简化, 你可能会疑惑,
对于<code>x.f = y.g</code>这样的操作,
上述算法框架可以覆盖到该语句吗?</p>
<p>实际上, <code>x.f = y.g</code>在IR中会被转化为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">21</span><span class="meta">@L16</span>] temp$<span class="number">8</span> = x.&lt;X: <span class="type">int</span> f&gt;;</span><br><span class="line">[<span class="number">22</span><span class="meta">@L16</span>] y.&lt;Y: <span class="type">int</span> g&gt; = temp$<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>与之类似的, <code>Invoke</code>,
<code>BinaryExp</code>也具有相同的特性.</p>
<p>如果不确定某条语句在框架中如何表示,
可以自己设计测试样例通过Assignment分析其结果.</p>
<p>回到这次实验,
可以简单认为<strong>所有<code>AssignStmt</code>的左值和右值中最多只有一个是Field/Array,
另外一个是Var</strong>.</p>
<h3
id="intersolver与interconstpropagation">InterSolver与InterConstPropagation</h3>
<p>InterConstPropagation的字段可以简单的通过参数的方式进行传递,
但InterSolver与InterConstPropagation间该如何通信?</p>
<p>注意到<code>InterConstantPropagation extends AbstractInterDataflowAnalysis</code>,
其父类中含有字段<code>InterSolver solver</code>,
可以通过<code>solver.xxx</code>实现通信.</p>
<p>对于其中的<code>private</code>和<code>protected</code>字段,
可以为其编写一个<code>public XType getX()</code>API提供访问接口.(如<code>result</code>,
<code>worklist</code>等).</p>
<h3 id="数据结构map">数据结构Map</h3>
<p>本次实验中存在大量"一对多"的联系,
可以考虑选取<code>MultiMap</code>进行维护.
其中提供了不少相当便捷的API.</p>
<h3 id="relevantstmt">relevantStmt</h3>
<p>如果能把字段中的Var取出,
可以使用其中的API<code>var.getStoreField()</code>等API方便的获取有关语句,
不过对Static就没有太好的方法了,
笔者采用的是遍历<code>icfg.getNodes()</code>.</p>
<h3 id="fieldstmt-fieldaccesss-filedref-jfield">FieldStmt, FieldAccesss,
FiledRef &amp; JField</h3>
<p>Tai-e框架中的Field的处理要比Array复杂不少, 笔者在此做简要解释.</p>
<ul>
<li><p>JField的结构是<code>&lt;Type: FieldName&gt;</code>,
可以使用<code>FieldStmt.getRef().resolve()</code>得到.
当使用Stmt解析出JField进行比较时会获取更高的精度.
(笔者因为这个卡了hidden test)</p></li>
<li><p>如果想获取Field的Obj(即base部分),
可以使用<code>FieldStmt.getFieldAccess().getBase()</code>.
不过需要先转换为<code>InstanceFieldAccess</code>类型才能使用<code>getBase()</code>的API.</p>
<blockquote>
<p><strong>Tips:</strong> 笔者在此吐槽一句,
为何关于Field的API都封装在了<code>tai-e-Assignemnt.jar</code>中而不是显式的给出,
增大了如何处理Field的学习成本.</p>
</blockquote></li>
</ul>
<h3 id="arraystmt">ArrayStmt</h3>
<p>Array的结构相对简单一点,
通过<code>getAccess()</code>就可以简单的<code>access.getBase/Index()</code>获取需要的信息.</p>
<h2 id="总结">总结</h2>
<p>恭喜挺过了本学期SPA的实验大魔王, 自己设计算法还是颇有难度的,
接下来迎接较为轻松的A8吧. (^_^)</p>
]]></content>
      <categories>
        <category>实验记录-NJU静态分析</category>
      </categories>
      <tags>
        <tag>NJU</tag>
        <tag>静态分析</tag>
      </tags>
  </entry>
  <entry>
    <title>千里之行，始于足下</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p><strong>A journey of a thousand miles begins with a single
step.</strong></p>
<span id="more"></span>
<img src="/hello-world/picture.png" class="" title="picture">
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode个人题解[C++] P4 寻找两个正序数组的中位数</title>
    <url>/LeetCode-P4/</url>
    <content><![CDATA[<p><strong>题目链接:</strong> <a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><strong>LeetCode|4.寻找两个正序数组的中位数</strong></a></p>
<span id="more"></span>
<hr />
<h2 id="题面解释">题面解释</h2>
<p>找出两个有序数组合并后的中位数. 但要求时间复杂度<span
class="math inline">\(\mathit{O}(log(m + n))\)</span>.</p>
<h2 id="解法一-二分">解法一 二分</h2>
<p>笔者看到复杂度<span class="math inline">\(\mathit{O}(log(m +
n))\)</span>第一想法便是二分, 但怎么二分? 两个数组只是内部有序,
两个数组并不有序, 常规对数组二分的思路肯定是不行的.</p>
<p>那该如何进行二分呢, 对答案进行二分. 令k为所寻找的k阶数, 初始为中位数,
则此时我们取两个数组的前<span
class="math inline">\(k/2\)</span>部分出来, 比较<span
class="math inline">\(nums1[k/2]\)</span>和<span
class="math inline">\(nums2[k/2]\)</span>, 则可以直接排除<span
class="math inline">\(k/2\)</span>个数. 我们以下图例子来解释.</p>
<img src="/LeetCode-P4/p1.png" class="" title="p1">
<p><span class="math inline">\(m = n = 4\)</span>, 我们有 <span
class="math inline">\(k = 4, k/2 = 2\)</span>,
于是我们取两个数组的前两位, 比较3和5, 不难看出, 1和3不可能是中位数.
为什么? 因为1和3的阶必定小于<span class="math inline">\(k = 4\)</span>,
即便第一个数组的3比第二个数组的5前面所有数都大, 3的阶也只能是3,
1就更不必说了. 而5前面的数可能大于3后面的数(例子中未能体现,
读者可以自行构造一个满足这种情况的简单例子). 因此通过这种操作,
我们可以排掉 <span class="math inline">\(k/2\)</span>
个不可能是中位数的元素, 接着我们令<span class="math inline">\(k = k -
k/2\)</span>, 将被排除的数去掉, 重新进行上述过程.</p>
<img src="/LeetCode-P4/p2.png" class="" title="p2">
<p>选取两个数组的前1位.比较2 和 4, 可以排除掉2. 此时过程进行到了边界处,
接下来<span class="math inline">\(k = 1\)</span>无法继续了.
而此时剩下的4和5正是我们需要的中位数.</p>
<blockquote>
<p><strong>Tips:</strong> 为什么第二个数组不是选择2, 5, 7?</p>
<p>因为我们在上面的步骤中无法确定2和5是中位数与否, 此时的有效信息不足.
而把2 5 7都放进来与4进行比较会出现bug, 以上例, 4会被错误的排除掉</p>
</blockquote>
<p>k为奇数时情况稍有不同, 但大多是一些细节问题, 笔者在此不再赘述.
推荐读者自己构建一个例子去推算上面的过程, 相信不难理解其中要义.</p>
<p>每次排除<span class="math inline">\(k/2\)</span>, 而 <span
class="math inline">\(k = (m + n + 1) / 2\)</span>, 故时间复杂度<span
class="math inline">\(\mathit{O}(log(m + n))\)</span>.</p>
<p>参考代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; m; i++)&#123;cout &lt;&lt; nums1[i] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; n; j++)&#123;cout &lt;&lt; nums2[j] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = (m + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 排除掉小于中位数的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组被清空</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// 注意循环条件 k &gt; 1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 边界情况，剩余数组大小不足k</span></span><br><span class="line">            <span class="keyword">if</span> (left1 + mid &gt; m) &#123; <span class="comment">// 等价于 left1 + mid - 1 &gt;= m</span></span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 + mid &gt; n) &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                k -= mid2 - left2 + <span class="number">1</span>; <span class="comment">// 一轮可以排除掉一半</span></span><br><span class="line">                left2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= mid1 - left1 + <span class="number">1</span>;</span><br><span class="line">                left1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 k == 1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                    left2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="built_in">return</span> (nums2[left2] + nums2[left2 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[left1] + nums1[left1 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num1;</span><br><span class="line">            <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                num1 = nums2[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = nums1[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                num2 = nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                num2 = nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (num1 + num2) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips:</strong> 本题思路并不难想出或者说并不难理解,
但非常考验代码功底, 对细节和边界情况的考察更像是此题的侧重点.
还望看到此处的读者能静下心来调试代码, 祝早日AC.</p>
</blockquote>
<h2 id="解法二-分割">解法二 分割</h2>
<blockquote>
<p>笔者阅读题解时注意到的巧妙的解法, 原链接在此<a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/"><strong>P4|windliang</strong></a></p>
</blockquote>
<p>更详细的数学证明, 思路和代码请阅读原文,
笔者在此只给出自己对其的理解.</p>
<p>本质来说, 两种方法殊途同归, 但分割的方法较为巧妙一些. 中位数,
或者说k阶数, 就是将数组分为两个部分, 其一是比k阶数小的部分,
其二是比k阶数大的部分.</p>
<p>对于有序的一个数组, 其性质本身就已经满足,
我们不妨将两部分简称为左半部分(小)和右半部分(大). 对于两个有序数组,
情况是一样的, 如果存在一种划分, 满足左边最大MaxLeft小于右边最小MinRight,
我们则认为这是关于k阶数的一种有效划分.</p>
<p>因此, 这道题就被转化为寻找数组中满足中位数的有效划分,
关于特定k阶数划分, 还需要满足左半部分和右半部分的数量关系,
若规定将k阶数划在左半部分, 则左半部分有k个元素, 右半部分有 n - k
个元素.</p>
<p>后面的事情就简单了, 固定数组1的划分位置,
根据数量关系找到数组2待判定划分位置,
根据MaxLeft和MinRight的大小关系决定数组1划分位置的左移或右移,
该过程可以通过二分完成.</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode个人题解[C++] P10 正则表达式匹配</title>
    <url>/LeetCode-P10/</url>
    <content><![CDATA[<p><strong>题目链接:</strong> <a
href="https://leetcode.cn/problems/regular-expression-matching/description/"><strong>LeetCode|10.正则表达式匹配</strong></a></p>
<span id="more"></span>
<hr />
<h2 id="题面解释">题面解释</h2>
<p>题目意思非常简单, 对字符串s和p进行匹配.(但写出来可一点都不简单啊)</p>
<p>不过需要注意的是,
<code>"*"匹配一个或多个前一个元素</code>的释义是<span
class="math inline">\(a*\rightarrow a^*\)</span>,
其中箭头右侧为正则文法.</p>
<h2 id="解法一-暴力回溯dfs">解法一 暴力回溯DFS</h2>
<p>先考虑假设不包含<code>*</code>的匹配过程.</p>
<p>那么当<code>s.length() != p.length()</code>时可以直接给出<code>false</code>,
或者当<code>s[i] != p[i] &amp;&amp; p[i] != '.'</code>时也可以直接给出<code>false</code>.
除非整个串匹配结束后则可以给出<code>true</code>.</p>
<p>因此难处理的部分应当是<code>*</code>的匹配过程.</p>
<p>下面用一个例子来分析<code>*</code>的匹配过程.</p>
<p>假设<code>s = abbbacc, p = ab*ab*cc</code></p>
<ul>
<li><p>对于<code>a</code>和<code>a</code>的匹配是自然的, 现在我们有:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = abbbacc</span><br><span class="line">     ^</span><br><span class="line">p = ab*ab*cc</span><br><span class="line">     ^</span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>接下来注意到p的模式为<code>b*</code>,
那么考虑枚举<code>b*</code>可以匹配的模式.</p>
<ul>
<li><p><code>case1: ''</code> 假设重复0个<code>b</code>, 我们有:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = abbbacc</span><br><span class="line">     ^</span><br><span class="line">p = ab*ab*cc</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>
<p>不难看出此时<code>b</code>无法匹配<code>a</code>,
case1匹配到这里不得不停下了.</p>
</blockquote></li>
<li><p><code>case2: b | bb</code> 假设重复一个或两个<code>b</code>,
此时和case1相同,
同样面临<code>b</code>不能匹配<code>a</code>的问题.</p></li>
<li><p><code>case3: bbb</code> 假设重复三个<code>b</code>, 此时有:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = abbbacc</span><br><span class="line">        ^</span><br><span class="line">p = ab*ab*cc</span><br><span class="line">       ^</span><br></pre></td></tr></table></figure>
<p>此时可以继续<code>a</code>和<code>a</code>的匹配.</p>
</blockquote></li>
<li><p><code>case4: bbbb|...</code> 假设重复四个或以上的<code>b</code>,
显然是无法匹配的.</p></li>
</ul></li>
<li><p>剩余部分的匹配与之前相似, 不难得出s和p匹配的结论.</p></li>
</ul>
<p>这就是处理<code>*</code>最朴素的思想, 直接枚举不同的组合,
看有没有机会匹配, 在上述例子中, 因为case3直接可以得出匹配的结论,
因此不需要处理case4.</p>
<p>至于为何一定要写成递归的DFS, 笔者在此给出一个例子, 可以自行推演.</p>
<blockquote>
<p><strong>Example:</strong> <code>s = abbbacc, p = ab*bbacc</code>.</p>
<p>实际上由于<code>.*</code>的存在, 会引起更加复杂的变化,
因此即便可以优化上述的例子, 此处最好的处理方式仍然是递归.</p>
</blockquote>
<p>由此我们可以得知DFS递归的基本框架:
每一次的压栈递归都代表枚举相应的<code>*</code>,
那么p中包含多少<code>*</code>最多就可能压多少递归栈.</p>
<p>可以预见到,
当<code>p.length()</code>和<code>s.length()</code>的规模增大时,
时间复杂度将会爆炸.</p>
<h2 id="解法二-动态规划dp">解法二 动态规划DP</h2>
<p>尽管上述的DFS性能堪忧, 但其思想还是很重要的, 有助于过渡到DP的方法.
<del>虽然可以预见到一群大神一眼看出是DP,
还能顺手把转移方程写出来</del></p>
<p>在上述过程中有一个计算是十分不必要的,
那就是"枚举完所有的"<code>a*</code>可以匹配的模式.</p>
<h3 id="状态转移方程求解">状态转移方程求解</h3>
<p>DFS的尝试是枚举所有的可能, 看是否能和后面的匹配上.
那么此时我们逆向思考这个问题,
对于<code>s[:i]</code>和<code>p[:j]</code>,
当得知哪些信息时可以判断是否匹配?</p>
<blockquote>
<p>为方便后续表述, 此处定义一个辅助函数<code>match(c1, c2)</code>,
当<code>c1 == c2 || c2 == '.'</code>时返回<code>true</code>,
否则返回<code>false</code>.</p>
<p><strong>注: 以下切片语法(<code>s[:i]</code>)遵循python的左闭右开原则,
字符串索引语法(<code>s[i]</code>)初始下标为0</strong></p>
</blockquote>
<ul>
<li>先从简单的部分开始考虑, 即<code>p[j - 1] != '*'</code>
<ul>
<li>如果<code>match(s[i - 1], p[j - 1]) == false</code>,
字符串尾部不匹配, 显然<code>s[:i]</code>和<code>p[:j]</code>不匹配.</li>
<li>如果<code>match(s[i - 1], p[j - 1]) == true</code>,
那么只要有<code>s[:i - 1]</code>和<code>p[:j - 1]</code>匹配,
则<code>s[:i]</code>和<code>p[:j]</code>匹配.</li>
</ul></li>
<li>接下来考虑稍微复杂的部分<code>p[j - 1] == '*'</code>
<ul>
<li>因为<code>*</code>具有左结合性,
因此<code>p[j - 2]</code>的信息对我们来说是重要的.
即<code>*</code>重复了哪一个字符.</li>
<li>如果有<code>match(s[i - 1], p[j - 2]) == true</code>,
其含义相当于由<code>*</code>多重复一个<code>p[j - 2]</code>进行匹配.
那么此时只要<code>s[:i - 1]</code>和<code>p[:j]</code>匹配,
就有<code>s[:i]</code>和<code>p[:j]</code>匹配</li>
<li>上述情况为<code>*</code>的扩展, 那么"零个"该如何处理?
只需要将p中的模式<code>a*</code>当作不存在,
考察<code>s[:i]</code>和<code>p[:j - 2]</code>是否匹配即可.</li>
</ul></li>
</ul>
<p>由此, 我们便得到了官方题解中的状态转移方程,
其中<code>f[i][j]</code>表示<code>s[:i]</code>和<code>p[:j]</code>是否匹配.</p>
<img src="/LeetCode-P10/pic1.png" class="" title="pic1">
<h3 id="边界条件考察">边界条件考察</h3>
<p>状态转移方程已经有了, 接下来回归到base case,
来想想边界条件的处理.</p>
<ul>
<li>显然<code>f[0][0] = true</code>, 因为空串和空串显然是匹配的.</li>
<li>对于<code>i != 0 &amp;&amp; j == 0</code>,
即s中若干个字符和p中零个字符, 显然有<code>f[i][0] = false</code>,
因为非空的s不可能匹配空串.</li>
<li>对于<code>i == 0 &amp;&amp; j != 0</code>,
即s中零个字符和p中若干个字符, 此时当且仅当p满足如下正则文法: <span
class="math inline">\(l \rightarrow .|a|b|...|z, \ p \rightarrow
(l*)^*\)</span> 时, 有<code>f][0][j] = true</code>.</li>
<li>此时已经处理了所有s为空串或p为空串的匹配情况, 因此在状态转移时,
只需要让初始时<code>i = 1, j = 1</code>即可.</li>
</ul>
<h3 id="参考代码">参考代码</h3>
<p>参考代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= m; j += <span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//输入样例保证p[j - 1] == &#x27;*&#x27;时 j-2&gt;=0</span></span><br><span class="line">                    dp[i][j] = dp[i][j] | dp[i][j - <span class="number">2</span>]; <span class="comment">//match 0</span></span><br><span class="line">                    <span class="comment">//match multi</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">match</span>(s[i - <span class="number">1</span>], p[j - <span class="number">2</span>]))&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j] | dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">match</span>(s[i - <span class="number">1</span>], p[j - <span class="number">1</span>]))&#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">char</span> sc, <span class="type">char</span> pc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pc == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sc == pc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
